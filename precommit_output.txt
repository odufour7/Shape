ruff.....................................................................Passed
ruff-format..............................................................Passed
codespell................................................................Passed
Analyze with Mypy........................................................Passed
numpydoc-validation......................................................Passed
Run tests with uv and pytest.............................................Passed
clang-format.............................................................Failed
- hook id: clang-format
- exit code: 1

tests/mechanical_layer/src/Main.cpp
====================
--- original

+++ formatted

@@ -16,65 +16,64 @@

 
 //  extern C is a trick for Python ctypes to work
 extern "C" {
-    /**
-     * @brief The main function of CrowdMechanics, and the only one to be called when used as a library.
-     *
-     * It reads static and dynamic XML files,
-     * stores everything and simulates the dynamics of the agents.
-     *
-     * @param files An array of file names. They should be given in a precise order:
-     *      - Parameters (directories, time step...)
-     *      - Materials (with Young's modulus and the shear modulus
-     *      - Geometry (obstacles)
-     *      - Agents
-     *      - Agent dynamics (current kinematics, and driving forces and torques)
-     *      - (optional) Agent interactions (the information about agent-to-agent and agent-to-obstacle contacts,
-     *                   if any, will be used.
-     *
-     * @return  EXIT_SUCCESS if the program executed successfully.
-     *          EXIT_FAILURE in case of issue(s) with any of the XML files' contents
-     */
-    int CrowdMechanics(char** files)
-    {
-        /*  Read general PARAMETERS */
-        if (const string parametersFile = files[0];
-            readParameters(parametersFile) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+/**
+ * @brief The main function of CrowdMechanics, and the only one to be called
+ * when used as a library.
+ *
+ * It reads static and dynamic XML files,
+ * stores everything and simulates the dynamics of the agents.
+ *
+ * @param files An array of file names. They should be given in a precise order:
+ *      - Parameters (directories, time step...)
+ *      - Materials (with Young's modulus and the shear modulus
+ *      - Geometry (obstacles)
+ *      - Agents
+ *      - Agent dynamics (current kinematics, and driving forces and torques)
+ *      - (optional) Agent interactions (the information about agent-to-agent
+ * and agent-to-obstacle contacts, if any, will be used.
+ *
+ * @return  EXIT_SUCCESS if the program executed successfully.
+ *          EXIT_FAILURE in case of issue(s) with any of the XML files' contents
+ */
+int CrowdMechanics(char** files) {
+  /*  Read general PARAMETERS */
+  if (const string parametersFile = files[0];
+      readParameters(parametersFile) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
-        /*  Read MATERIALS  */
-        //  Mapping between user-given id's and indexes in the program
-        map<string, int32_t> materialMapping;
-        if (const string materialsFile = pathStatic + files[1];
-            readMaterials(materialsFile, materialMapping) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Read MATERIALS  */
+  //  Mapping between user-given id's and indexes in the program
+  map<string, int32_t> materialMapping;
+  if (const string materialsFile = pathStatic + files[1];
+      readMaterials(materialsFile, materialMapping) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
-        /*  Read GEOMETRY   */
-        if (const string geometryFile = pathStatic + files[2];
-            readGeometry(geometryFile, materialMapping) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Read GEOMETRY   */
+  if (const string geometryFile = pathStatic + files[2];
+      readGeometry(geometryFile, materialMapping) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
-        /*  Read AGENTS */
-        vector<unsigned> nb_shapes_allagents, shapeIDagent;
-        vector<int> edges;
-        vector<double> radius_allshapes, masses, mois;
-        vector<double2> delta_gtos;
-        if (const string agentsFile = pathStatic + files[3];
-            readAgents(agentsFile, nb_shapes_allagents,
-                    shapeIDagent, edges, radius_allshapes, masses, mois,
-                    delta_gtos, materialMapping) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Read AGENTS */
+  vector<unsigned> nb_shapes_allagents, shapeIDagent;
+  vector<int> edges;
+  vector<double> radius_allshapes, masses, mois;
+  vector<double2> delta_gtos;
+  if (const string agentsFile = pathStatic + files[3];
+      readAgents(agentsFile, nb_shapes_allagents, shapeIDagent, edges,
+                 radius_allshapes, masses, mois, delta_gtos,
+                 materialMapping) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
+  /*  Initialise simulation  */
+  const string dynamicsFile = pathDynamic + files[4];
+  if (initialiseSetting(dynamicsFile, nb_shapes_allagents, shapeIDagent, edges,
+                        radius_allshapes, masses, mois,
+                        delta_gtos) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
-        /*  Initialise simulation  */
-        const string dynamicsFile = pathDynamic + files[4];
-        if (initialiseSetting(dynamicsFile, nb_shapes_allagents, shapeIDagent, edges,
-            radius_allshapes, masses, mois, delta_gtos) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Main program procedure  */
+  handleMechanicalLayer(dynamicsFile);
 
-
-        /*  Main program procedure  */
-        handleMechanicalLayer(dynamicsFile);
-
-        return EXIT_SUCCESS;
-    }
+  return EXIT_SUCCESS;
 }
+}
tests/mechanical_layer/include/CrowdMechanics.h
====================
--- original

+++ formatted

@@ -1,16 +1,16 @@

 #ifndef MAIN_H
 #define MAIN_H
 
-#include "InputStatic.h"
 #include "Crowd.h"
 #include "Globals.h"
+#include "InputStatic.h"
 
 /*
     Functions
                 */
 //  Main
-extern "C" {            //  extern C is a trick for Python ctypes to work
-    int CrowdMechanics(char** files);
+extern "C" {  //  extern C is a trick for Python ctypes to work
+int CrowdMechanics(char** files);
 }
 
-#endif  /*  MAIN_H  */
+#endif /*  MAIN_H  */
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h
====================
--- original

+++ formatted

@@ -25,76 +25,89 @@

 #define TINYXML2_INCLUDED
 
 #if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)
-#   include <ctype.h>
-#   include <limits.h>
-#   include <stdio.h>
-#   include <stdlib.h>
-#   include <string.h>
-#	if defined(__PS3__)
-#		include <stddef.h>
-#	endif
+#include <ctype.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined(__PS3__)
+#include <stddef.h>
+#endif
 #else
-#   include <cctype>
-#   include <climits>
-#   include <cstdio>
-#   include <cstdlib>
-#   include <cstring>
+#include <cctype>
+#include <climits>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
 #endif
 #include <stdint.h>
 
 /*
-	gcc:
+        gcc:
         g++ -Wall -DTINYXML2_DEBUG tinyxml2.cpp xmltest.cpp -o gccxmltest.exe
 
     Formatting, Artistic Style:
-        AStyle.exe --style=1tbs --indent-switches --break-closing-brackets --indent-preprocessor tinyxml2.cpp tinyxml2.h
+        AStyle.exe --style=1tbs --indent-switches --break-closing-brackets
+   --indent-preprocessor tinyxml2.cpp tinyxml2.h
 */
 
-#if defined( _DEBUG ) || defined (__DEBUG__)
-#   ifndef TINYXML2_DEBUG
-#       define TINYXML2_DEBUG
-#   endif
+#if defined(_DEBUG) || defined(__DEBUG__)
+#ifndef TINYXML2_DEBUG
+#define TINYXML2_DEBUG
 #endif
+#endif
 
 #ifdef _MSC_VER
-#   pragma warning(push)
-#   pragma warning(disable: 4251)
+#pragma warning(push)
+#pragma warning(disable : 4251)
 #endif
 
 #ifdef _MSC_VER
-#   ifdef TINYXML2_EXPORT
-#       define TINYXML2_LIB __declspec(dllexport)
-#   elif defined(TINYXML2_IMPORT)
-#       define TINYXML2_LIB __declspec(dllimport)
-#   else
-#       define TINYXML2_LIB
-#   endif
+#ifdef TINYXML2_EXPORT
+#define TINYXML2_LIB __declspec(dllexport)
+#elif defined(TINYXML2_IMPORT)
+#define TINYXML2_LIB __declspec(dllimport)
+#else
+#define TINYXML2_LIB
+#endif
 #elif __GNUC__ >= 4
-#   define TINYXML2_LIB __attribute__((visibility("default")))
+#define TINYXML2_LIB __attribute__((visibility("default")))
 #else
-#   define TINYXML2_LIB
+#define TINYXML2_LIB
 #endif
-
 
 #if !defined(TIXMLASSERT)
 #if defined(TINYXML2_DEBUG)
-#   if defined(_MSC_VER)
-#       // "(void)0," is for suppressing C4127 warning in "assert(false)", "assert(true)" and the like
-#       define TIXMLASSERT( x )           do { if ( !((void)0,(x))) { __debugbreak(); } } while(false)
-#   elif defined (ANDROID_NDK)
-#       include <android/log.h>
-#       define TIXMLASSERT( x )           do { if ( !(x)) { __android_log_assert( "assert", "grinliz", "ASSERT in '%s' at %d.", __FILE__, __LINE__ ); } } while(false)
-#   else
-#       include <assert.h>
-#       define TIXMLASSERT                assert
-#   endif
+#if defined(_MSC_VER)
+#// "(void)0," is for suppressing C4127 warning in "assert(false)", "assert(true)" and the like
+#define TIXMLASSERT(x)     \
+  do {                     \
+    if (!((void)0, (x))) { \
+      __debugbreak();      \
+    }                      \
+  } while (false)
+#elif defined(ANDROID_NDK)
+#include <android/log.h>
+#define TIXMLASSERT(x)                                                   \
+  do {                                                                   \
+    if (!(x)) {                                                          \
+      __android_log_assert("assert", "grinliz", "ASSERT in '%s' at %d.", \
+                           __FILE__, __LINE__);                          \
+    }                                                                    \
+  } while (false)
 #else
-#   define TIXMLASSERT( x )               do {} while(false)
+#include <assert.h>
+#define TIXMLASSERT assert
+#endif
+#else
+#define TIXMLASSERT(x) \
+  do {                 \
+  } while (false)
 #endif
 #endif
 
 /* Versioning, past 1.0.14:
-	http://semver.org/
+        http://semver.org/
 */
 static const int TIXML2_MAJOR_VERSION = 11;
 static const int TIXML2_MINOR_VERSION = 0;
@@ -111,8 +124,7 @@

 // so there needs to be a limit in place.
 static const int TINYXML2_MAX_ELEMENT_DEPTH = 500;
 
-namespace tinyxml2
-{
+namespace tinyxml2 {
 class XMLDocument;
 class XMLElement;
 class XMLAttribute;
@@ -123,2262 +135,2111 @@

 class XMLPrinter;
 
 /*
-	A class that wraps strings. Normally stores the start and end
-	pointers into the XML file itself, and will apply normalization
-	and entity translation if actually read. Can also store (and memory
-	manage) a traditional char[]
+        A class that wraps strings. Normally stores the start and end
+        pointers into the XML file itself, and will apply normalization
+        and entity translation if actually read. Can also store (and memory
+        manage) a traditional char[]
 
     Isn't clear why TINYXML2_LIB is needed; but seems to fix #719
 */
-class TINYXML2_LIB StrPair
-{
-public:
-    enum Mode {
-        NEEDS_ENTITY_PROCESSING			= 0x01,
-        NEEDS_NEWLINE_NORMALIZATION		= 0x02,
-        NEEDS_WHITESPACE_COLLAPSING     = 0x04,
-
-        TEXT_ELEMENT		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
-        TEXT_ELEMENT_LEAVE_ENTITIES		= NEEDS_NEWLINE_NORMALIZATION,
-        ATTRIBUTE_NAME		            = 0,
-        ATTRIBUTE_VALUE		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
-        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,
-        COMMENT							= NEEDS_NEWLINE_NORMALIZATION
-    };
-
-    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}
-    ~StrPair();
-
-    void Set( char* start, char* end, int flags ) {
-        TIXMLASSERT( start );
-        TIXMLASSERT( end );
-        Reset();
-        _start  = start;
-        _end    = end;
-        _flags  = flags | NEEDS_FLUSH;
-    }
-
-    const char* GetStr();
-
-    bool Empty() const {
-        return _start == _end;
-    }
-
-    void SetInternedStr( const char* str ) {
-        Reset();
-        _start = const_cast<char*>(str);
-    }
-
-    void SetStr( const char* str, int flags=0 );
-
-    char* ParseText( char* in, const char* endTag, int strFlags, int* curLineNumPtr );
-    char* ParseName( char* in );
-
-    void TransferTo( StrPair* other );
-	void Reset();
-
-private:
-    void CollapseWhitespace();
-
-    enum {
-        NEEDS_FLUSH = 0x100,
-        NEEDS_DELETE = 0x200
-    };
-
-    int     _flags;
-    char*   _start;
-    char*   _end;
-
-    StrPair( const StrPair& other );	// not supported
-    void operator=( const StrPair& other );	// not supported, use TransferTo()
+class TINYXML2_LIB StrPair {
+ public:
+  enum Mode {
+    NEEDS_ENTITY_PROCESSING = 0x01,
+    NEEDS_NEWLINE_NORMALIZATION = 0x02,
+    NEEDS_WHITESPACE_COLLAPSING = 0x04,
+
+    TEXT_ELEMENT = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
+    TEXT_ELEMENT_LEAVE_ENTITIES = NEEDS_NEWLINE_NORMALIZATION,
+    ATTRIBUTE_NAME = 0,
+    ATTRIBUTE_VALUE = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
+    ATTRIBUTE_VALUE_LEAVE_ENTITIES = NEEDS_NEWLINE_NORMALIZATION,
+    COMMENT = NEEDS_NEWLINE_NORMALIZATION
+  };
+
+  StrPair() : _flags(0), _start(0), _end(0) {}
+  ~StrPair();
+
+  void Set(char* start, char* end, int flags) {
+    TIXMLASSERT(start);
+    TIXMLASSERT(end);
+    Reset();
+    _start = start;
+    _end = end;
+    _flags = flags | NEEDS_FLUSH;
+  }
+
+  const char* GetStr();
+
+  bool Empty() const { return _start == _end; }
+
+  void SetInternedStr(const char* str) {
+    Reset();
+    _start = const_cast<char*>(str);
+  }
+
+  void SetStr(const char* str, int flags = 0);
+
+  char* ParseText(char* in, const char* endTag, int strFlags,
+                  int* curLineNumPtr);
+  char* ParseName(char* in);
+
+  void TransferTo(StrPair* other);
+  void Reset();
+
+ private:
+  void CollapseWhitespace();
+
+  enum { NEEDS_FLUSH = 0x100, NEEDS_DELETE = 0x200 };
+
+  int _flags;
+  char* _start;
+  char* _end;
+
+  StrPair(const StrPair& other);         // not supported
+  void operator=(const StrPair& other);  // not supported, use TransferTo()
 };
 
-
 /*
-	A dynamic array of Plain Old Data. Doesn't support constructors, etc.
-	Has a small initial memory pool, so that low or no usage will not
-	cause a call to new/delete
+        A dynamic array of Plain Old Data. Doesn't support constructors, etc.
+        Has a small initial memory pool, so that low or no usage will not
+        cause a call to new/delete
 */
 template <class T, size_t INITIAL_SIZE>
-class DynArray
-{
-public:
-    DynArray() :
-        _mem( _pool ),
-        _allocated( INITIAL_SIZE ),
-        _size( 0 )
-    {
+class DynArray {
+ public:
+  DynArray() : _mem(_pool), _allocated(INITIAL_SIZE), _size(0) {}
+
+  ~DynArray() {
+    if (_mem != _pool) {
+      delete[] _mem;
     }
-
-    ~DynArray() {
-        if ( _mem != _pool ) {
-            delete [] _mem;
-        }
+  }
+
+  void Clear() { _size = 0; }
+
+  void Push(T t) {
+    TIXMLASSERT(_size < INT_MAX);
+    EnsureCapacity(_size + 1);
+    _mem[_size] = t;
+    ++_size;
+  }
+
+  T* PushArr(size_t count) {
+    TIXMLASSERT(_size <= SIZE_MAX - count);
+    EnsureCapacity(_size + count);
+    T* ret = &_mem[_size];
+    _size += count;
+    return ret;
+  }
+
+  T Pop() {
+    TIXMLASSERT(_size > 0);
+    --_size;
+    return _mem[_size];
+  }
+
+  void PopArr(size_t count) {
+    TIXMLASSERT(_size >= count);
+    _size -= count;
+  }
+
+  bool Empty() const { return _size == 0; }
+
+  T& operator[](size_t i) {
+    TIXMLASSERT(i < _size);
+    return _mem[i];
+  }
+
+  const T& operator[](size_t i) const {
+    TIXMLASSERT(i < _size);
+    return _mem[i];
+  }
+
+  const T& PeekTop() const {
+    TIXMLASSERT(_size > 0);
+    return _mem[_size - 1];
+  }
+
+  size_t Size() const {
+    TIXMLASSERT(_size >= 0);
+    return _size;
+  }
+
+  size_t Capacity() const {
+    TIXMLASSERT(_allocated >= INITIAL_SIZE);
+    return _allocated;
+  }
+
+  void SwapRemove(size_t i) {
+    TIXMLASSERT(i < _size);
+    TIXMLASSERT(_size > 0);
+    _mem[i] = _mem[_size - 1];
+    --_size;
+  }
+
+  const T* Mem() const {
+    TIXMLASSERT(_mem);
+    return _mem;
+  }
+
+  T* Mem() {
+    TIXMLASSERT(_mem);
+    return _mem;
+  }
+
+ private:
+  DynArray(const DynArray&);        // not supported
+  void operator=(const DynArray&);  // not supported
+
+  void EnsureCapacity(size_t cap) {
+    TIXMLASSERT(cap > 0);
+    if (cap > _allocated) {
+      TIXMLASSERT(cap <= SIZE_MAX / 2 / sizeof(T));
+      const size_t newAllocated = cap * 2;
+      T* newMem = new T[newAllocated];
+      TIXMLASSERT(newAllocated >= _size);
+      memcpy(
+          newMem, _mem,
+          sizeof(T) *
+              _size);  // warning: not using constructors, only works for PODs
+      if (_mem != _pool) {
+        delete[] _mem;
+      }
+      _mem = newMem;
+      _allocated = newAllocated;
     }
-
-    void Clear() {
-        _size = 0;
+  }
+
+  T* _mem;
+  T _pool[INITIAL_SIZE];
+  size_t _allocated;  // objects allocated
+  size_t _size;       // number objects in use
+};
+
+/*
+        Parent virtual class of a pool for fast allocation
+        and deallocation of objects.
+*/
+class MemPool {
+ public:
+  MemPool() {}
+  virtual ~MemPool() {}
+
+  virtual size_t ItemSize() const = 0;
+  virtual void* Alloc() = 0;
+  virtual void Free(void*) = 0;
+  virtual void SetTracked() = 0;
+};
+
+/*
+        Template child class to create pools of the correct type.
+*/
+template <size_t ITEM_SIZE>
+class MemPoolT : public MemPool {
+ public:
+  MemPoolT()
+      : _blockPtrs(),
+        _root(0),
+        _currentAllocs(0),
+        _nAllocs(0),
+        _maxAllocs(0),
+        _nUntracked(0) {}
+  ~MemPoolT() { MemPoolT<ITEM_SIZE>::Clear(); }
+
+  void Clear() {
+    // Delete the blocks.
+    while (!_blockPtrs.Empty()) {
+      Block* lastBlock = _blockPtrs.Pop();
+      delete lastBlock;
     }
-
-    void Push( T t ) {
-        TIXMLASSERT( _size < INT_MAX );
-        EnsureCapacity( _size+1 );
-        _mem[_size] = t;
-        ++_size;
+    _root = 0;
+    _currentAllocs = 0;
+    _nAllocs = 0;
+    _maxAllocs = 0;
+    _nUntracked = 0;
+  }
+
+  virtual size_t ItemSize() const override { return ITEM_SIZE; }
+  size_t CurrentAllocs() const { return _currentAllocs; }
+
+  virtual void* Alloc() override {
+    if (!_root) {
+      // Need a new block.
+      Block* block = new Block;
+      _blockPtrs.Push(block);
+
+      Item* blockItems = block->items;
+      for (size_t i = 0; i < ITEMS_PER_BLOCK - 1; ++i) {
+        blockItems[i].next = &(blockItems[i + 1]);
+      }
+      blockItems[ITEMS_PER_BLOCK - 1].next = 0;
+      _root = blockItems;
     }
-
-    T* PushArr( size_t count ) {
-        TIXMLASSERT( _size <= SIZE_MAX - count );
-        EnsureCapacity( _size+count );
-        T* ret = &_mem[_size];
-        _size += count;
-        return ret;
+    Item* const result = _root;
+    TIXMLASSERT(result != 0);
+    _root = _root->next;
+
+    ++_currentAllocs;
+    if (_currentAllocs > _maxAllocs) {
+      _maxAllocs = _currentAllocs;
     }
-
-    T Pop() {
-        TIXMLASSERT( _size > 0 );
-        --_size;
-        return _mem[_size];
+    ++_nAllocs;
+    ++_nUntracked;
+    return result;
+  }
+
+  virtual void Free(void* mem) override {
+    if (!mem) {
+      return;
     }
-
-    void PopArr( size_t count ) {
-        TIXMLASSERT( _size >= count );
-        _size -= count;
-    }
-
-    bool Empty() const					{
-        return _size == 0;
-    }
-
-    T& operator[](size_t i) {
-        TIXMLASSERT( i < _size );
-        return _mem[i];
-    }
-
-    const T& operator[](size_t i) const {
-        TIXMLASSERT( i < _size );
-        return _mem[i];
-    }
-
-    const T& PeekTop() const            {
-        TIXMLASSERT( _size > 0 );
-        return _mem[ _size - 1];
-    }
-
-    size_t Size() const {
-        TIXMLASSERT( _size >= 0 );
-        return _size;
-    }
-
-    size_t Capacity() const {
-        TIXMLASSERT( _allocated >= INITIAL_SIZE );
-        return _allocated;
-    }
-
-	void SwapRemove(size_t i) {
-		TIXMLASSERT(i < _size);
-		TIXMLASSERT(_size > 0);
-		_mem[i] = _mem[_size - 1];
-		--_size;
-	}
-
-    const T* Mem() const				{
-        TIXMLASSERT( _mem );
-        return _mem;
-    }
-
-    T* Mem() {
-        TIXMLASSERT( _mem );
-        return _mem;
-    }
-
-private:
-    DynArray( const DynArray& ); // not supported
-    void operator=( const DynArray& ); // not supported
-
-    void EnsureCapacity( size_t cap ) {
-        TIXMLASSERT( cap > 0 );
-        if ( cap > _allocated ) {
-            TIXMLASSERT( cap <= SIZE_MAX / 2 / sizeof(T));
-            const size_t newAllocated = cap * 2;
-            T* newMem = new T[newAllocated];
-            TIXMLASSERT( newAllocated >= _size );
-            memcpy( newMem, _mem, sizeof(T) * _size );	// warning: not using constructors, only works for PODs
-            if ( _mem != _pool ) {
-                delete [] _mem;
-            }
-            _mem = newMem;
-            _allocated = newAllocated;
-        }
-    }
-
-    T*  _mem;
-    T   _pool[INITIAL_SIZE];
-    size_t _allocated;		// objects allocated
-    size_t _size;			// number objects in use
+    --_currentAllocs;
+    Item* item = static_cast<Item*>(mem);
+#ifdef TINYXML2_DEBUG
+    memset(item, 0xfe, sizeof(*item));
+#endif
+    item->next = _root;
+    _root = item;
+  }
+  void Trace(const char* name) {
+    printf(
+        "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d "
+        "blocks=%d\n",
+        name, _maxAllocs, _maxAllocs * ITEM_SIZE / 1024, _currentAllocs,
+        ITEM_SIZE, _nAllocs, _blockPtrs.Size());
+  }
+
+  void SetTracked() override { --_nUntracked; }
+
+  size_t Untracked() const { return _nUntracked; }
+
+  // This number is perf sensitive. 4k seems like a good tradeoff on my machine.
+  // The test file is large, 170k.
+  // Release:		VS2010 gcc(no opt)
+  //		1k:		4000
+  //		2k:		4000
+  //		4k:		3900	21000
+  //		16k:	5200
+  //		32k:	4300
+  //		64k:	4000	21000
+  // Declared public because some compilers do not accept to use ITEMS_PER_BLOCK
+  // in private part if ITEMS_PER_BLOCK is private
+  enum { ITEMS_PER_BLOCK = (4 * 1024) / ITEM_SIZE };
+
+ private:
+  MemPoolT(const MemPoolT&);        // not supported
+  void operator=(const MemPoolT&);  // not supported
+
+  union Item {
+    Item* next;
+    char itemData[static_cast<size_t>(ITEM_SIZE)];
+  };
+  struct Block {
+    Item items[ITEMS_PER_BLOCK];
+  };
+  DynArray<Block*, 10> _blockPtrs;
+  Item* _root;
+
+  size_t _currentAllocs;
+  size_t _nAllocs;
+  size_t _maxAllocs;
+  size_t _nUntracked;
 };
 
-
-/*
-	Parent virtual class of a pool for fast allocation
-	and deallocation of objects.
+/**
+        Implements the interface to the "Visitor pattern" (see the Accept()
+   method.) If you call the Accept() method, it requires being passed a
+   XMLVisitor class to handle callbacks. For nodes that contain other nodes
+   (Document, Element) you will get called with a VisitEnter/VisitExit pair.
+   Nodes that are always leafs are simply called with Visit().
+
+        If you return 'true' from a Visit method, recursive parsing will
+   continue. If you return false, <b>no children of this node or its
+   siblings</b> will be visited.
+
+        All flavors of Visit methods have a default implementation that returns
+   'true' (continue visiting). You need to only override methods that are
+   interesting to you.
+
+        Generally Accept() is called on the XMLDocument, although all nodes
+   support visiting.
+
+        You should never change the document from a callback.
+
+        @sa XMLNode::Accept()
 */
-class MemPool
-{
-public:
-    MemPool() {}
-    virtual ~MemPool() {}
-
-    virtual size_t ItemSize() const = 0;
-    virtual void* Alloc() = 0;
-    virtual void Free( void* ) = 0;
-    virtual void SetTracked() = 0;
-};
-
-
-/*
-	Template child class to create pools of the correct type.
-*/
-template< size_t ITEM_SIZE >
-class MemPoolT : public MemPool
-{
-public:
-    MemPoolT() : _blockPtrs(), _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)	{}
-    ~MemPoolT() {
-        MemPoolT< ITEM_SIZE >::Clear();
-    }
-
-    void Clear() {
-        // Delete the blocks.
-        while( !_blockPtrs.Empty()) {
-            Block* lastBlock = _blockPtrs.Pop();
-            delete lastBlock;
-        }
-        _root = 0;
-        _currentAllocs = 0;
-        _nAllocs = 0;
-        _maxAllocs = 0;
-        _nUntracked = 0;
-    }
-
-    virtual size_t ItemSize() const override {
-        return ITEM_SIZE;
-    }
-    size_t CurrentAllocs() const {
-        return _currentAllocs;
-    }
-
-    virtual void* Alloc() override{
-        if ( !_root ) {
-            // Need a new block.
-            Block* block = new Block;
-            _blockPtrs.Push( block );
-
-            Item* blockItems = block->items;
-            for( size_t i = 0; i < ITEMS_PER_BLOCK - 1; ++i ) {
-                blockItems[i].next = &(blockItems[i + 1]);
-            }
-            blockItems[ITEMS_PER_BLOCK - 1].next = 0;
-            _root = blockItems;
-        }
-        Item* const result = _root;
-        TIXMLASSERT( result != 0 );
-        _root = _root->next;
-
-        ++_currentAllocs;
-        if ( _currentAllocs > _maxAllocs ) {
-            _maxAllocs = _currentAllocs;
-        }
-        ++_nAllocs;
-        ++_nUntracked;
-        return result;
-    }
-
-    virtual void Free( void* mem ) override {
-        if ( !mem ) {
-            return;
-        }
-        --_currentAllocs;
-        Item* item = static_cast<Item*>( mem );
-#ifdef TINYXML2_DEBUG
-        memset( item, 0xfe, sizeof( *item ) );
-#endif
-        item->next = _root;
-        _root = item;
-    }
-    void Trace( const char* name ) {
-        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
-                name, _maxAllocs, _maxAllocs * ITEM_SIZE / 1024, _currentAllocs,
-                ITEM_SIZE, _nAllocs, _blockPtrs.Size() );
-    }
-
-    void SetTracked() override {
-        --_nUntracked;
-    }
-
-    size_t Untracked() const {
-        return _nUntracked;
-    }
-
-	// This number is perf sensitive. 4k seems like a good tradeoff on my machine.
-	// The test file is large, 170k.
-	// Release:		VS2010 gcc(no opt)
-	//		1k:		4000
-	//		2k:		4000
-	//		4k:		3900	21000
-	//		16k:	5200
-	//		32k:	4300
-	//		64k:	4000	21000
-    // Declared public because some compilers do not accept to use ITEMS_PER_BLOCK
-    // in private part if ITEMS_PER_BLOCK is private
-    enum { ITEMS_PER_BLOCK = (4 * 1024) / ITEM_SIZE };
-
-private:
-    MemPoolT( const MemPoolT& ); // not supported
-    void operator=( const MemPoolT& ); // not supported
-
-    union Item {
-        Item*   next;
-        char    itemData[static_cast<size_t>(ITEM_SIZE)];
-    };
-    struct Block {
-        Item items[ITEMS_PER_BLOCK];
-    };
-    DynArray< Block*, 10 > _blockPtrs;
-    Item* _root;
-
-    size_t _currentAllocs;
-    size_t _nAllocs;
-    size_t _maxAllocs;
-    size_t _nUntracked;
-};
-
-
-
-/**
-	Implements the interface to the "Visitor pattern" (see the Accept() method.)
-	If you call the Accept() method, it requires being passed a XMLVisitor
-	class to handle callbacks. For nodes that contain other nodes (Document, Element)
-	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
-	are simply called with Visit().
-
-	If you return 'true' from a Visit method, recursive parsing will continue. If you return
-	false, <b>no children of this node or its siblings</b> will be visited.
-
-	All flavors of Visit methods have a default implementation that returns 'true' (continue
-	visiting). You need to only override methods that are interesting to you.
-
-	Generally Accept() is called on the XMLDocument, although all nodes support visiting.
-
-	You should never change the document from a callback.
-
-	@sa XMLNode::Accept()
-*/
-class TINYXML2_LIB XMLVisitor
-{
-public:
-    virtual ~XMLVisitor() {}
-
-    /// Visit a document.
-    virtual bool VisitEnter( const XMLDocument& /*doc*/ )			{
-        return true;
-    }
-    /// Visit a document.
-    virtual bool VisitExit( const XMLDocument& /*doc*/ )			{
-        return true;
-    }
-
-    /// Visit an element.
-    virtual bool VisitEnter( const XMLElement& /*element*/, const XMLAttribute* /*firstAttribute*/ )	{
-        return true;
-    }
-    /// Visit an element.
-    virtual bool VisitExit( const XMLElement& /*element*/ )			{
-        return true;
-    }
-
-    /// Visit a declaration.
-    virtual bool Visit( const XMLDeclaration& /*declaration*/ )		{
-        return true;
-    }
-    /// Visit a text node.
-    virtual bool Visit( const XMLText& /*text*/ )					{
-        return true;
-    }
-    /// Visit a comment node.
-    virtual bool Visit( const XMLComment& /*comment*/ )				{
-        return true;
-    }
-    /// Visit an unknown node.
-    virtual bool Visit( const XMLUnknown& /*unknown*/ )				{
-        return true;
-    }
+class TINYXML2_LIB XMLVisitor {
+ public:
+  virtual ~XMLVisitor() {}
+
+  /// Visit a document.
+  virtual bool VisitEnter(const XMLDocument& /*doc*/) { return true; }
+  /// Visit a document.
+  virtual bool VisitExit(const XMLDocument& /*doc*/) { return true; }
+
+  /// Visit an element.
+  virtual bool VisitEnter(const XMLElement& /*element*/,
+                          const XMLAttribute* /*firstAttribute*/) {
+    return true;
+  }
+  /// Visit an element.
+  virtual bool VisitExit(const XMLElement& /*element*/) { return true; }
+
+  /// Visit a declaration.
+  virtual bool Visit(const XMLDeclaration& /*declaration*/) { return true; }
+  /// Visit a text node.
+  virtual bool Visit(const XMLText& /*text*/) { return true; }
+  /// Visit a comment node.
+  virtual bool Visit(const XMLComment& /*comment*/) { return true; }
+  /// Visit an unknown node.
+  virtual bool Visit(const XMLUnknown& /*unknown*/) { return true; }
 };
 
 // WARNING: must match XMLDocument::_errorNames[]
 enum XMLError {
-    XML_SUCCESS = 0,
-    XML_NO_ATTRIBUTE,
-    XML_WRONG_ATTRIBUTE_TYPE,
-    XML_ERROR_FILE_NOT_FOUND,
-    XML_ERROR_FILE_COULD_NOT_BE_OPENED,
-    XML_ERROR_FILE_READ_ERROR,
-    XML_ERROR_PARSING_ELEMENT,
-    XML_ERROR_PARSING_ATTRIBUTE,
-    XML_ERROR_PARSING_TEXT,
-    XML_ERROR_PARSING_CDATA,
-    XML_ERROR_PARSING_COMMENT,
-    XML_ERROR_PARSING_DECLARATION,
-    XML_ERROR_PARSING_UNKNOWN,
-    XML_ERROR_EMPTY_DOCUMENT,
-    XML_ERROR_MISMATCHED_ELEMENT,
-    XML_ERROR_PARSING,
-    XML_CAN_NOT_CONVERT_TEXT,
-    XML_NO_TEXT_NODE,
-	XML_ELEMENT_DEPTH_EXCEEDED,
-
-	XML_ERROR_COUNT
+  XML_SUCCESS = 0,
+  XML_NO_ATTRIBUTE,
+  XML_WRONG_ATTRIBUTE_TYPE,
+  XML_ERROR_FILE_NOT_FOUND,
+  XML_ERROR_FILE_COULD_NOT_BE_OPENED,
+  XML_ERROR_FILE_READ_ERROR,
+  XML_ERROR_PARSING_ELEMENT,
+  XML_ERROR_PARSING_ATTRIBUTE,
+  XML_ERROR_PARSING_TEXT,
+  XML_ERROR_PARSING_CDATA,
+  XML_ERROR_PARSING_COMMENT,
+  XML_ERROR_PARSING_DECLARATION,
+  XML_ERROR_PARSING_UNKNOWN,
+  XML_ERROR_EMPTY_DOCUMENT,
+  XML_ERROR_MISMATCHED_ELEMENT,
+  XML_ERROR_PARSING,
+  XML_CAN_NOT_CONVERT_TEXT,
+  XML_NO_TEXT_NODE,
+  XML_ELEMENT_DEPTH_EXCEEDED,
+
+  XML_ERROR_COUNT
 };
 
-
 /*
-	Utility functionality.
+        Utility functionality.
 */
-class TINYXML2_LIB XMLUtil
-{
-public:
-    static const char* SkipWhiteSpace( const char* p, int* curLineNumPtr )	{
-        TIXMLASSERT( p );
-
-        while( IsWhiteSpace(*p) ) {
-            if (curLineNumPtr && *p == '\n') {
-                ++(*curLineNumPtr);
-            }
-            ++p;
-        }
-        TIXMLASSERT( p );
-        return p;
+class TINYXML2_LIB XMLUtil {
+ public:
+  static const char* SkipWhiteSpace(const char* p, int* curLineNumPtr) {
+    TIXMLASSERT(p);
+
+    while (IsWhiteSpace(*p)) {
+      if (curLineNumPtr && *p == '\n') {
+        ++(*curLineNumPtr);
+      }
+      ++p;
     }
-    static char* SkipWhiteSpace( char* const p, int* curLineNumPtr ) {
-        return const_cast<char*>( SkipWhiteSpace( const_cast<const char*>(p), curLineNumPtr ) );
+    TIXMLASSERT(p);
+    return p;
+  }
+  static char* SkipWhiteSpace(char* const p, int* curLineNumPtr) {
+    return const_cast<char*>(
+        SkipWhiteSpace(const_cast<const char*>(p), curLineNumPtr));
+  }
+
+  // Anything in the high order range of UTF-8 is assumed to not be whitespace.
+  // This isn't correct, but simple, and usually works.
+  static bool IsWhiteSpace(char p) {
+    return !IsUTF8Continuation(p) && isspace(static_cast<unsigned char>(p));
+  }
+
+  inline static bool IsNameStartChar(unsigned char ch) {
+    if (ch >= 128) {
+      // This is a heuristic guess in attempt to not implement Unicode-aware
+      // isalpha()
+      return true;
     }
-
-    // Anything in the high order range of UTF-8 is assumed to not be whitespace. This isn't
-    // correct, but simple, and usually works.
-    static bool IsWhiteSpace( char p )					{
-        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );
+    if (isalpha(ch)) {
+      return true;
     }
-
-    inline static bool IsNameStartChar( unsigned char ch ) {
-        if ( ch >= 128 ) {
-            // This is a heuristic guess in attempt to not implement Unicode-aware isalpha()
-            return true;
-        }
-        if ( isalpha( ch ) ) {
-            return true;
-        }
-        return ch == ':' || ch == '_';
+    return ch == ':' || ch == '_';
+  }
+
+  inline static bool IsNameChar(unsigned char ch) {
+    return IsNameStartChar(ch) || isdigit(ch) || ch == '.' || ch == '-';
+  }
+
+  inline static bool IsPrefixHex(const char* p) {
+    p = SkipWhiteSpace(p, 0);
+    return p && *p == '0' && (*(p + 1) == 'x' || *(p + 1) == 'X');
+  }
+
+  inline static bool StringEqual(const char* p, const char* q,
+                                 int nChar = INT_MAX) {
+    if (p == q) {
+      return true;
     }
-
-    inline static bool IsNameChar( unsigned char ch ) {
-        return IsNameStartChar( ch )
-               || isdigit( ch )
-               || ch == '.'
-               || ch == '-';
+    TIXMLASSERT(p);
+    TIXMLASSERT(q);
+    TIXMLASSERT(nChar >= 0);
+    return strncmp(p, q, static_cast<size_t>(nChar)) == 0;
+  }
+
+  inline static bool IsUTF8Continuation(const char p) {
+    return (p & 0x80) != 0;
+  }
+
+  static const char* ReadBOM(const char* p, bool* hasBOM);
+  // p is the starting location,
+  // the UTF-8 value of the entity will be placed in value, and length filled
+  // in.
+  static const char* GetCharacterRef(const char* p, char* value, int* length);
+  static void ConvertUTF32ToUTF8(unsigned long input, char* output,
+                                 int* length);
+
+  // converts primitive types to strings
+  static void ToStr(int v, char* buffer, int bufferSize);
+  static void ToStr(unsigned v, char* buffer, int bufferSize);
+  static void ToStr(bool v, char* buffer, int bufferSize);
+  static void ToStr(float v, char* buffer, int bufferSize);
+  static void ToStr(double v, char* buffer, int bufferSize);
+  static void ToStr(int64_t v, char* buffer, int bufferSize);
+  static void ToStr(uint64_t v, char* buffer, int bufferSize);
+
+  // converts strings to primitive types
+  static bool ToInt(const char* str, int* value);
+  static bool ToUnsigned(const char* str, unsigned* value);
+  static bool ToBool(const char* str, bool* value);
+  static bool ToFloat(const char* str, float* value);
+  static bool ToDouble(const char* str, double* value);
+  static bool ToInt64(const char* str, int64_t* value);
+  static bool ToUnsigned64(const char* str, uint64_t* value);
+  // Changes what is serialized for a boolean value.
+  // Default to "true" and "false". Shouldn't be changed
+  // unless you have a special testing or compatibility need.
+  // Be careful: static, global, & not thread safe.
+  // Be sure to set static const memory as parameters.
+  static void SetBoolSerialization(const char* writeTrue,
+                                   const char* writeFalse);
+
+ private:
+  static const char* writeBoolTrue;
+  static const char* writeBoolFalse;
+};
+
+/** XMLNode is a base class for every object that is in the
+        XML Document Object Model (DOM), except XMLAttributes.
+        Nodes have siblings, a parent, and children which can
+        be navigated. A node is always in a XMLDocument.
+        The type of a XMLNode can be queried, and it can
+        be cast to its more defined type.
+
+        A XMLDocument allocates memory for all its Nodes.
+        When the XMLDocument gets deleted, all its Nodes
+        will also be deleted.
+
+        @verbatim
+        A Document can contain:	Element	(container or leaf)
+                                                        Comment (leaf)
+                                                        Unknown (leaf)
+                                                        Declaration( leaf )
+
+        An Element can contain:	Element (container or leaf)
+                                                        Text	(leaf)
+                                                        Attributes (not on tree)
+                                                        Comment (leaf)
+                                                        Unknown (leaf)
+
+        @endverbatim
+*/
+class TINYXML2_LIB XMLNode {
+  friend class XMLDocument;
+  friend class XMLElement;
+
+ public:
+  /// Get the XMLDocument that owns this XMLNode.
+  const XMLDocument* GetDocument() const {
+    TIXMLASSERT(_document);
+    return _document;
+  }
+  /// Get the XMLDocument that owns this XMLNode.
+  XMLDocument* GetDocument() {
+    TIXMLASSERT(_document);
+    return _document;
+  }
+
+  /// Safely cast to an Element, or null.
+  virtual XMLElement* ToElement() { return 0; }
+  /// Safely cast to Text, or null.
+  virtual XMLText* ToText() { return 0; }
+  /// Safely cast to a Comment, or null.
+  virtual XMLComment* ToComment() { return 0; }
+  /// Safely cast to a Document, or null.
+  virtual XMLDocument* ToDocument() { return 0; }
+  /// Safely cast to a Declaration, or null.
+  virtual XMLDeclaration* ToDeclaration() { return 0; }
+  /// Safely cast to an Unknown, or null.
+  virtual XMLUnknown* ToUnknown() { return 0; }
+
+  virtual const XMLElement* ToElement() const { return 0; }
+  virtual const XMLText* ToText() const { return 0; }
+  virtual const XMLComment* ToComment() const { return 0; }
+  virtual const XMLDocument* ToDocument() const { return 0; }
+  virtual const XMLDeclaration* ToDeclaration() const { return 0; }
+  virtual const XMLUnknown* ToUnknown() const { return 0; }
+
+  // ChildElementCount was originally suggested by msteiger on the sourceforge
+  // page for TinyXML and modified by KB1SPH for TinyXML-2.
+
+  int ChildElementCount(const char* value) const;
+
+  int ChildElementCount() const;
+
+  /** The meaning of 'value' changes for the specific type.
+      @verbatim
+      Document:	empty (NULL is returned, not an empty string)
+      Element:	name of the element
+      Comment:	the comment text
+      Unknown:	the tag contents
+      Text:		the text string
+      @endverbatim
+  */
+  const char* Value() const;
+
+  /** Set the Value of an XML node.
+      @sa Value()
+  */
+  void SetValue(const char* val, bool staticMem = false);
+
+  /// Gets the line number the node is in, if the document was parsed from a
+  /// file.
+  int GetLineNum() const { return _parseLineNum; }
+
+  /// Get the parent of this node on the DOM.
+  const XMLNode* Parent() const { return _parent; }
+
+  XMLNode* Parent() { return _parent; }
+
+  /// Returns true if this node has no children.
+  bool NoChildren() const { return !_firstChild; }
+
+  /// Get the first child node, or null if none exists.
+  const XMLNode* FirstChild() const { return _firstChild; }
+
+  XMLNode* FirstChild() { return _firstChild; }
+
+  /** Get the first child element, or optionally the first child
+      element with the specified name.
+  */
+  const XMLElement* FirstChildElement(const char* name = 0) const;
+
+  XMLElement* FirstChildElement(const char* name = 0) {
+    return const_cast<XMLElement*>(
+        const_cast<const XMLNode*>(this)->FirstChildElement(name));
+  }
+
+  /// Get the last child node, or null if none exists.
+  const XMLNode* LastChild() const { return _lastChild; }
+
+  XMLNode* LastChild() { return _lastChild; }
+
+  /** Get the last child element or optionally the last child
+      element with the specified name.
+  */
+  const XMLElement* LastChildElement(const char* name = 0) const;
+
+  XMLElement* LastChildElement(const char* name = 0) {
+    return const_cast<XMLElement*>(
+        const_cast<const XMLNode*>(this)->LastChildElement(name));
+  }
+
+  /// Get the previous (left) sibling node of this node.
+  const XMLNode* PreviousSibling() const { return _prev; }
+
+  XMLNode* PreviousSibling() { return _prev; }
+
+  /// Get the previous (left) sibling element of this node, with an optionally
+  /// supplied name.
+  const XMLElement* PreviousSiblingElement(const char* name = 0) const;
+
+  XMLElement* PreviousSiblingElement(const char* name = 0) {
+    return const_cast<XMLElement*>(
+        const_cast<const XMLNode*>(this)->PreviousSiblingElement(name));
+  }
+
+  /// Get the next (right) sibling node of this node.
+  const XMLNode* NextSibling() const { return _next; }
+
+  XMLNode* NextSibling() { return _next; }
+
+  /// Get the next (right) sibling element of this node, with an optionally
+  /// supplied name.
+  const XMLElement* NextSiblingElement(const char* name = 0) const;
+
+  XMLElement* NextSiblingElement(const char* name = 0) {
+    return const_cast<XMLElement*>(
+        const_cast<const XMLNode*>(this)->NextSiblingElement(name));
+  }
+
+  /**
+      Add a child node as the last (right) child.
+              If the child node is already part of the document,
+              it is moved from its old location to the new location.
+              Returns the addThis argument or 0 if the node does not
+              belong to the same document.
+  */
+  XMLNode* InsertEndChild(XMLNode* addThis);
+
+  XMLNode* LinkEndChild(XMLNode* addThis) { return InsertEndChild(addThis); }
+  /**
+      Add a child node as the first (left) child.
+              If the child node is already part of the document,
+              it is moved from its old location to the new location.
+              Returns the addThis argument or 0 if the node does not
+              belong to the same document.
+  */
+  XMLNode* InsertFirstChild(XMLNode* addThis);
+  /**
+      Add a node after the specified child node.
+              If the child node is already part of the document,
+              it is moved from its old location to the new location.
+              Returns the addThis argument or 0 if the afterThis node
+              is not a child of this node, or if the node does not
+              belong to the same document.
+  */
+  XMLNode* InsertAfterChild(XMLNode* afterThis, XMLNode* addThis);
+
+  /**
+      Delete all the children of this node.
+  */
+  void DeleteChildren();
+
+  /**
+      Delete a child of this node.
+  */
+  void DeleteChild(XMLNode* node);
+
+  /**
+      Make a copy of this node, but not its children.
+      You may pass in a Document pointer that will be
+      the owner of the new Node. If the 'document' is
+      null, then the node returned will be allocated
+      from the current Document. (this->GetDocument())
+
+      Note: if called on a XMLDocument, this will return null.
+  */
+  virtual XMLNode* ShallowClone(XMLDocument* document) const = 0;
+
+  /**
+          Make a copy of this node and all its children.
+
+          If the 'target' is null, then the nodes will
+          be allocated in the current document. If 'target'
+  is specified, the memory will be allocated in the
+  specified XMLDocument.
+
+          NOTE: This is probably not the correct tool to
+          copy a document, since XMLDocuments can have multiple
+          top level XMLNodes. You probably want to use
+  XMLDocument::DeepCopy()
+  */
+  XMLNode* DeepClone(XMLDocument* target) const;
+
+  /**
+      Test if 2 nodes are the same, but don't test children.
+      The 2 nodes do not need to be in the same Document.
+
+      Note: if called on a XMLDocument, this will return false.
+  */
+  virtual bool ShallowEqual(const XMLNode* compare) const = 0;
+
+  /** Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node
+     in the XML tree will be conditionally visited and the host will be called
+     back via the XMLVisitor interface.
+
+      This is essentially a SAX interface for TinyXML-2. (Note however it
+     doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2
+     is unchanged by using this interface versus any other.)
+
+      The interface has been based on ideas from:
+
+      - http://www.saxproject.org/
+      - http://c2.com/cgi/wiki?HierarchicalVisitorPattern
+
+      Which are both good references for "visiting".
+
+      An example of using Accept():
+      @verbatim
+      XMLPrinter printer;
+      tinyxmlDoc.Accept( &printer );
+      const char* xmlcstr = printer.CStr();
+      @endverbatim
+  */
+  virtual bool Accept(XMLVisitor* visitor) const = 0;
+
+  /**
+          Set user data into the XMLNode. TinyXML-2 in
+          no way processes or interprets user data.
+          It is initially 0.
+  */
+  void SetUserData(void* userData) { _userData = userData; }
+
+  /**
+          Get user data set into the XMLNode. TinyXML-2 in
+          no way processes or interprets user data.
+          It is initially 0.
+  */
+  void* GetUserData() const { return _userData; }
+
+ protected:
+  explicit XMLNode(XMLDocument*);
+  virtual ~XMLNode();
+
+  virtual char* ParseDeep(char* p, StrPair* parentEndTag, int* curLineNumPtr);
+
+  XMLDocument* _document;
+  XMLNode* _parent;
+  mutable StrPair _value;
+  int _parseLineNum;
+
+  XMLNode* _firstChild;
+  XMLNode* _lastChild;
+
+  XMLNode* _prev;
+  XMLNode* _next;
+
+  void* _userData;
+
+ private:
+  MemPool* _memPool;
+  void Unlink(XMLNode* child);
+  static void DeleteNode(XMLNode* node);
+  void InsertChildPreamble(XMLNode* insertThis) const;
+  const XMLElement* ToElementWithName(const char* name) const;
+
+  XMLNode(const XMLNode&);             // not supported
+  XMLNode& operator=(const XMLNode&);  // not supported
+};
+
+/** XML text.
+
+        Note that a text node can have child element nodes, for example:
+        @verbatim
+        <root>This is <b>bold</b></root>
+        @endverbatim
+
+        A text node can have 2 ways to output the next. "normal" output
+        and CDATA. It will default to the mode it was parsed from the XML file
+   and you generally want to leave it alone, but you can change the output mode
+   with SetCData() and query it with CData().
+*/
+class TINYXML2_LIB XMLText : public XMLNode {
+  friend class XMLDocument;
+
+ public:
+  virtual bool Accept(XMLVisitor* visitor) const override;
+
+  virtual XMLText* ToText() override { return this; }
+  virtual const XMLText* ToText() const override { return this; }
+
+  /// Declare whether this should be CDATA or standard text.
+  void SetCData(bool isCData) { _isCData = isCData; }
+  /// Returns true if this is a CDATA text element.
+  bool CData() const { return _isCData; }
+
+  virtual XMLNode* ShallowClone(XMLDocument* document) const override;
+  virtual bool ShallowEqual(const XMLNode* compare) const override;
+
+ protected:
+  explicit XMLText(XMLDocument* doc) : XMLNode(doc), _isCData(false) {}
+  virtual ~XMLText() {}
+
+  char* ParseDeep(char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
+
+ private:
+  bool _isCData;
+
+  XMLText(const XMLText&);             // not supported
+  XMLText& operator=(const XMLText&);  // not supported
+};
+
+/** An XML Comment. */
+class TINYXML2_LIB XMLComment : public XMLNode {
+  friend class XMLDocument;
+
+ public:
+  virtual XMLComment* ToComment() override { return this; }
+  virtual const XMLComment* ToComment() const override { return this; }
+
+  virtual bool Accept(XMLVisitor* visitor) const override;
+
+  virtual XMLNode* ShallowClone(XMLDocument* document) const override;
+  virtual bool ShallowEqual(const XMLNode* compare) const override;
+
+ protected:
+  explicit XMLComment(XMLDocument* doc);
+  virtual ~XMLComment();
+
+  char* ParseDeep(char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
+
+ private:
+  XMLComment(const XMLComment&);             // not supported
+  XMLComment& operator=(const XMLComment&);  // not supported
+};
+
+/** In correct XML the declaration is the first entry in the file.
+        @verbatim
+                <?xml version="1.0" standalone="yes"?>
+        @endverbatim
+
+        TinyXML-2 will happily read or write files without a declaration,
+        however.
+
+        The text of the declaration isn't interpreted. It is parsed
+        and written as a string.
+*/
+class TINYXML2_LIB XMLDeclaration : public XMLNode {
+  friend class XMLDocument;
+
+ public:
+  virtual XMLDeclaration* ToDeclaration() override { return this; }
+  virtual const XMLDeclaration* ToDeclaration() const override { return this; }
+
+  virtual bool Accept(XMLVisitor* visitor) const override;
+
+  virtual XMLNode* ShallowClone(XMLDocument* document) const override;
+  virtual bool ShallowEqual(const XMLNode* compare) const override;
+
+ protected:
+  explicit XMLDeclaration(XMLDocument* doc);
+  virtual ~XMLDeclaration();
+
+  char* ParseDeep(char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
+
+ private:
+  XMLDeclaration(const XMLDeclaration&);             // not supported
+  XMLDeclaration& operator=(const XMLDeclaration&);  // not supported
+};
+
+/** Any tag that TinyXML-2 doesn't recognize is saved as an
+        unknown. It is a tag of text, but should not be modified.
+        It will be written back to the XML, unchanged, when the file
+        is saved.
+
+        DTD tags get thrown into XMLUnknowns.
+*/
+class TINYXML2_LIB XMLUnknown : public XMLNode {
+  friend class XMLDocument;
+
+ public:
+  virtual XMLUnknown* ToUnknown() override { return this; }
+  virtual const XMLUnknown* ToUnknown() const override { return this; }
+
+  virtual bool Accept(XMLVisitor* visitor) const override;
+
+  virtual XMLNode* ShallowClone(XMLDocument* document) const override;
+  virtual bool ShallowEqual(const XMLNode* compare) const override;
+
+ protected:
+  explicit XMLUnknown(XMLDocument* doc);
+  virtual ~XMLUnknown();
+
+  char* ParseDeep(char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
+
+ private:
+  XMLUnknown(const XMLUnknown&);             // not supported
+  XMLUnknown& operator=(const XMLUnknown&);  // not supported
+};
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+        number of attributes, each with a unique name.
+
+        @note The attributes are not XMLNodes. You may only query the
+        Next() attribute in a list.
+*/
+class TINYXML2_LIB XMLAttribute {
+  friend class XMLElement;
+
+ public:
+  /// The name of the attribute.
+  const char* Name() const;
+
+  /// The value of the attribute.
+  const char* Value() const;
+
+  /// Gets the line number the attribute is in, if the document was parsed from
+  /// a file.
+  int GetLineNum() const { return _parseLineNum; }
+
+  /// The next attribute in the list.
+  const XMLAttribute* Next() const { return _next; }
+
+  /** IntValue interprets the attribute as an integer, and returns the value.
+      If the value isn't an integer, 0 will be returned. There is no error
+     checking; use QueryIntValue() if you need error checking.
+  */
+  int IntValue() const {
+    int i = 0;
+    QueryIntValue(&i);
+    return i;
+  }
+
+  int64_t Int64Value() const {
+    int64_t i = 0;
+    QueryInt64Value(&i);
+    return i;
+  }
+
+  uint64_t Unsigned64Value() const {
+    uint64_t i = 0;
+    QueryUnsigned64Value(&i);
+    return i;
+  }
+
+  /// Query as an unsigned integer. See IntValue()
+  unsigned UnsignedValue() const {
+    unsigned i = 0;
+    QueryUnsignedValue(&i);
+    return i;
+  }
+  /// Query as a boolean. See IntValue()
+  bool BoolValue() const {
+    bool b = false;
+    QueryBoolValue(&b);
+    return b;
+  }
+  /// Query as a double. See IntValue()
+  double DoubleValue() const {
+    double d = 0;
+    QueryDoubleValue(&d);
+    return d;
+  }
+  /// Query as a float. See IntValue()
+  float FloatValue() const {
+    float f = 0;
+    QueryFloatValue(&f);
+    return f;
+  }
+
+  /** QueryIntValue interprets the attribute as an integer, and returns the
+     value in the provided parameter. The function will return XML_SUCCESS on
+     success, and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.
+  */
+  XMLError QueryIntValue(int* value) const;
+  /// See QueryIntValue
+  XMLError QueryUnsignedValue(unsigned int* value) const;
+  /// See QueryIntValue
+  XMLError QueryInt64Value(int64_t* value) const;
+  /// See QueryIntValue
+  XMLError QueryUnsigned64Value(uint64_t* value) const;
+  /// See QueryIntValue
+  XMLError QueryBoolValue(bool* value) const;
+  /// See QueryIntValue
+  XMLError QueryDoubleValue(double* value) const;
+  /// See QueryIntValue
+  XMLError QueryFloatValue(float* value) const;
+
+  /// Set the attribute to a string value.
+  void SetAttribute(const char* value);
+  /// Set the attribute to value.
+  void SetAttribute(int value);
+  /// Set the attribute to value.
+  void SetAttribute(unsigned value);
+  /// Set the attribute to value.
+  void SetAttribute(int64_t value);
+  /// Set the attribute to value.
+  void SetAttribute(uint64_t value);
+  /// Set the attribute to value.
+  void SetAttribute(bool value);
+  /// Set the attribute to value.
+  void SetAttribute(double value);
+  /// Set the attribute to value.
+  void SetAttribute(float value);
+
+ private:
+  enum { BUF_SIZE = 200 };
+
+  XMLAttribute() : _name(), _value(), _parseLineNum(0), _next(0), _memPool(0) {}
+  virtual ~XMLAttribute() {}
+
+  XMLAttribute(const XMLAttribute&);    // not supported
+  void operator=(const XMLAttribute&);  // not supported
+  void SetName(const char* name);
+
+  char* ParseDeep(char* p, bool processEntities, int* curLineNumPtr);
+
+  mutable StrPair _name;
+  mutable StrPair _value;
+  int _parseLineNum;
+  XMLAttribute* _next;
+  MemPool* _memPool;
+};
+
+/** The element is a container class. It has a value, the element name,
+        and can contain other elements, text, comments, and unknowns.
+        Elements also contain an arbitrary number of attributes.
+*/
+class TINYXML2_LIB XMLElement : public XMLNode {
+  friend class XMLDocument;
+
+ public:
+  /// Get the name of an element (which is the Value() of the node.)
+  const char* Name() const { return Value(); }
+  /// Set the name of the element.
+  void SetName(const char* str, bool staticMem = false) {
+    SetValue(str, staticMem);
+  }
+
+  virtual XMLElement* ToElement() override { return this; }
+  virtual const XMLElement* ToElement() const override { return this; }
+  virtual bool Accept(XMLVisitor* visitor) const override;
+
+  /** Given an attribute name, Attribute() returns the value
+      for the attribute of that name, or null if none
+      exists. For example:
+
+      @verbatim
+      const char* value = ele->Attribute( "foo" );
+      @endverbatim
+
+      The 'value' parameter is normally null. However, if specified,
+      the attribute will only be returned if the 'name' and 'value'
+      match. This allow you to write code:
+
+      @verbatim
+      if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();
+      @endverbatim
+
+      rather than:
+      @verbatim
+      if ( ele->Attribute( "foo" ) ) {
+              if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 )
+     callFooIsBar();
+      }
+      @endverbatim
+  */
+  const char* Attribute(const char* name, const char* value = 0) const;
+
+  /** Given an attribute name, IntAttribute() returns the value
+      of the attribute interpreted as an integer. The default
+      value will be returned if the attribute isn't present,
+      or if there is an error. (For a method with error
+      checking, see QueryIntAttribute()).
+  */
+  int IntAttribute(const char* name, int defaultValue = 0) const;
+  /// See IntAttribute()
+  unsigned UnsignedAttribute(const char* name, unsigned defaultValue = 0) const;
+  /// See IntAttribute()
+  int64_t Int64Attribute(const char* name, int64_t defaultValue = 0) const;
+  /// See IntAttribute()
+  uint64_t Unsigned64Attribute(const char* name,
+                               uint64_t defaultValue = 0) const;
+  /// See IntAttribute()
+  bool BoolAttribute(const char* name, bool defaultValue = false) const;
+  /// See IntAttribute()
+  double DoubleAttribute(const char* name, double defaultValue = 0) const;
+  /// See IntAttribute()
+  float FloatAttribute(const char* name, float defaultValue = 0) const;
+
+  /** Given an attribute name, QueryIntAttribute() returns
+      XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
+      can't be performed, or XML_NO_ATTRIBUTE if the attribute
+      doesn't exist. If successful, the result of the conversion
+      will be written to 'value'. If not successful, nothing will
+      be written to 'value'. This allows you to provide default
+      value:
+
+      @verbatim
+      int value = 10;
+      QueryIntAttribute( "foo", &value );		// if "foo" isn't found,
+     value will still be 10
+      @endverbatim
+  */
+  XMLError QueryIntAttribute(const char* name, int* value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
     }
-
-    inline static bool IsPrefixHex( const char* p) {
-        p = SkipWhiteSpace(p, 0);
-        return p && *p == '0' && ( *(p + 1) == 'x' || *(p + 1) == 'X');
+    return a->QueryIntValue(value);
+  }
+
+  /// See QueryIntAttribute()
+  XMLError QueryUnsignedAttribute(const char* name, unsigned int* value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
     }
-
-    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {
-        if ( p == q ) {
-            return true;
-        }
-        TIXMLASSERT( p );
-        TIXMLASSERT( q );
-        TIXMLASSERT( nChar >= 0 );
-        return strncmp( p, q, static_cast<size_t>(nChar) ) == 0;
+    return a->QueryUnsignedValue(value);
+  }
+
+  /// See QueryIntAttribute()
+  XMLError QueryInt64Attribute(const char* name, int64_t* value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
     }
-
-    inline static bool IsUTF8Continuation( const char p ) {
-        return ( p & 0x80 ) != 0;
+    return a->QueryInt64Value(value);
+  }
+
+  /// See QueryIntAttribute()
+  XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
     }
-
-    static const char* ReadBOM( const char* p, bool* hasBOM );
-    // p is the starting location,
-    // the UTF-8 value of the entity will be placed in value, and length filled in.
-    static const char* GetCharacterRef( const char* p, char* value, int* length );
-    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
-
-    // converts primitive types to strings
-    static void ToStr( int v, char* buffer, int bufferSize );
-    static void ToStr( unsigned v, char* buffer, int bufferSize );
-    static void ToStr( bool v, char* buffer, int bufferSize );
-    static void ToStr( float v, char* buffer, int bufferSize );
-    static void ToStr( double v, char* buffer, int bufferSize );
-	static void ToStr(int64_t v, char* buffer, int bufferSize);
-    static void ToStr(uint64_t v, char* buffer, int bufferSize);
-
-    // converts strings to primitive types
-    static bool	ToInt( const char* str, int* value );
-    static bool ToUnsigned( const char* str, unsigned* value );
-    static bool	ToBool( const char* str, bool* value );
-    static bool	ToFloat( const char* str, float* value );
-    static bool ToDouble( const char* str, double* value );
-	static bool ToInt64(const char* str, int64_t* value);
-    static bool ToUnsigned64(const char* str, uint64_t* value);
-	// Changes what is serialized for a boolean value.
-	// Default to "true" and "false". Shouldn't be changed
-	// unless you have a special testing or compatibility need.
-	// Be careful: static, global, & not thread safe.
-	// Be sure to set static const memory as parameters.
-	static void SetBoolSerialization(const char* writeTrue, const char* writeFalse);
-
-private:
-	static const char* writeBoolTrue;
-	static const char* writeBoolFalse;
+    return a->QueryUnsigned64Value(value);
+  }
+
+  /// See QueryIntAttribute()
+  XMLError QueryBoolAttribute(const char* name, bool* value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
+    }
+    return a->QueryBoolValue(value);
+  }
+  /// See QueryIntAttribute()
+  XMLError QueryDoubleAttribute(const char* name, double* value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
+    }
+    return a->QueryDoubleValue(value);
+  }
+  /// See QueryIntAttribute()
+  XMLError QueryFloatAttribute(const char* name, float* value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
+    }
+    return a->QueryFloatValue(value);
+  }
+
+  /// See QueryIntAttribute()
+  XMLError QueryStringAttribute(const char* name, const char** value) const {
+    const XMLAttribute* a = FindAttribute(name);
+    if (!a) {
+      return XML_NO_ATTRIBUTE;
+    }
+    *value = a->Value();
+    return XML_SUCCESS;
+  }
+
+  /** Given an attribute name, QueryAttribute() returns
+      XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
+      can't be performed, or XML_NO_ATTRIBUTE if the attribute
+      doesn't exist. It is overloaded for the primitive types,
+              and is a generally more convenient replacement of
+              QueryIntAttribute() and related functions.
+
+              If successful, the result of the conversion
+      will be written to 'value'. If not successful, nothing will
+      be written to 'value'. This allows you to provide default
+      value:
+
+      @verbatim
+      int value = 10;
+      QueryAttribute( "foo", &value );		// if "foo" isn't found, value
+     will still be 10
+      @endverbatim
+  */
+  XMLError QueryAttribute(const char* name, int* value) const {
+    return QueryIntAttribute(name, value);
+  }
+
+  XMLError QueryAttribute(const char* name, unsigned int* value) const {
+    return QueryUnsignedAttribute(name, value);
+  }
+
+  XMLError QueryAttribute(const char* name, int64_t* value) const {
+    return QueryInt64Attribute(name, value);
+  }
+
+  XMLError QueryAttribute(const char* name, uint64_t* value) const {
+    return QueryUnsigned64Attribute(name, value);
+  }
+
+  XMLError QueryAttribute(const char* name, bool* value) const {
+    return QueryBoolAttribute(name, value);
+  }
+
+  XMLError QueryAttribute(const char* name, double* value) const {
+    return QueryDoubleAttribute(name, value);
+  }
+
+  XMLError QueryAttribute(const char* name, float* value) const {
+    return QueryFloatAttribute(name, value);
+  }
+
+  XMLError QueryAttribute(const char* name, const char** value) const {
+    return QueryStringAttribute(name, value);
+  }
+
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, const char* value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, int value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, unsigned value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, int64_t value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, uint64_t value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, bool value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, double value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+  /// Sets the named attribute to value.
+  void SetAttribute(const char* name, float value) {
+    XMLAttribute* a = FindOrCreateAttribute(name);
+    a->SetAttribute(value);
+  }
+
+  /**
+      Delete an attribute.
+  */
+  void DeleteAttribute(const char* name);
+
+  /// Return the first attribute in the list.
+  const XMLAttribute* FirstAttribute() const { return _rootAttribute; }
+  /// Query a specific attribute in the list.
+  const XMLAttribute* FindAttribute(const char* name) const;
+
+  /** Convenience function for easy access to the text inside an element.
+     Although easy and concise, GetText() is limited compared to getting the
+     XMLText child and accessing it directly.
+
+      If the first child of 'this' is a XMLText, the GetText()
+      returns the character string of the Text node, else null is returned.
+
+      This is a convenient method for getting the text of simple contained text:
+      @verbatim
+      <foo>This is text</foo>
+              const char* str = fooElement->GetText();
+      @endverbatim
+
+      'str' will be a pointer to "This is text".
+
+      Note that this function can be misleading. If the element foo was created
+     from this XML:
+      @verbatim
+              <foo><b>This is text</b></foo>
+      @endverbatim
+
+      then the value of str would be null. The first child node isn't a text
+     node, it is another element. From this XML:
+      @verbatim
+              <foo>This is <b>text</b></foo>
+      @endverbatim
+      GetText() will return "This is ".
+  */
+  const char* GetText() const;
+
+  /** Convenience function for easy access to the text inside an element.
+     Although easy and concise, SetText() is limited compared to creating an
+     XMLText child and mutating it directly.
+
+      If the first child of 'this' is a XMLText, SetText() sets its value to
+              the given string, otherwise it will create a first child that is
+     an XMLText.
+
+      This is a convenient method for setting the text of simple contained text:
+      @verbatim
+      <foo>This is text</foo>
+              fooElement->SetText( "Hullaballoo!" );
+      <foo>Hullaballoo!</foo>
+              @endverbatim
+
+      Note that this function can be misleading. If the element foo was created
+     from this XML:
+      @verbatim
+              <foo><b>This is text</b></foo>
+      @endverbatim
+
+      then it will not change "This is text", but rather prefix it with a text
+     element:
+      @verbatim
+              <foo>Hullaballoo!<b>This is text</b></foo>
+      @endverbatim
+
+              For this XML:
+      @verbatim
+              <foo />
+      @endverbatim
+      SetText() will generate
+      @verbatim
+              <foo>Hullaballoo!</foo>
+      @endverbatim
+  */
+  void SetText(const char* inText);
+  /// Convenience method for setting text inside an element. See SetText() for
+  /// important limitations.
+  void SetText(int value);
+  /// Convenience method for setting text inside an element. See SetText() for
+  /// important limitations.
+  void SetText(unsigned value);
+  /// Convenience method for setting text inside an element. See SetText() for
+  /// important limitations.
+  void SetText(int64_t value);
+  /// Convenience method for setting text inside an element. See SetText() for
+  /// important limitations.
+  void SetText(uint64_t value);
+  /// Convenience method for setting text inside an element. See SetText() for
+  /// important limitations.
+  void SetText(bool value);
+  /// Convenience method for setting text inside an element. See SetText() for
+  /// important limitations.
+  void SetText(double value);
+  /// Convenience method for setting text inside an element. See SetText() for
+  /// important limitations.
+  void SetText(float value);
+
+  /**
+      Convenience method to query the value of a child text node. This is
+     probably best shown by example. Given you have a document is this form:
+      @verbatim
+              <point>
+                      <x>1</x>
+                      <y>1.4</y>
+              </point>
+      @endverbatim
+
+      The QueryIntText() and similar functions provide a safe and easier way to
+     get to the "value" of x and y.
+
+      @verbatim
+              int x = 0;
+              float y = 0;	// types of x and y are contrived for example
+              const XMLElement* xElement = pointElement->FirstChildElement( "x"
+     ); const XMLElement* yElement = pointElement->FirstChildElement( "y" );
+              xElement->QueryIntText( &x );
+              yElement->QueryFloatText( &y );
+      @endverbatim
+
+      @returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text
+     cannot be converted to the requested type, and XML_NO_TEXT_NODE if there is
+     no child text to query.
+
+  */
+  XMLError QueryIntText(int* ival) const;
+  /// See QueryIntText()
+  XMLError QueryUnsignedText(unsigned* uval) const;
+  /// See QueryIntText()
+  XMLError QueryInt64Text(int64_t* uval) const;
+  /// See QueryIntText()
+  XMLError QueryUnsigned64Text(uint64_t* uval) const;
+  /// See QueryIntText()
+  XMLError QueryBoolText(bool* bval) const;
+  /// See QueryIntText()
+  XMLError QueryDoubleText(double* dval) const;
+  /// See QueryIntText()
+  XMLError QueryFloatText(float* fval) const;
+
+  int IntText(int defaultValue = 0) const;
+
+  /// See QueryIntText()
+  unsigned UnsignedText(unsigned defaultValue = 0) const;
+  /// See QueryIntText()
+  int64_t Int64Text(int64_t defaultValue = 0) const;
+  /// See QueryIntText()
+  uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;
+  /// See QueryIntText()
+  bool BoolText(bool defaultValue = false) const;
+  /// See QueryIntText()
+  double DoubleText(double defaultValue = 0) const;
+  /// See QueryIntText()
+  float FloatText(float defaultValue = 0) const;
+
+  /**
+      Convenience method to create a new XMLElement and add it as last (right)
+      child of this node. Returns the created and inserted element.
+  */
+  XMLElement* InsertNewChildElement(const char* name);
+  /// See InsertNewChildElement()
+  XMLComment* InsertNewComment(const char* comment);
+  /// See InsertNewChildElement()
+  XMLText* InsertNewText(const char* text);
+  /// See InsertNewChildElement()
+  XMLDeclaration* InsertNewDeclaration(const char* text);
+  /// See InsertNewChildElement()
+  XMLUnknown* InsertNewUnknown(const char* text);
+
+  // internal:
+  enum ElementClosingType {
+    OPEN,    // <foo>
+    CLOSED,  // <foo/>
+    CLOSING  // </foo>
+  };
+  ElementClosingType ClosingType() const { return _closingType; }
+  virtual XMLNode* ShallowClone(XMLDocument* document) const override;
+  virtual bool ShallowEqual(const XMLNode* compare) const override;
+
+ protected:
+  char* ParseDeep(char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
+
+ private:
+  XMLElement(XMLDocument* doc);
+  virtual ~XMLElement();
+  XMLElement(const XMLElement&);      // not supported
+  void operator=(const XMLElement&);  // not supported
+
+  XMLAttribute* FindOrCreateAttribute(const char* name);
+  char* ParseAttributes(char* p, int* curLineNumPtr);
+  static void DeleteAttribute(XMLAttribute* attribute);
+  XMLAttribute* CreateAttribute();
+
+  enum { BUF_SIZE = 200 };
+  ElementClosingType _closingType;
+  // The attribute list is ordered; there is no 'lastAttribute'
+  // because the list needs to be scanned for dupes before adding
+  // a new attribute.
+  XMLAttribute* _rootAttribute;
 };
 
-
-/** XMLNode is a base class for every object that is in the
-	XML Document Object Model (DOM), except XMLAttributes.
-	Nodes have siblings, a parent, and children which can
-	be navigated. A node is always in a XMLDocument.
-	The type of a XMLNode can be queried, and it can
-	be cast to its more defined type.
-
-	A XMLDocument allocates memory for all its Nodes.
-	When the XMLDocument gets deleted, all its Nodes
-	will also be deleted.
-
-	@verbatim
-	A Document can contain:	Element	(container or leaf)
-							Comment (leaf)
-							Unknown (leaf)
-							Declaration( leaf )
-
-	An Element can contain:	Element (container or leaf)
-							Text	(leaf)
-							Attributes (not on tree)
-							Comment (leaf)
-							Unknown (leaf)
-
-	@endverbatim
+enum Whitespace {
+  PRESERVE_WHITESPACE,
+  COLLAPSE_WHITESPACE,
+  PEDANTIC_WHITESPACE
+};
+
+/** A Document binds together all the functionality.
+        It can be saved, loaded, and printed to the screen.
+        All Nodes are connected and allocated to a Document.
+        If the Document is deleted, all its Nodes are also deleted.
 */
-class TINYXML2_LIB XMLNode
-{
-    friend class XMLDocument;
-    friend class XMLElement;
-public:
-
-    /// Get the XMLDocument that owns this XMLNode.
-    const XMLDocument* GetDocument() const	{
-        TIXMLASSERT( _document );
-        return _document;
+class TINYXML2_LIB XMLDocument : public XMLNode {
+  friend class XMLElement;
+  // Gives access to SetError and Push/PopDepth, but over-access for everything
+  // else. Wishing C++ had "internal" scope.
+  friend class XMLNode;
+  friend class XMLText;
+  friend class XMLComment;
+  friend class XMLDeclaration;
+  friend class XMLUnknown;
+
+ public:
+  /// constructor
+  XMLDocument(bool processEntities = true,
+              Whitespace whitespaceMode = PRESERVE_WHITESPACE);
+  ~XMLDocument();
+
+  virtual XMLDocument* ToDocument() override {
+    TIXMLASSERT(this == _document);
+    return this;
+  }
+  virtual const XMLDocument* ToDocument() const override {
+    TIXMLASSERT(this == _document);
+    return this;
+  }
+
+  /**
+      Parse an XML file from a character string.
+      Returns XML_SUCCESS (0) on success, or
+      an errorID.
+
+      You may optionally pass in the 'nBytes', which is
+      the number of bytes which will be parsed. If not
+      specified, TinyXML-2 will assume 'xml' points to a
+      null terminated string.
+  */
+  XMLError Parse(const char* xml, size_t nBytes = static_cast<size_t>(-1));
+
+  /**
+      Load an XML file from disk.
+      Returns XML_SUCCESS (0) on success, or
+      an errorID.
+  */
+  XMLError LoadFile(const char* filename);
+
+  /**
+      Load an XML file from disk. You are responsible
+      for providing and closing the FILE*.
+
+      NOTE: The file should be opened as binary ("rb")
+      not text in order for TinyXML-2 to correctly
+      do newline normalization.
+
+      Returns XML_SUCCESS (0) on success, or
+      an errorID.
+  */
+  XMLError LoadFile(FILE*);
+
+  /**
+      Save the XML file to disk.
+      Returns XML_SUCCESS (0) on success, or
+      an errorID.
+  */
+  XMLError SaveFile(const char* filename, bool compact = false);
+
+  /**
+      Save the XML file to disk. You are responsible
+      for providing and closing the FILE*.
+
+      Returns XML_SUCCESS (0) on success, or
+      an errorID.
+  */
+  XMLError SaveFile(FILE* fp, bool compact = false);
+
+  bool ProcessEntities() const { return _processEntities; }
+  Whitespace WhitespaceMode() const { return _whitespaceMode; }
+
+  /**
+      Returns true if this document has a leading Byte Order Mark of UTF8.
+  */
+  bool HasBOM() const { return _writeBOM; }
+  /** Sets whether to write the BOM when writing the file.
+   */
+  void SetBOM(bool useBOM) { _writeBOM = useBOM; }
+
+  /** Return the root element of DOM. Equivalent to FirstChildElement().
+      To get the first node, use FirstChild().
+  */
+  XMLElement* RootElement() { return FirstChildElement(); }
+  const XMLElement* RootElement() const { return FirstChildElement(); }
+
+  /** Print the Document. If the Printer is not provided, it will
+      print to stdout. If you provide Printer, this can print to a file:
+      @verbatim
+      XMLPrinter printer( fp );
+      doc.Print( &printer );
+      @endverbatim
+
+      Or you can use a printer to print to memory:
+      @verbatim
+      XMLPrinter printer;
+      doc.Print( &printer );
+      // printer.CStr() has a const char* to the XML
+      @endverbatim
+  */
+  void Print(XMLPrinter* streamer = 0) const;
+  virtual bool Accept(XMLVisitor* visitor) const override;
+
+  /**
+      Create a new Element associated with
+      this Document. The memory for the Element
+      is managed by the Document.
+  */
+  XMLElement* NewElement(const char* name);
+  /**
+      Create a new Comment associated with
+      this Document. The memory for the Comment
+      is managed by the Document.
+  */
+  XMLComment* NewComment(const char* comment);
+  /**
+      Create a new Text associated with
+      this Document. The memory for the Text
+      is managed by the Document.
+  */
+  XMLText* NewText(const char* text);
+  /**
+      Create a new Declaration associated with
+      this Document. The memory for the object
+      is managed by the Document.
+
+      If the 'text' param is null, the standard
+      declaration is used.:
+      @verbatim
+              <?xml version="1.0" encoding="UTF-8"?>
+      @endverbatim
+  */
+  XMLDeclaration* NewDeclaration(const char* text = 0);
+  /**
+      Create a new Unknown associated with
+      this Document. The memory for the object
+      is managed by the Document.
+  */
+  XMLUnknown* NewUnknown(const char* text);
+
+  /**
+      Delete a node associated with this document.
+      It will be unlinked from the DOM.
+  */
+  void DeleteNode(XMLNode* node);
+
+  /// Clears the error flags.
+  void ClearError();
+
+  /// Return true if there was an error parsing the document.
+  bool Error() const { return _errorID != XML_SUCCESS; }
+  /// Return the errorID.
+  XMLError ErrorID() const { return _errorID; }
+  const char* ErrorName() const;
+  static const char* ErrorIDToName(XMLError errorID);
+
+  /** Returns a "long form" error description. A hopefully helpful
+      diagnostic with location, line number, and/or additional info.
+  */
+  const char* ErrorStr() const;
+
+  /// A (trivial) utility function that prints the ErrorStr() to stdout.
+  void PrintError() const;
+
+  /// Return the line where the error occurred, or zero if unknown.
+  int ErrorLineNum() const { return _errorLineNum; }
+
+  /// Clear the document, resetting it to the initial state.
+  void Clear();
+
+  /**
+          Copies this document to a target document.
+          The target will be completely cleared before the copy.
+          If you want to copy a sub-tree, see XMLNode::DeepClone().
+
+          NOTE: that the 'target' must be non-null.
+  */
+  void DeepCopy(XMLDocument* target) const;
+
+  // internal
+  char* Identify(char* p, XMLNode** node, bool first);
+
+  // internal
+  void MarkInUse(const XMLNode* const);
+
+  virtual XMLNode* ShallowClone(XMLDocument* /*document*/) const override {
+    return 0;
+  }
+  virtual bool ShallowEqual(const XMLNode* /*compare*/) const override {
+    return false;
+  }
+
+ private:
+  XMLDocument(const XMLDocument&);     // not supported
+  void operator=(const XMLDocument&);  // not supported
+
+  bool _writeBOM;
+  bool _processEntities;
+  XMLError _errorID;
+  Whitespace _whitespaceMode;
+  mutable StrPair _errorStr;
+  int _errorLineNum;
+  char* _charBuffer;
+  int _parseCurLineNum;
+  int _parsingDepth;
+  // Memory tracking does add some overhead.
+  // However, the code assumes that you don't
+  // have a bunch of unlinked nodes around.
+  // Therefore it takes less memory to track
+  // in the document vs. a linked list in the XMLNode,
+  // and the performance is the same.
+  DynArray<XMLNode*, 10> _unlinked;
+
+  MemPoolT<sizeof(XMLElement)> _elementPool;
+  MemPoolT<sizeof(XMLAttribute)> _attributePool;
+  MemPoolT<sizeof(XMLText)> _textPool;
+  MemPoolT<sizeof(XMLComment)> _commentPool;
+
+  static const char* _errorNames[XML_ERROR_COUNT];
+
+  void Parse();
+
+  void SetError(XMLError error, int lineNum, const char* format, ...);
+
+  // Something of an obvious security hole, once it was discovered.
+  // Either an ill-formed XML or an excessively deep one can overflow
+  // the stack. Track stack depth, and error out if needed.
+  class DepthTracker {
+   public:
+    explicit DepthTracker(XMLDocument* document) {
+      this->_document = document;
+      document->PushDepth();
     }
-    /// Get the XMLDocument that owns this XMLNode.
-    XMLDocument* GetDocument()				{
-        TIXMLASSERT( _document );
-        return _document;
-    }
-
-    /// Safely cast to an Element, or null.
-    virtual XMLElement*		ToElement()		{
-        return 0;
-    }
-    /// Safely cast to Text, or null.
-    virtual XMLText*		ToText()		{
-        return 0;
-    }
-    /// Safely cast to a Comment, or null.
-    virtual XMLComment*		ToComment()		{
-        return 0;
-    }
-    /// Safely cast to a Document, or null.
-    virtual XMLDocument*	ToDocument()	{
-        return 0;
-    }
-    /// Safely cast to a Declaration, or null.
-    virtual XMLDeclaration*	ToDeclaration()	{
-        return 0;
-    }
-    /// Safely cast to an Unknown, or null.
-    virtual XMLUnknown*		ToUnknown()		{
-        return 0;
-    }
-
-    virtual const XMLElement*		ToElement() const		{
-        return 0;
-    }
-    virtual const XMLText*			ToText() const			{
-        return 0;
-    }
-    virtual const XMLComment*		ToComment() const		{
-        return 0;
-    }
-    virtual const XMLDocument*		ToDocument() const		{
-        return 0;
-    }
-    virtual const XMLDeclaration*	ToDeclaration() const	{
-        return 0;
-    }
-    virtual const XMLUnknown*		ToUnknown() const		{
-        return 0;
-    }
-
-    // ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.
-
-    int ChildElementCount(const char *value) const;
-
-    int ChildElementCount() const;
-
-    /** The meaning of 'value' changes for the specific type.
-    	@verbatim
-    	Document:	empty (NULL is returned, not an empty string)
-    	Element:	name of the element
-    	Comment:	the comment text
-    	Unknown:	the tag contents
-    	Text:		the text string
-    	@endverbatim
-    */
-    const char* Value() const;
-
-    /** Set the Value of an XML node.
-    	@sa Value()
-    */
-    void SetValue( const char* val, bool staticMem=false );
-
-    /// Gets the line number the node is in, if the document was parsed from a file.
-    int GetLineNum() const { return _parseLineNum; }
-
-    /// Get the parent of this node on the DOM.
-    const XMLNode*	Parent() const			{
-        return _parent;
-    }
-
-    XMLNode* Parent()						{
-        return _parent;
-    }
-
-    /// Returns true if this node has no children.
-    bool NoChildren() const					{
-        return !_firstChild;
-    }
-
-    /// Get the first child node, or null if none exists.
-    const XMLNode*  FirstChild() const		{
-        return _firstChild;
-    }
-
-    XMLNode*		FirstChild()			{
-        return _firstChild;
-    }
-
-    /** Get the first child element, or optionally the first child
-        element with the specified name.
-    */
-    const XMLElement* FirstChildElement( const char* name = 0 ) const;
-
-    XMLElement* FirstChildElement( const char* name = 0 )	{
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( name ));
-    }
-
-    /// Get the last child node, or null if none exists.
-    const XMLNode*	LastChild() const						{
-        return _lastChild;
-    }
-
-    XMLNode*		LastChild()								{
-        return _lastChild;
-    }
-
-    /** Get the last child element or optionally the last child
-        element with the specified name.
-    */
-    const XMLElement* LastChildElement( const char* name = 0 ) const;
-
-    XMLElement* LastChildElement( const char* name = 0 )	{
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(name) );
-    }
-
-    /// Get the previous (left) sibling node of this node.
-    const XMLNode*	PreviousSibling() const					{
-        return _prev;
-    }
-
-    XMLNode*	PreviousSibling()							{
-        return _prev;
-    }
-
-    /// Get the previous (left) sibling element of this node, with an optionally supplied name.
-    const XMLElement*	PreviousSiblingElement( const char* name = 0 ) const ;
-
-    XMLElement*	PreviousSiblingElement( const char* name = 0 ) {
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( name ) );
-    }
-
-    /// Get the next (right) sibling node of this node.
-    const XMLNode*	NextSibling() const						{
-        return _next;
-    }
-
-    XMLNode*	NextSibling()								{
-        return _next;
-    }
-
-    /// Get the next (right) sibling element of this node, with an optionally supplied name.
-    const XMLElement*	NextSiblingElement( const char* name = 0 ) const;
-
-    XMLElement*	NextSiblingElement( const char* name = 0 )	{
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( name ) );
-    }
-
-    /**
-    	Add a child node as the last (right) child.
-		If the child node is already part of the document,
-		it is moved from its old location to the new location.
-		Returns the addThis argument or 0 if the node does not
-		belong to the same document.
-    */
-    XMLNode* InsertEndChild( XMLNode* addThis );
-
-    XMLNode* LinkEndChild( XMLNode* addThis )	{
-        return InsertEndChild( addThis );
-    }
-    /**
-    	Add a child node as the first (left) child.
-		If the child node is already part of the document,
-		it is moved from its old location to the new location.
-		Returns the addThis argument or 0 if the node does not
-		belong to the same document.
-    */
-    XMLNode* InsertFirstChild( XMLNode* addThis );
-    /**
-    	Add a node after the specified child node.
-		If the child node is already part of the document,
-		it is moved from its old location to the new location.
-		Returns the addThis argument or 0 if the afterThis node
-		is not a child of this node, or if the node does not
-		belong to the same document.
-    */
-    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );
-
-    /**
-    	Delete all the children of this node.
-    */
-    void DeleteChildren();
-
-    /**
-    	Delete a child of this node.
-    */
-    void DeleteChild( XMLNode* node );
-
-    /**
-    	Make a copy of this node, but not its children.
-    	You may pass in a Document pointer that will be
-    	the owner of the new Node. If the 'document' is
-    	null, then the node returned will be allocated
-    	from the current Document. (this->GetDocument())
-
-    	Note: if called on a XMLDocument, this will return null.
-    */
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;
-
-	/**
-		Make a copy of this node and all its children.
-
-		If the 'target' is null, then the nodes will
-		be allocated in the current document. If 'target'
-        is specified, the memory will be allocated in the
-        specified XMLDocument.
-
-		NOTE: This is probably not the correct tool to
-		copy a document, since XMLDocuments can have multiple
-		top level XMLNodes. You probably want to use
-        XMLDocument::DeepCopy()
-	*/
-	XMLNode* DeepClone( XMLDocument* target ) const;
-
-    /**
-    	Test if 2 nodes are the same, but don't test children.
-    	The 2 nodes do not need to be in the same Document.
-
-    	Note: if called on a XMLDocument, this will return false.
-    */
-    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;
-
-    /** Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the
-    	XML tree will be conditionally visited and the host will be called back
-    	via the XMLVisitor interface.
-
-    	This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse
-    	the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this
-    	interface versus any other.)
-
-    	The interface has been based on ideas from:
-
-    	- http://www.saxproject.org/
-    	- http://c2.com/cgi/wiki?HierarchicalVisitorPattern
-
-    	Which are both good references for "visiting".
-
-    	An example of using Accept():
-    	@verbatim
-    	XMLPrinter printer;
-    	tinyxmlDoc.Accept( &printer );
-    	const char* xmlcstr = printer.CStr();
-    	@endverbatim
-    */
-    virtual bool Accept( XMLVisitor* visitor ) const = 0;
-
-	/**
-		Set user data into the XMLNode. TinyXML-2 in
-		no way processes or interprets user data.
-		It is initially 0.
-	*/
-	void SetUserData(void* userData)	{ _userData = userData; }
-
-	/**
-		Get user data set into the XMLNode. TinyXML-2 in
-		no way processes or interprets user data.
-		It is initially 0.
-	*/
-	void* GetUserData() const			{ return _userData; }
-
-protected:
-    explicit XMLNode( XMLDocument* );
-    virtual ~XMLNode();
-
-    virtual char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr);
-
-    XMLDocument*	_document;
-    XMLNode*		_parent;
-    mutable StrPair	_value;
-    int             _parseLineNum;
-
-    XMLNode*		_firstChild;
-    XMLNode*		_lastChild;
-
-    XMLNode*		_prev;
-    XMLNode*		_next;
-
-	void*			_userData;
-
-private:
-    MemPool*		_memPool;
-    void Unlink( XMLNode* child );
-    static void DeleteNode( XMLNode* node );
-    void InsertChildPreamble( XMLNode* insertThis ) const;
-    const XMLElement* ToElementWithName( const char* name ) const;
-
-    XMLNode( const XMLNode& );	// not supported
-    XMLNode& operator=( const XMLNode& );	// not supported
+    ~DepthTracker() { _document->PopDepth(); }
+
+   private:
+    XMLDocument* _document;
+  };
+  void PushDepth();
+  void PopDepth();
+
+  template <class NodeType, size_t PoolElementSize>
+  NodeType* CreateUnlinkedNode(MemPoolT<PoolElementSize>& pool);
 };
 
-
-/** XML text.
-
-	Note that a text node can have child element nodes, for example:
-	@verbatim
-	<root>This is <b>bold</b></root>
-	@endverbatim
-
-	A text node can have 2 ways to output the next. "normal" output
-	and CDATA. It will default to the mode it was parsed from the XML file and
-	you generally want to leave it alone, but you can change the output mode with
-	SetCData() and query it with CData().
+template <class NodeType, size_t PoolElementSize>
+inline NodeType* XMLDocument::CreateUnlinkedNode(
+    MemPoolT<PoolElementSize>& pool) {
+  TIXMLASSERT(sizeof(NodeType) == PoolElementSize);
+  TIXMLASSERT(sizeof(NodeType) == pool.ItemSize());
+  NodeType* returnNode = new (pool.Alloc()) NodeType(this);
+  TIXMLASSERT(returnNode);
+  returnNode->_memPool = &pool;
+
+  _unlinked.Push(returnNode);
+  return returnNode;
+}
+
+/**
+        A XMLHandle is a class that wraps a node pointer with null checks; this
+   is an incredibly useful thing. Note that XMLHandle is not part of the
+   TinyXML-2 DOM structure. It is a separate utility class.
+
+        Take an example:
+        @verbatim
+        <Document>
+                <Element attributeA = "valueA">
+                        <Child attributeB = "value1" />
+                        <Child attributeB = "value2" />
+                </Element>
+        </Document>
+        @endverbatim
+
+        Assuming you want the value of "attributeB" in the 2nd "Child" element,
+   it's very easy to write a *lot* of code that looks like:
+
+        @verbatim
+        XMLElement* root = document.FirstChildElement( "Document" );
+        if ( root )
+        {
+                XMLElement* element = root->FirstChildElement( "Element" );
+                if ( element )
+                {
+                        XMLElement* child = element->FirstChildElement( "Child"
+   ); if ( child )
+                        {
+                                XMLElement* child2 = child->NextSiblingElement(
+   "Child" ); if ( child2 )
+                                {
+                                        // Finally do something useful.
+        @endverbatim
+
+        And that doesn't even cover "else" cases. XMLHandle addresses the
+   verbosity of such code. A XMLHandle checks for null pointers so it is
+   perfectly safe and correct to use:
+
+        @verbatim
+        XMLHandle docHandle( &document );
+        XMLElement* child2 = docHandle.FirstChildElement( "Document"
+   ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement(); if
+   ( child2 )
+        {
+                // do something useful
+        @endverbatim
+
+        Which is MUCH more concise and useful.
+
+        It is also safe to copy handles - internally they are nothing more than
+   node pointers.
+        @verbatim
+        XMLHandle handleCopy = handle;
+        @endverbatim
+
+        See also XMLConstHandle, which is the same as XMLHandle, but operates on
+   const objects.
 */
-class TINYXML2_LIB XMLText : public XMLNode
-{
-    friend class XMLDocument;
-public:
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLText* ToText() override		{
-        return this;
-    }
-    virtual const XMLText* ToText() const override {
-        return this;
-    }
-
-    /// Declare whether this should be CDATA or standard text.
-    void SetCData( bool isCData )			{
-        _isCData = isCData;
-    }
-    /// Returns true if this is a CDATA text element.
-    bool CData() const						{
-        return _isCData;
-    }
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
-
-protected:
-    explicit XMLText( XMLDocument* doc )	: XMLNode( doc ), _isCData( false )	{}
-    virtual ~XMLText()												{}
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
-
-private:
-    bool _isCData;
-
-    XMLText( const XMLText& );	// not supported
-    XMLText& operator=( const XMLText& );	// not supported
+class TINYXML2_LIB XMLHandle {
+ public:
+  /// Create a handle from any node (at any depth of the tree.) This can be a
+  /// null pointer.
+  explicit XMLHandle(XMLNode* node) : _node(node) {}
+  /// Create a handle from a node.
+  explicit XMLHandle(XMLNode& node) : _node(&node) {}
+  /// Copy constructor
+  XMLHandle(const XMLHandle& ref) : _node(ref._node) {}
+  /// Assignment
+  XMLHandle& operator=(const XMLHandle& ref) {
+    _node = ref._node;
+    return *this;
+  }
+
+  /// Get the first child of this handle.
+  XMLHandle FirstChild() { return XMLHandle(_node ? _node->FirstChild() : 0); }
+  /// Get the first child element of this handle.
+  XMLHandle FirstChildElement(const char* name = 0) {
+    return XMLHandle(_node ? _node->FirstChildElement(name) : 0);
+  }
+  /// Get the last child of this handle.
+  XMLHandle LastChild() { return XMLHandle(_node ? _node->LastChild() : 0); }
+  /// Get the last child element of this handle.
+  XMLHandle LastChildElement(const char* name = 0) {
+    return XMLHandle(_node ? _node->LastChildElement(name) : 0);
+  }
+  /// Get the previous sibling of this handle.
+  XMLHandle PreviousSibling() {
+    return XMLHandle(_node ? _node->PreviousSibling() : 0);
+  }
+  /// Get the previous sibling element of this handle.
+  XMLHandle PreviousSiblingElement(const char* name = 0) {
+    return XMLHandle(_node ? _node->PreviousSiblingElement(name) : 0);
+  }
+  /// Get the next sibling of this handle.
+  XMLHandle NextSibling() {
+    return XMLHandle(_node ? _node->NextSibling() : 0);
+  }
+  /// Get the next sibling element of this handle.
+  XMLHandle NextSiblingElement(const char* name = 0) {
+    return XMLHandle(_node ? _node->NextSiblingElement(name) : 0);
+  }
+
+  /// Safe cast to XMLNode. This can return null.
+  XMLNode* ToNode() { return _node; }
+  /// Safe cast to XMLElement. This can return null.
+  XMLElement* ToElement() { return (_node ? _node->ToElement() : 0); }
+  /// Safe cast to XMLText. This can return null.
+  XMLText* ToText() { return (_node ? _node->ToText() : 0); }
+  /// Safe cast to XMLUnknown. This can return null.
+  XMLUnknown* ToUnknown() { return (_node ? _node->ToUnknown() : 0); }
+  /// Safe cast to XMLDeclaration. This can return null.
+  XMLDeclaration* ToDeclaration() {
+    return (_node ? _node->ToDeclaration() : 0);
+  }
+
+ private:
+  XMLNode* _node;
 };
 
-
-/** An XML Comment. */
-class TINYXML2_LIB XMLComment : public XMLNode
-{
-    friend class XMLDocument;
-public:
-    virtual XMLComment*	ToComment() override		{
-        return this;
-    }
-    virtual const XMLComment* ToComment() const override {
-        return this;
-    }
-
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
-
-protected:
-    explicit XMLComment( XMLDocument* doc );
-    virtual ~XMLComment();
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
-
-private:
-    XMLComment( const XMLComment& );	// not supported
-    XMLComment& operator=( const XMLComment& );	// not supported
+/**
+        A variant of the XMLHandle class for working with const XMLNodes and
+   Documents. It is the same in all regards, except for the 'const' qualifiers.
+   See XMLHandle for API.
+*/
+class TINYXML2_LIB XMLConstHandle {
+ public:
+  explicit XMLConstHandle(const XMLNode* node) : _node(node) {}
+  explicit XMLConstHandle(const XMLNode& node) : _node(&node) {}
+  XMLConstHandle(const XMLConstHandle& ref) : _node(ref._node) {}
+
+  XMLConstHandle& operator=(const XMLConstHandle& ref) {
+    _node = ref._node;
+    return *this;
+  }
+
+  const XMLConstHandle FirstChild() const {
+    return XMLConstHandle(_node ? _node->FirstChild() : 0);
+  }
+  const XMLConstHandle FirstChildElement(const char* name = 0) const {
+    return XMLConstHandle(_node ? _node->FirstChildElement(name) : 0);
+  }
+  const XMLConstHandle LastChild() const {
+    return XMLConstHandle(_node ? _node->LastChild() : 0);
+  }
+  const XMLConstHandle LastChildElement(const char* name = 0) const {
+    return XMLConstHandle(_node ? _node->LastChildElement(name) : 0);
+  }
+  const XMLConstHandle PreviousSibling() const {
+    return XMLConstHandle(_node ? _node->PreviousSibling() : 0);
+  }
+  const XMLConstHandle PreviousSiblingElement(const char* name = 0) const {
+    return XMLConstHandle(_node ? _node->PreviousSiblingElement(name) : 0);
+  }
+  const XMLConstHandle NextSibling() const {
+    return XMLConstHandle(_node ? _node->NextSibling() : 0);
+  }
+  const XMLConstHandle NextSiblingElement(const char* name = 0) const {
+    return XMLConstHandle(_node ? _node->NextSiblingElement(name) : 0);
+  }
+
+  const XMLNode* ToNode() const { return _node; }
+  const XMLElement* ToElement() const {
+    return (_node ? _node->ToElement() : 0);
+  }
+  const XMLText* ToText() const { return (_node ? _node->ToText() : 0); }
+  const XMLUnknown* ToUnknown() const {
+    return (_node ? _node->ToUnknown() : 0);
+  }
+  const XMLDeclaration* ToDeclaration() const {
+    return (_node ? _node->ToDeclaration() : 0);
+  }
+
+ private:
+  const XMLNode* _node;
 };
 
-
-/** In correct XML the declaration is the first entry in the file.
-	@verbatim
-		<?xml version="1.0" standalone="yes"?>
-	@endverbatim
-
-	TinyXML-2 will happily read or write files without a declaration,
-	however.
-
-	The text of the declaration isn't interpreted. It is parsed
-	and written as a string.
+/**
+        Printing functionality. The XMLPrinter gives you more
+        options than the XMLDocument::Print() method.
+
+        It can:
+        -# Print to memory.
+        -# Print to a file you provide.
+        -# Print XML without a XMLDocument.
+
+        Print to Memory
+
+        @verbatim
+        XMLPrinter printer;
+        doc.Print( &printer );
+        SomeFunction( printer.CStr() );
+        @endverbatim
+
+        Print to a File
+
+        You provide the file pointer.
+        @verbatim
+        XMLPrinter printer( fp );
+        doc.Print( &printer );
+        @endverbatim
+
+        Print without a XMLDocument
+
+        When loading, an XML parser is very useful. However, sometimes
+        when saving, it just gets in the way. The code is often set up
+        for streaming, and constructing the DOM is just overhead.
+
+        The Printer supports the streaming case. The following code
+        prints out a trivially simple XML file without ever creating
+        an XML document.
+
+        @verbatim
+        XMLPrinter printer( fp );
+        printer.OpenElement( "foo" );
+        printer.PushAttribute( "foo", "bar" );
+        printer.CloseElement();
+        @endverbatim
 */
-class TINYXML2_LIB XMLDeclaration : public XMLNode
-{
-    friend class XMLDocument;
-public:
-    virtual XMLDeclaration*	ToDeclaration() override		{
-        return this;
-    }
-    virtual const XMLDeclaration* ToDeclaration() const override {
-        return this;
-    }
-
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
-
-protected:
-    explicit XMLDeclaration( XMLDocument* doc );
-    virtual ~XMLDeclaration();
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
-
-private:
-    XMLDeclaration( const XMLDeclaration& );	// not supported
-    XMLDeclaration& operator=( const XMLDeclaration& );	// not supported
+class TINYXML2_LIB XMLPrinter : public XMLVisitor {
+ public:
+  /** Construct the printer. If the FILE* is specified,
+      this will print to the FILE. Else it will print
+      to memory, and the result is available in CStr().
+      If 'compact' is set to true, then output is created
+      with only required whitespace and newlines.
+  */
+  XMLPrinter(FILE* file = 0, bool compact = false, int depth = 0);
+  virtual ~XMLPrinter() {}
+
+  /** If streaming, write the BOM and declaration. */
+  void PushHeader(bool writeBOM, bool writeDeclaration);
+  /** If streaming, start writing an element.
+      The element must be closed with CloseElement()
+  */
+  void OpenElement(const char* name, bool compactMode = false);
+  /// If streaming, add an attribute to an open element.
+  void PushAttribute(const char* name, const char* value);
+  void PushAttribute(const char* name, int value);
+  void PushAttribute(const char* name, unsigned value);
+  void PushAttribute(const char* name, int64_t value);
+  void PushAttribute(const char* name, uint64_t value);
+  void PushAttribute(const char* name, bool value);
+  void PushAttribute(const char* name, double value);
+  /// If streaming, close the Element.
+  virtual void CloseElement(bool compactMode = false);
+
+  /// Add a text node.
+  void PushText(const char* text, bool cdata = false);
+  /// Add a text node from an integer.
+  void PushText(int value);
+  /// Add a text node from an unsigned.
+  void PushText(unsigned value);
+  /// Add a text node from a signed 64bit integer.
+  void PushText(int64_t value);
+  /// Add a text node from an unsigned 64bit integer.
+  void PushText(uint64_t value);
+  /// Add a text node from a bool.
+  void PushText(bool value);
+  /// Add a text node from a float.
+  void PushText(float value);
+  /// Add a text node from a double.
+  void PushText(double value);
+
+  /// Add a comment
+  void PushComment(const char* comment);
+
+  void PushDeclaration(const char* value);
+  void PushUnknown(const char* value);
+
+  virtual bool VisitEnter(const XMLDocument& /*doc*/) override;
+  virtual bool VisitExit(const XMLDocument& /*doc*/) override { return true; }
+
+  virtual bool VisitEnter(const XMLElement& element,
+                          const XMLAttribute* attribute) override;
+  virtual bool VisitExit(const XMLElement& element) override;
+
+  virtual bool Visit(const XMLText& text) override;
+  virtual bool Visit(const XMLComment& comment) override;
+  virtual bool Visit(const XMLDeclaration& declaration) override;
+  virtual bool Visit(const XMLUnknown& unknown) override;
+
+  /**
+      If in print to memory mode, return a pointer to
+      the XML file in memory.
+  */
+  const char* CStr() const { return _buffer.Mem(); }
+  /**
+      If in print to memory mode, return the size
+      of the XML file in memory. (Note the size returned
+      includes the terminating null.)
+  */
+  size_t CStrSize() const { return _buffer.Size(); }
+  /**
+      If in print to memory mode, reset the buffer to the
+      beginning.
+  */
+  void ClearBuffer(bool resetToFirstElement = true) {
+    _buffer.Clear();
+    _buffer.Push(0);
+    _firstElement = resetToFirstElement;
+  }
+
+ protected:
+  virtual bool CompactMode(const XMLElement&) { return _compactMode; }
+
+  /** Prints out the space before an element. You may override to change
+      the space and tabs used. A PrintSpace() override should call Print().
+  */
+  virtual void PrintSpace(int depth);
+  virtual void Print(const char* format, ...);
+  virtual void Write(const char* data, size_t size);
+  virtual void Putc(char ch);
+
+  inline void Write(const char* data) { Write(data, strlen(data)); }
+
+  void SealElementIfJustOpened();
+  bool _elementJustOpened;
+  DynArray<const char*, 10> _stack;
+
+ private:
+  /**
+     Prepares to write a new node. This includes sealing an element that was
+     just opened, and writing any whitespace necessary if not in compact mode.
+   */
+  void PrepareForNewNode(bool compactMode);
+  void PrintString(
+      const char*,
+      bool restrictedEntitySet);  // prints out, after detecting entities.
+
+  bool _firstElement;
+  FILE* _fp;
+  int _depth;
+  int _textDepth;
+  bool _processEntities;
+  bool _compactMode;
+
+  enum { ENTITY_RANGE = 64, BUF_SIZE = 200 };
+  bool _entityFlag[ENTITY_RANGE];
+  bool _restrictedEntityFlag[ENTITY_RANGE];
+
+  DynArray<char, 20> _buffer;
+
+  // Prohibit cloning, intentionally not implemented
+  XMLPrinter(const XMLPrinter&);
+  XMLPrinter& operator=(const XMLPrinter&);
 };
 
-
-/** Any tag that TinyXML-2 doesn't recognize is saved as an
-	unknown. It is a tag of text, but should not be modified.
-	It will be written back to the XML, unchanged, when the file
-	is saved.
-
-	DTD tags get thrown into XMLUnknowns.
-*/
-class TINYXML2_LIB XMLUnknown : public XMLNode
-{
-    friend class XMLDocument;
-public:
-    virtual XMLUnknown*	ToUnknown() override		{
-        return this;
-    }
-    virtual const XMLUnknown* ToUnknown() const override {
-        return this;
-    }
-
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
-
-protected:
-    explicit XMLUnknown( XMLDocument* doc );
-    virtual ~XMLUnknown();
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
-
-private:
-    XMLUnknown( const XMLUnknown& );	// not supported
-    XMLUnknown& operator=( const XMLUnknown& );	// not supported
-};
-
-
-
-/** An attribute is a name-value pair. Elements have an arbitrary
-	number of attributes, each with a unique name.
-
-	@note The attributes are not XMLNodes. You may only query the
-	Next() attribute in a list.
-*/
-class TINYXML2_LIB XMLAttribute
-{
-    friend class XMLElement;
-public:
-    /// The name of the attribute.
-    const char* Name() const;
-
-    /// The value of the attribute.
-    const char* Value() const;
-
-    /// Gets the line number the attribute is in, if the document was parsed from a file.
-    int GetLineNum() const { return _parseLineNum; }
-
-    /// The next attribute in the list.
-    const XMLAttribute* Next() const {
-        return _next;
-    }
-
-    /** IntValue interprets the attribute as an integer, and returns the value.
-        If the value isn't an integer, 0 will be returned. There is no error checking;
-    	use QueryIntValue() if you need error checking.
-    */
-	int	IntValue() const {
-		int i = 0;
-		QueryIntValue(&i);
-		return i;
-	}
-
-	int64_t Int64Value() const {
-		int64_t i = 0;
-		QueryInt64Value(&i);
-		return i;
-	}
-
-    uint64_t Unsigned64Value() const {
-        uint64_t i = 0;
-        QueryUnsigned64Value(&i);
-        return i;
-    }
-
-    /// Query as an unsigned integer. See IntValue()
-    unsigned UnsignedValue() const			{
-        unsigned i=0;
-        QueryUnsignedValue( &i );
-        return i;
-    }
-    /// Query as a boolean. See IntValue()
-    bool	 BoolValue() const				{
-        bool b=false;
-        QueryBoolValue( &b );
-        return b;
-    }
-    /// Query as a double. See IntValue()
-    double 	 DoubleValue() const			{
-        double d=0;
-        QueryDoubleValue( &d );
-        return d;
-    }
-    /// Query as a float. See IntValue()
-    float	 FloatValue() const				{
-        float f=0;
-        QueryFloatValue( &f );
-        return f;
-    }
-
-    /** QueryIntValue interprets the attribute as an integer, and returns the value
-    	in the provided parameter. The function will return XML_SUCCESS on success,
-    	and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.
-    */
-    XMLError QueryIntValue( int* value ) const;
-    /// See QueryIntValue
-    XMLError QueryUnsignedValue( unsigned int* value ) const;
-	/// See QueryIntValue
-	XMLError QueryInt64Value(int64_t* value) const;
-    /// See QueryIntValue
-    XMLError QueryUnsigned64Value(uint64_t* value) const;
-	/// See QueryIntValue
-    XMLError QueryBoolValue( bool* value ) const;
-    /// See QueryIntValue
-    XMLError QueryDoubleValue( double* value ) const;
-    /// See QueryIntValue
-    XMLError QueryFloatValue( float* value ) const;
-
-    /// Set the attribute to a string value.
-    void SetAttribute( const char* value );
-    /// Set the attribute to value.
-    void SetAttribute( int value );
-    /// Set the attribute to value.
-    void SetAttribute( unsigned value );
-	/// Set the attribute to value.
-	void SetAttribute(int64_t value);
-    /// Set the attribute to value.
-    void SetAttribute(uint64_t value);
-    /// Set the attribute to value.
-    void SetAttribute( bool value );
-    /// Set the attribute to value.
-    void SetAttribute( double value );
-    /// Set the attribute to value.
-    void SetAttribute( float value );
-
-private:
-    enum { BUF_SIZE = 200 };
-
-    XMLAttribute() : _name(), _value(),_parseLineNum( 0 ), _next( 0 ), _memPool( 0 ) {}
-    virtual ~XMLAttribute()	{}
-
-    XMLAttribute( const XMLAttribute& );	// not supported
-    void operator=( const XMLAttribute& );	// not supported
-    void SetName( const char* name );
-
-    char* ParseDeep( char* p, bool processEntities, int* curLineNumPtr );
-
-    mutable StrPair _name;
-    mutable StrPair _value;
-    int             _parseLineNum;
-    XMLAttribute*   _next;
-    MemPool*        _memPool;
-};
-
-
-/** The element is a container class. It has a value, the element name,
-	and can contain other elements, text, comments, and unknowns.
-	Elements also contain an arbitrary number of attributes.
-*/
-class TINYXML2_LIB XMLElement : public XMLNode
-{
-    friend class XMLDocument;
-public:
-    /// Get the name of an element (which is the Value() of the node.)
-    const char* Name() const		{
-        return Value();
-    }
-    /// Set the name of the element.
-    void SetName( const char* str, bool staticMem=false )	{
-        SetValue( str, staticMem );
-    }
-
-    virtual XMLElement* ToElement() override	{
-        return this;
-    }
-    virtual const XMLElement* ToElement() const override {
-        return this;
-    }
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    /** Given an attribute name, Attribute() returns the value
-    	for the attribute of that name, or null if none
-    	exists. For example:
-
-    	@verbatim
-    	const char* value = ele->Attribute( "foo" );
-    	@endverbatim
-
-    	The 'value' parameter is normally null. However, if specified,
-    	the attribute will only be returned if the 'name' and 'value'
-    	match. This allow you to write code:
-
-    	@verbatim
-    	if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();
-    	@endverbatim
-
-    	rather than:
-    	@verbatim
-    	if ( ele->Attribute( "foo" ) ) {
-    		if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
-    	}
-    	@endverbatim
-    */
-    const char* Attribute( const char* name, const char* value=0 ) const;
-
-    /** Given an attribute name, IntAttribute() returns the value
-    	of the attribute interpreted as an integer. The default
-        value will be returned if the attribute isn't present,
-        or if there is an error. (For a method with error
-    	checking, see QueryIntAttribute()).
-    */
-	int IntAttribute(const char* name, int defaultValue = 0) const;
-    /// See IntAttribute()
-	unsigned UnsignedAttribute(const char* name, unsigned defaultValue = 0) const;
-	/// See IntAttribute()
-	int64_t Int64Attribute(const char* name, int64_t defaultValue = 0) const;
-    /// See IntAttribute()
-    uint64_t Unsigned64Attribute(const char* name, uint64_t defaultValue = 0) const;
-	/// See IntAttribute()
-	bool BoolAttribute(const char* name, bool defaultValue = false) const;
-    /// See IntAttribute()
-	double DoubleAttribute(const char* name, double defaultValue = 0) const;
-    /// See IntAttribute()
-	float FloatAttribute(const char* name, float defaultValue = 0) const;
-
-    /** Given an attribute name, QueryIntAttribute() returns
-    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
-    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
-    	doesn't exist. If successful, the result of the conversion
-    	will be written to 'value'. If not successful, nothing will
-    	be written to 'value'. This allows you to provide default
-    	value:
-
-    	@verbatim
-    	int value = 10;
-    	QueryIntAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
-    	@endverbatim
-    */
-    XMLError QueryIntAttribute( const char* name, int* value ) const				{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryIntValue( value );
-    }
-
-	/// See QueryIntAttribute()
-    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const	{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryUnsignedValue( value );
-    }
-
-	/// See QueryIntAttribute()
-	XMLError QueryInt64Attribute(const char* name, int64_t* value) const {
-		const XMLAttribute* a = FindAttribute(name);
-		if (!a) {
-			return XML_NO_ATTRIBUTE;
-		}
-		return a->QueryInt64Value(value);
-	}
-
-    /// See QueryIntAttribute()
-    XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {
-        const XMLAttribute* a = FindAttribute(name);
-        if(!a) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryUnsigned64Value(value);
-    }
-
-	/// See QueryIntAttribute()
-    XMLError QueryBoolAttribute( const char* name, bool* value ) const				{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryBoolValue( value );
-    }
-    /// See QueryIntAttribute()
-    XMLError QueryDoubleAttribute( const char* name, double* value ) const			{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryDoubleValue( value );
-    }
-    /// See QueryIntAttribute()
-    XMLError QueryFloatAttribute( const char* name, float* value ) const			{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryFloatValue( value );
-    }
-
-	/// See QueryIntAttribute()
-	XMLError QueryStringAttribute(const char* name, const char** value) const {
-		const XMLAttribute* a = FindAttribute(name);
-		if (!a) {
-			return XML_NO_ATTRIBUTE;
-		}
-		*value = a->Value();
-		return XML_SUCCESS;
-	}
-
-
-
-    /** Given an attribute name, QueryAttribute() returns
-    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
-    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
-    	doesn't exist. It is overloaded for the primitive types,
-		and is a generally more convenient replacement of
-		QueryIntAttribute() and related functions.
-
-		If successful, the result of the conversion
-    	will be written to 'value'. If not successful, nothing will
-    	be written to 'value'. This allows you to provide default
-    	value:
-
-    	@verbatim
-    	int value = 10;
-    	QueryAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
-    	@endverbatim
-    */
-	XMLError QueryAttribute( const char* name, int* value ) const {
-		return QueryIntAttribute( name, value );
-	}
-
-	XMLError QueryAttribute( const char* name, unsigned int* value ) const {
-		return QueryUnsignedAttribute( name, value );
-	}
-
-	XMLError QueryAttribute(const char* name, int64_t* value) const {
-		return QueryInt64Attribute(name, value);
-	}
-
-    XMLError QueryAttribute(const char* name, uint64_t* value) const {
-        return QueryUnsigned64Attribute(name, value);
-    }
-
-    XMLError QueryAttribute( const char* name, bool* value ) const {
-		return QueryBoolAttribute( name, value );
-	}
-
-	XMLError QueryAttribute( const char* name, double* value ) const {
-		return QueryDoubleAttribute( name, value );
-	}
-
-	XMLError QueryAttribute( const char* name, float* value ) const {
-		return QueryFloatAttribute( name, value );
-	}
-
-	XMLError QueryAttribute(const char* name, const char** value) const {
-		return QueryStringAttribute(name, value);
-	}
-
-	/// Sets the named attribute to value.
-    void SetAttribute( const char* name, const char* value )	{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, int value )			{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, unsigned value )		{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-
-	/// Sets the named attribute to value.
-	void SetAttribute(const char* name, int64_t value) {
-		XMLAttribute* a = FindOrCreateAttribute(name);
-		a->SetAttribute(value);
-	}
-
-    /// Sets the named attribute to value.
-    void SetAttribute(const char* name, uint64_t value) {
-        XMLAttribute* a = FindOrCreateAttribute(name);
-        a->SetAttribute(value);
-    }
-
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, bool value )			{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, double value )		{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, float value )		{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-
-    /**
-    	Delete an attribute.
-    */
-    void DeleteAttribute( const char* name );
-
-    /// Return the first attribute in the list.
-    const XMLAttribute* FirstAttribute() const {
-        return _rootAttribute;
-    }
-    /// Query a specific attribute in the list.
-    const XMLAttribute* FindAttribute( const char* name ) const;
-
-    /** Convenience function for easy access to the text inside an element. Although easy
-    	and concise, GetText() is limited compared to getting the XMLText child
-    	and accessing it directly.
-
-    	If the first child of 'this' is a XMLText, the GetText()
-    	returns the character string of the Text node, else null is returned.
-
-    	This is a convenient method for getting the text of simple contained text:
-    	@verbatim
-    	<foo>This is text</foo>
-    		const char* str = fooElement->GetText();
-    	@endverbatim
-
-    	'str' will be a pointer to "This is text".
-
-    	Note that this function can be misleading. If the element foo was created from
-    	this XML:
-    	@verbatim
-    		<foo><b>This is text</b></foo>
-    	@endverbatim
-
-    	then the value of str would be null. The first child node isn't a text node, it is
-    	another element. From this XML:
-    	@verbatim
-    		<foo>This is <b>text</b></foo>
-    	@endverbatim
-    	GetText() will return "This is ".
-    */
-    const char* GetText() const;
-
-    /** Convenience function for easy access to the text inside an element. Although easy
-    	and concise, SetText() is limited compared to creating an XMLText child
-    	and mutating it directly.
-
-    	If the first child of 'this' is a XMLText, SetText() sets its value to
-		the given string, otherwise it will create a first child that is an XMLText.
-
-    	This is a convenient method for setting the text of simple contained text:
-    	@verbatim
-    	<foo>This is text</foo>
-    		fooElement->SetText( "Hullaballoo!" );
-     	<foo>Hullaballoo!</foo>
-		@endverbatim
-
-    	Note that this function can be misleading. If the element foo was created from
-    	this XML:
-    	@verbatim
-    		<foo><b>This is text</b></foo>
-    	@endverbatim
-
-    	then it will not change "This is text", but rather prefix it with a text element:
-    	@verbatim
-    		<foo>Hullaballoo!<b>This is text</b></foo>
-    	@endverbatim
-
-		For this XML:
-    	@verbatim
-    		<foo />
-    	@endverbatim
-    	SetText() will generate
-    	@verbatim
-    		<foo>Hullaballoo!</foo>
-    	@endverbatim
-    */
-	void SetText( const char* inText );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( int value );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( unsigned value );
-	/// Convenience method for setting text inside an element. See SetText() for important limitations.
-	void SetText(int64_t value);
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText(uint64_t value);
-	/// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( bool value );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( double value );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( float value );
-
-    /**
-    	Convenience method to query the value of a child text node. This is probably best
-    	shown by example. Given you have a document is this form:
-    	@verbatim
-    		<point>
-    			<x>1</x>
-    			<y>1.4</y>
-    		</point>
-    	@endverbatim
-
-    	The QueryIntText() and similar functions provide a safe and easier way to get to the
-    	"value" of x and y.
-
-    	@verbatim
-    		int x = 0;
-    		float y = 0;	// types of x and y are contrived for example
-    		const XMLElement* xElement = pointElement->FirstChildElement( "x" );
-    		const XMLElement* yElement = pointElement->FirstChildElement( "y" );
-    		xElement->QueryIntText( &x );
-    		yElement->QueryFloatText( &y );
-    	@endverbatim
-
-    	@returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted
-    			 to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.
-
-    */
-    XMLError QueryIntText( int* ival ) const;
-    /// See QueryIntText()
-    XMLError QueryUnsignedText( unsigned* uval ) const;
-	/// See QueryIntText()
-	XMLError QueryInt64Text(int64_t* uval) const;
-	/// See QueryIntText()
-	XMLError QueryUnsigned64Text(uint64_t* uval) const;
-	/// See QueryIntText()
-    XMLError QueryBoolText( bool* bval ) const;
-    /// See QueryIntText()
-    XMLError QueryDoubleText( double* dval ) const;
-    /// See QueryIntText()
-    XMLError QueryFloatText( float* fval ) const;
-
-	int IntText(int defaultValue = 0) const;
-
-	/// See QueryIntText()
-	unsigned UnsignedText(unsigned defaultValue = 0) const;
-	/// See QueryIntText()
-	int64_t Int64Text(int64_t defaultValue = 0) const;
-    /// See QueryIntText()
-    uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;
-	/// See QueryIntText()
-	bool BoolText(bool defaultValue = false) const;
-	/// See QueryIntText()
-	double DoubleText(double defaultValue = 0) const;
-	/// See QueryIntText()
-    float FloatText(float defaultValue = 0) const;
-
-    /**
-        Convenience method to create a new XMLElement and add it as last (right)
-        child of this node. Returns the created and inserted element.
-    */
-    XMLElement* InsertNewChildElement(const char* name);
-    /// See InsertNewChildElement()
-    XMLComment* InsertNewComment(const char* comment);
-    /// See InsertNewChildElement()
-    XMLText* InsertNewText(const char* text);
-    /// See InsertNewChildElement()
-    XMLDeclaration* InsertNewDeclaration(const char* text);
-    /// See InsertNewChildElement()
-    XMLUnknown* InsertNewUnknown(const char* text);
-
-
-    // internal:
-    enum ElementClosingType {
-        OPEN,		// <foo>
-        CLOSED,		// <foo/>
-        CLOSING		// </foo>
-    };
-    ElementClosingType ClosingType() const {
-        return _closingType;
-    }
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
-
-protected:
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
-
-private:
-    XMLElement( XMLDocument* doc );
-    virtual ~XMLElement();
-    XMLElement( const XMLElement& );	// not supported
-    void operator=( const XMLElement& );	// not supported
-
-    XMLAttribute* FindOrCreateAttribute( const char* name );
-    char* ParseAttributes( char* p, int* curLineNumPtr );
-    static void DeleteAttribute( XMLAttribute* attribute );
-    XMLAttribute* CreateAttribute();
-
-    enum { BUF_SIZE = 200 };
-    ElementClosingType _closingType;
-    // The attribute list is ordered; there is no 'lastAttribute'
-    // because the list needs to be scanned for dupes before adding
-    // a new attribute.
-    XMLAttribute* _rootAttribute;
-};
-
-
-enum Whitespace {
-    PRESERVE_WHITESPACE,
-    COLLAPSE_WHITESPACE,
-    PEDANTIC_WHITESPACE
-};
-
-
-/** A Document binds together all the functionality.
-	It can be saved, loaded, and printed to the screen.
-	All Nodes are connected and allocated to a Document.
-	If the Document is deleted, all its Nodes are also deleted.
-*/
-class TINYXML2_LIB XMLDocument : public XMLNode
-{
-    friend class XMLElement;
-    // Gives access to SetError and Push/PopDepth, but over-access for everything else.
-    // Wishing C++ had "internal" scope.
-    friend class XMLNode;
-    friend class XMLText;
-    friend class XMLComment;
-    friend class XMLDeclaration;
-    friend class XMLUnknown;
-public:
-    /// constructor
-    XMLDocument( bool processEntities = true, Whitespace whitespaceMode = PRESERVE_WHITESPACE );
-    ~XMLDocument();
-
-    virtual XMLDocument* ToDocument() override		{
-        TIXMLASSERT( this == _document );
-        return this;
-    }
-    virtual const XMLDocument* ToDocument() const override {
-        TIXMLASSERT( this == _document );
-        return this;
-    }
-
-    /**
-    	Parse an XML file from a character string.
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-
-    	You may optionally pass in the 'nBytes', which is
-    	the number of bytes which will be parsed. If not
-    	specified, TinyXML-2 will assume 'xml' points to a
-    	null terminated string.
-    */
-    XMLError Parse( const char* xml, size_t nBytes=static_cast<size_t>(-1) );
-
-    /**
-    	Load an XML file from disk.
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError LoadFile( const char* filename );
-
-    /**
-    	Load an XML file from disk. You are responsible
-    	for providing and closing the FILE*.
-
-        NOTE: The file should be opened as binary ("rb")
-        not text in order for TinyXML-2 to correctly
-        do newline normalization.
-
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError LoadFile( FILE* );
-
-    /**
-    	Save the XML file to disk.
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError SaveFile( const char* filename, bool compact = false );
-
-    /**
-    	Save the XML file to disk. You are responsible
-    	for providing and closing the FILE*.
-
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError SaveFile( FILE* fp, bool compact = false );
-
-    bool ProcessEntities() const		{
-        return _processEntities;
-    }
-    Whitespace WhitespaceMode() const	{
-        return _whitespaceMode;
-    }
-
-    /**
-    	Returns true if this document has a leading Byte Order Mark of UTF8.
-    */
-    bool HasBOM() const {
-        return _writeBOM;
-    }
-    /** Sets whether to write the BOM when writing the file.
-    */
-    void SetBOM( bool useBOM ) {
-        _writeBOM = useBOM;
-    }
-
-    /** Return the root element of DOM. Equivalent to FirstChildElement().
-        To get the first node, use FirstChild().
-    */
-    XMLElement* RootElement()				{
-        return FirstChildElement();
-    }
-    const XMLElement* RootElement() const	{
-        return FirstChildElement();
-    }
-
-    /** Print the Document. If the Printer is not provided, it will
-        print to stdout. If you provide Printer, this can print to a file:
-    	@verbatim
-    	XMLPrinter printer( fp );
-    	doc.Print( &printer );
-    	@endverbatim
-
-    	Or you can use a printer to print to memory:
-    	@verbatim
-    	XMLPrinter printer;
-    	doc.Print( &printer );
-    	// printer.CStr() has a const char* to the XML
-    	@endverbatim
-    */
-    void Print( XMLPrinter* streamer=0 ) const;
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    /**
-    	Create a new Element associated with
-    	this Document. The memory for the Element
-    	is managed by the Document.
-    */
-    XMLElement* NewElement( const char* name );
-    /**
-    	Create a new Comment associated with
-    	this Document. The memory for the Comment
-    	is managed by the Document.
-    */
-    XMLComment* NewComment( const char* comment );
-    /**
-    	Create a new Text associated with
-    	this Document. The memory for the Text
-    	is managed by the Document.
-    */
-    XMLText* NewText( const char* text );
-    /**
-    	Create a new Declaration associated with
-    	this Document. The memory for the object
-    	is managed by the Document.
-
-    	If the 'text' param is null, the standard
-    	declaration is used.:
-    	@verbatim
-    		<?xml version="1.0" encoding="UTF-8"?>
-    	@endverbatim
-    */
-    XMLDeclaration* NewDeclaration( const char* text=0 );
-    /**
-    	Create a new Unknown associated with
-    	this Document. The memory for the object
-    	is managed by the Document.
-    */
-    XMLUnknown* NewUnknown( const char* text );
-
-    /**
-    	Delete a node associated with this document.
-    	It will be unlinked from the DOM.
-    */
-    void DeleteNode( XMLNode* node );
-
-    /// Clears the error flags.
-    void ClearError();
-
-    /// Return true if there was an error parsing the document.
-    bool Error() const {
-        return _errorID != XML_SUCCESS;
-    }
-    /// Return the errorID.
-    XMLError  ErrorID() const {
-        return _errorID;
-    }
-	const char* ErrorName() const;
-    static const char* ErrorIDToName(XMLError errorID);
-
-    /** Returns a "long form" error description. A hopefully helpful
-        diagnostic with location, line number, and/or additional info.
-    */
-	const char* ErrorStr() const;
-
-    /// A (trivial) utility function that prints the ErrorStr() to stdout.
-    void PrintError() const;
-
-    /// Return the line where the error occurred, or zero if unknown.
-    int ErrorLineNum() const
-    {
-        return _errorLineNum;
-    }
-
-    /// Clear the document, resetting it to the initial state.
-    void Clear();
-
-	/**
-		Copies this document to a target document.
-		The target will be completely cleared before the copy.
-		If you want to copy a sub-tree, see XMLNode::DeepClone().
-
-		NOTE: that the 'target' must be non-null.
-	*/
-	void DeepCopy(XMLDocument* target) const;
-
-	// internal
-    char* Identify( char* p, XMLNode** node, bool first );
-
-	// internal
-	void MarkInUse(const XMLNode* const);
-
-    virtual XMLNode* ShallowClone( XMLDocument* /*document*/ ) const override{
-        return 0;
-    }
-    virtual bool ShallowEqual( const XMLNode* /*compare*/ ) const override{
-        return false;
-    }
-
-private:
-    XMLDocument( const XMLDocument& );	// not supported
-    void operator=( const XMLDocument& );	// not supported
-
-    bool			_writeBOM;
-    bool			_processEntities;
-    XMLError		_errorID;
-    Whitespace		_whitespaceMode;
-    mutable StrPair	_errorStr;
-    int             _errorLineNum;
-    char*			_charBuffer;
-    int				_parseCurLineNum;
-	int				_parsingDepth;
-	// Memory tracking does add some overhead.
-	// However, the code assumes that you don't
-	// have a bunch of unlinked nodes around.
-	// Therefore it takes less memory to track
-	// in the document vs. a linked list in the XMLNode,
-	// and the performance is the same.
-	DynArray<XMLNode*, 10> _unlinked;
-
-    MemPoolT< sizeof(XMLElement) >	 _elementPool;
-    MemPoolT< sizeof(XMLAttribute) > _attributePool;
-    MemPoolT< sizeof(XMLText) >		 _textPool;
-    MemPoolT< sizeof(XMLComment) >	 _commentPool;
-
-	static const char* _errorNames[XML_ERROR_COUNT];
-
-    void Parse();
-
-    void SetError( XMLError error, int lineNum, const char* format, ... );
-
-	// Something of an obvious security hole, once it was discovered.
-	// Either an ill-formed XML or an excessively deep one can overflow
-	// the stack. Track stack depth, and error out if needed.
-	class DepthTracker {
-	public:
-		explicit DepthTracker(XMLDocument * document) {
-			this->_document = document;
-			document->PushDepth();
-		}
-		~DepthTracker() {
-			_document->PopDepth();
-		}
-	private:
-		XMLDocument * _document;
-	};
-	void PushDepth();
-	void PopDepth();
-
-    template<class NodeType, size_t PoolElementSize>
-    NodeType* CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool );
-};
-
-template<class NodeType, size_t PoolElementSize>
-inline NodeType* XMLDocument::CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool )
-{
-    TIXMLASSERT( sizeof( NodeType ) == PoolElementSize );
-    TIXMLASSERT( sizeof( NodeType ) == pool.ItemSize() );
-    NodeType* returnNode = new (pool.Alloc()) NodeType( this );
-    TIXMLASSERT( returnNode );
-    returnNode->_memPool = &pool;
-
-	_unlinked.Push(returnNode);
-    return returnNode;
-}
-
-/**
-	A XMLHandle is a class that wraps a node pointer with null checks; this is
-	an incredibly useful thing. Note that XMLHandle is not part of the TinyXML-2
-	DOM structure. It is a separate utility class.
-
-	Take an example:
-	@verbatim
-	<Document>
-		<Element attributeA = "valueA">
-			<Child attributeB = "value1" />
-			<Child attributeB = "value2" />
-		</Element>
-	</Document>
-	@endverbatim
-
-	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
-	easy to write a *lot* of code that looks like:
-
-	@verbatim
-	XMLElement* root = document.FirstChildElement( "Document" );
-	if ( root )
-	{
-		XMLElement* element = root->FirstChildElement( "Element" );
-		if ( element )
-		{
-			XMLElement* child = element->FirstChildElement( "Child" );
-			if ( child )
-			{
-				XMLElement* child2 = child->NextSiblingElement( "Child" );
-				if ( child2 )
-				{
-					// Finally do something useful.
-	@endverbatim
-
-	And that doesn't even cover "else" cases. XMLHandle addresses the verbosity
-	of such code. A XMLHandle checks for null pointers so it is perfectly safe
-	and correct to use:
-
-	@verbatim
-	XMLHandle docHandle( &document );
-	XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();
-	if ( child2 )
-	{
-		// do something useful
-	@endverbatim
-
-	Which is MUCH more concise and useful.
-
-	It is also safe to copy handles - internally they are nothing more than node pointers.
-	@verbatim
-	XMLHandle handleCopy = handle;
-	@endverbatim
-
-	See also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.
-*/
-class TINYXML2_LIB XMLHandle
-{
-public:
-    /// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
-    explicit XMLHandle( XMLNode* node ) : _node( node ) {
-    }
-    /// Create a handle from a node.
-    explicit XMLHandle( XMLNode& node ) : _node( &node ) {
-    }
-    /// Copy constructor
-    XMLHandle( const XMLHandle& ref ) : _node( ref._node ) {
-    }
-    /// Assignment
-    XMLHandle& operator=( const XMLHandle& ref )							{
-        _node = ref._node;
-        return *this;
-    }
-
-    /// Get the first child of this handle.
-    XMLHandle FirstChild() 													{
-        return XMLHandle( _node ? _node->FirstChild() : 0 );
-    }
-    /// Get the first child element of this handle.
-    XMLHandle FirstChildElement( const char* name = 0 )						{
-        return XMLHandle( _node ? _node->FirstChildElement( name ) : 0 );
-    }
-    /// Get the last child of this handle.
-    XMLHandle LastChild()													{
-        return XMLHandle( _node ? _node->LastChild() : 0 );
-    }
-    /// Get the last child element of this handle.
-    XMLHandle LastChildElement( const char* name = 0 )						{
-        return XMLHandle( _node ? _node->LastChildElement( name ) : 0 );
-    }
-    /// Get the previous sibling of this handle.
-    XMLHandle PreviousSibling()												{
-        return XMLHandle( _node ? _node->PreviousSibling() : 0 );
-    }
-    /// Get the previous sibling element of this handle.
-    XMLHandle PreviousSiblingElement( const char* name = 0 )				{
-        return XMLHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
-    }
-    /// Get the next sibling of this handle.
-    XMLHandle NextSibling()													{
-        return XMLHandle( _node ? _node->NextSibling() : 0 );
-    }
-    /// Get the next sibling element of this handle.
-    XMLHandle NextSiblingElement( const char* name = 0 )					{
-        return XMLHandle( _node ? _node->NextSiblingElement( name ) : 0 );
-    }
-
-    /// Safe cast to XMLNode. This can return null.
-    XMLNode* ToNode()							{
-        return _node;
-    }
-    /// Safe cast to XMLElement. This can return null.
-    XMLElement* ToElement() 					{
-        return ( _node ? _node->ToElement() : 0 );
-    }
-    /// Safe cast to XMLText. This can return null.
-    XMLText* ToText() 							{
-        return ( _node ? _node->ToText() : 0 );
-    }
-    /// Safe cast to XMLUnknown. This can return null.
-    XMLUnknown* ToUnknown() 					{
-        return ( _node ? _node->ToUnknown() : 0 );
-    }
-    /// Safe cast to XMLDeclaration. This can return null.
-    XMLDeclaration* ToDeclaration() 			{
-        return ( _node ? _node->ToDeclaration() : 0 );
-    }
-
-private:
-    XMLNode* _node;
-};
-
-
-/**
-	A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
-	same in all regards, except for the 'const' qualifiers. See XMLHandle for API.
-*/
-class TINYXML2_LIB XMLConstHandle
-{
-public:
-    explicit XMLConstHandle( const XMLNode* node ) : _node( node ) {
-    }
-    explicit XMLConstHandle( const XMLNode& node ) : _node( &node ) {
-    }
-    XMLConstHandle( const XMLConstHandle& ref ) : _node( ref._node ) {
-    }
-
-    XMLConstHandle& operator=( const XMLConstHandle& ref )							{
-        _node = ref._node;
-        return *this;
-    }
-
-    const XMLConstHandle FirstChild() const											{
-        return XMLConstHandle( _node ? _node->FirstChild() : 0 );
-    }
-    const XMLConstHandle FirstChildElement( const char* name = 0 ) const				{
-        return XMLConstHandle( _node ? _node->FirstChildElement( name ) : 0 );
-    }
-    const XMLConstHandle LastChild()	const										{
-        return XMLConstHandle( _node ? _node->LastChild() : 0 );
-    }
-    const XMLConstHandle LastChildElement( const char* name = 0 ) const				{
-        return XMLConstHandle( _node ? _node->LastChildElement( name ) : 0 );
-    }
-    const XMLConstHandle PreviousSibling() const									{
-        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );
-    }
-    const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const		{
-        return XMLConstHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
-    }
-    const XMLConstHandle NextSibling() const										{
-        return XMLConstHandle( _node ? _node->NextSibling() : 0 );
-    }
-    const XMLConstHandle NextSiblingElement( const char* name = 0 ) const			{
-        return XMLConstHandle( _node ? _node->NextSiblingElement( name ) : 0 );
-    }
-
-
-    const XMLNode* ToNode() const				{
-        return _node;
-    }
-    const XMLElement* ToElement() const			{
-        return ( _node ? _node->ToElement() : 0 );
-    }
-    const XMLText* ToText() const				{
-        return ( _node ? _node->ToText() : 0 );
-    }
-    const XMLUnknown* ToUnknown() const			{
-        return ( _node ? _node->ToUnknown() : 0 );
-    }
-    const XMLDeclaration* ToDeclaration() const	{
-        return ( _node ? _node->ToDeclaration() : 0 );
-    }
-
-private:
-    const XMLNode* _node;
-};
-
-
-/**
-	Printing functionality. The XMLPrinter gives you more
-	options than the XMLDocument::Print() method.
-
-	It can:
-	-# Print to memory.
-	-# Print to a file you provide.
-	-# Print XML without a XMLDocument.
-
-	Print to Memory
-
-	@verbatim
-	XMLPrinter printer;
-	doc.Print( &printer );
-	SomeFunction( printer.CStr() );
-	@endverbatim
-
-	Print to a File
-
-	You provide the file pointer.
-	@verbatim
-	XMLPrinter printer( fp );
-	doc.Print( &printer );
-	@endverbatim
-
-	Print without a XMLDocument
-
-	When loading, an XML parser is very useful. However, sometimes
-	when saving, it just gets in the way. The code is often set up
-	for streaming, and constructing the DOM is just overhead.
-
-	The Printer supports the streaming case. The following code
-	prints out a trivially simple XML file without ever creating
-	an XML document.
-
-	@verbatim
-	XMLPrinter printer( fp );
-	printer.OpenElement( "foo" );
-	printer.PushAttribute( "foo", "bar" );
-	printer.CloseElement();
-	@endverbatim
-*/
-class TINYXML2_LIB XMLPrinter : public XMLVisitor
-{
-public:
-    /** Construct the printer. If the FILE* is specified,
-    	this will print to the FILE. Else it will print
-    	to memory, and the result is available in CStr().
-    	If 'compact' is set to true, then output is created
-    	with only required whitespace and newlines.
-    */
-    XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 );
-    virtual ~XMLPrinter()	{}
-
-    /** If streaming, write the BOM and declaration. */
-    void PushHeader( bool writeBOM, bool writeDeclaration );
-    /** If streaming, start writing an element.
-        The element must be closed with CloseElement()
-    */
-    void OpenElement( const char* name, bool compactMode=false );
-    /// If streaming, add an attribute to an open element.
-    void PushAttribute( const char* name, const char* value );
-    void PushAttribute( const char* name, int value );
-    void PushAttribute( const char* name, unsigned value );
-	void PushAttribute( const char* name, int64_t value );
-	void PushAttribute( const char* name, uint64_t value );
-	void PushAttribute( const char* name, bool value );
-    void PushAttribute( const char* name, double value );
-    /// If streaming, close the Element.
-    virtual void CloseElement( bool compactMode=false );
-
-    /// Add a text node.
-    void PushText( const char* text, bool cdata=false );
-    /// Add a text node from an integer.
-    void PushText( int value );
-    /// Add a text node from an unsigned.
-    void PushText( unsigned value );
-	/// Add a text node from a signed 64bit integer.
-	void PushText( int64_t value );
-	/// Add a text node from an unsigned 64bit integer.
-	void PushText( uint64_t value );
-	/// Add a text node from a bool.
-    void PushText( bool value );
-    /// Add a text node from a float.
-    void PushText( float value );
-    /// Add a text node from a double.
-    void PushText( double value );
-
-    /// Add a comment
-    void PushComment( const char* comment );
-
-    void PushDeclaration( const char* value );
-    void PushUnknown( const char* value );
-
-    virtual bool VisitEnter( const XMLDocument& /*doc*/ ) override;
-    virtual bool VisitExit( const XMLDocument& /*doc*/ ) override	{
-        return true;
-    }
-
-    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute ) override;
-    virtual bool VisitExit( const XMLElement& element ) override;
-
-    virtual bool Visit( const XMLText& text ) override;
-    virtual bool Visit( const XMLComment& comment ) override;
-    virtual bool Visit( const XMLDeclaration& declaration ) override;
-    virtual bool Visit( const XMLUnknown& unknown ) override;
-
-    /**
-    	If in print to memory mode, return a pointer to
-    	the XML file in memory.
-    */
-    const char* CStr() const {
-        return _buffer.Mem();
-    }
-    /**
-    	If in print to memory mode, return the size
-    	of the XML file in memory. (Note the size returned
-    	includes the terminating null.)
-    */
-    size_t CStrSize() const {
-        return _buffer.Size();
-    }
-    /**
-    	If in print to memory mode, reset the buffer to the
-    	beginning.
-    */
-    void ClearBuffer( bool resetToFirstElement = true ) {
-        _buffer.Clear();
-        _buffer.Push(0);
-		_firstElement = resetToFirstElement;
-    }
-
-protected:
-	virtual bool CompactMode( const XMLElement& )	{ return _compactMode; }
-
-	/** Prints out the space before an element. You may override to change
-	    the space and tabs used. A PrintSpace() override should call Print().
-	*/
-    virtual void PrintSpace( int depth );
-    virtual void Print( const char* format, ... );
-    virtual void Write( const char* data, size_t size );
-    virtual void Putc( char ch );
-
-    inline void Write(const char* data) { Write(data, strlen(data)); }
-
-    void SealElementIfJustOpened();
-    bool _elementJustOpened;
-    DynArray< const char*, 10 > _stack;
-
-private:
-    /**
-       Prepares to write a new node. This includes sealing an element that was
-       just opened, and writing any whitespace necessary if not in compact mode.
-     */
-    void PrepareForNewNode( bool compactMode );
-    void PrintString( const char*, bool restrictedEntitySet );	// prints out, after detecting entities.
-
-    bool _firstElement;
-    FILE* _fp;
-    int _depth;
-    int _textDepth;
-    bool _processEntities;
-	bool _compactMode;
-
-    enum {
-        ENTITY_RANGE = 64,
-        BUF_SIZE = 200
-    };
-    bool _entityFlag[ENTITY_RANGE];
-    bool _restrictedEntityFlag[ENTITY_RANGE];
-
-    DynArray< char, 20 > _buffer;
-
-    // Prohibit cloning, intentionally not implemented
-    XMLPrinter( const XMLPrinter& );
-    XMLPrinter& operator=( const XMLPrinter& );
-};
-
-
-} // namespace tinyxml2
+}  // namespace tinyxml2
 
 #if defined(_MSC_VER)
-#   pragma warning(pop)
+#pragma warning(pop)
 #endif
 
-#endif // TINYXML2_INCLUDED
+#endif  // TINYXML2_INCLUDED
 
tests/mechanical_layer/include/Agent.h
====================
--- original

+++ formatted

@@ -1,46 +1,51 @@

 #ifndef AGENT_H
 #define AGENT_H
 
+#include <utility>
+
 #include "Globals.h"
-#include <utility>
 
 struct Agent
 /**
  * @brief Class representing an agent in the simulation.
  *
- * This class defines the properties and behaviors of an agent, such as its position, velocity, and shape.
- * Agents can interact with each other and navigate through the environment based on a driving force.
+ * This class defines the properties and behaviors of an agent, such as its
+ * position, velocity, and shape. Agents can interact with each other and
+ * navigate through the environment based on a driving force.
  */
 {
-    const unsigned _id;                         //  agent id
-    const double _mass;                         //  mass
-    const double _moi;                          //  moment of inertia
-    const std::vector<unsigned> _ids_shapes;    //  list of ids of the shapes of the agent
-    const double _radius;                       //  equivalent radius for repulsive force
-    const unsigned _nb_shapes;
-    std::vector<double2> _delta_gtos;           // list of vector from the center of mass G to the center of each physical shape (disc),
-    /*  For composite agents, remember that the positions and velocities given here
-        refer to the centre of mass of the composite agent  */
-    const std::vector<double> _radius_shapes;
-    const double _theta_init;
-    double _x, _y, _theta, _vx, _vy, _w;
-    double _vx_des, _vy_des, _w_des, _theta_des;
-    double2 _v_des;
-    std::list<unsigned> _neighbours;
-    std::list<std::pair<unsigned, unsigned>> _neighbours_walls;
+  const unsigned _id;  //  agent id
+  const double _mass;  //  mass
+  const double _moi;   //  moment of inertia
+  const std::vector<unsigned>
+      _ids_shapes;       //  list of ids of the shapes of the agent
+  const double _radius;  //  equivalent radius for repulsive force
+  const unsigned _nb_shapes;
+  std::vector<double2>
+      _delta_gtos;  // list of vector from the center of mass G to the center of
+                    // each physical shape (disc),
+  /*  For composite agents, remember that the positions and velocities given
+     here refer to the centre of mass of the composite agent  */
+  const std::vector<double> _radius_shapes;
+  const double _theta_init;
+  double _x, _y, _theta, _vx, _vy, _w;
+  double _vx_des, _vy_des, _w_des, _theta_des;
+  double2 _v_des;
+  std::list<unsigned> _neighbours;
+  std::list<std::pair<unsigned, unsigned>> _neighbours_walls;
 
-    /*  Constructor for the class   */
-    Agent(unsigned ID, std::vector<unsigned> Ids_shapes, double x, double y, double vx, double vy, double omega,
-          double2 Fp, double Mp, unsigned nb_shapes, const std::vector<double2>& delta_gtos,
-          const std::vector<double>& radius_shapes, double theta_body, double theta_body_init,
-          double mass, double moi);
-    ~Agent();
+  /*  Constructor for the class   */
+  Agent(unsigned ID, std::vector<unsigned> Ids_shapes, double x, double y,
+        double vx, double vy, double omega, double2 Fp, double Mp,
+        unsigned nb_shapes, const std::vector<double2>& delta_gtos,
+        const std::vector<double>& radius_shapes, double theta_body,
+        double theta_body_init, double mass, double moi);
+  ~Agent();
 
-    void move();
-    inline double2 get_r() { return {_x, _y}; }
-    inline double2 get_v() { return {_vx, _vy}; }
-    std::vector<double2> get_delta_gtos();
+  void move();
+  inline double2 get_r() { return {_x, _y}; }
+  inline double2 get_v() { return {_vx, _vy}; }
+  std::vector<double2> get_delta_gtos();
 };
 
-
-#endif  /*  AGENT_H */
+#endif /*  AGENT_H */
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp
====================
--- original

+++ formatted

@@ -23,104 +23,107 @@

 
 #include "tinyxml2.h"
 
-#include <new>		// yes, this one new style header, is in the Android SDK.
-#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__) || defined(__CC_ARM)
-#   include <stddef.h>
-#   include <stdarg.h>
+#include <new>  // yes, this one new style header, is in the Android SDK.
+#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__) || \
+    defined(__CC_ARM)
+#include <stdarg.h>
+#include <stddef.h>
 #else
-#   include <cstddef>
-#   include <cstdarg>
+#include <cstdarg>
+#include <cstddef>
 #endif
 
-#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
-	// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
-	/*int _snprintf_s(
-	   char *buffer,
-	   size_t sizeOfBuffer,
-	   size_t count,
-	   const char *format [,
-		  argument] ...
-	);*/
-	static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )
-	{
-		va_list va;
-		va_start( va, format );
-		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
-		va_end( va );
-		return result;
-	}
-
-	static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )
-	{
-		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
-		return result;
-	}
-
-	#define TIXML_VSCPRINTF	_vscprintf
-	#define TIXML_SSCANF	sscanf_s
+#if defined(_MSC_VER) && (_MSC_VER >= 1400) && (!defined WINCE)
+// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
+/*int _snprintf_s(
+   char *buffer,
+   size_t sizeOfBuffer,
+   size_t count,
+   const char *format [,
+          argument] ...
+);*/
+static inline int TIXML_SNPRINTF(char* buffer, size_t size, const char* format,
+                                 ...) {
+  va_list va;
+  va_start(va, format);
+  const int result = vsnprintf_s(buffer, size, _TRUNCATE, format, va);
+  va_end(va);
+  return result;
+}
+
+static inline int TIXML_VSNPRINTF(char* buffer, size_t size, const char* format,
+                                  va_list va) {
+  const int result = vsnprintf_s(buffer, size, _TRUNCATE, format, va);
+  return result;
+}
+
+#define TIXML_VSCPRINTF _vscprintf
+#define TIXML_SSCANF sscanf_s
 #elif defined _MSC_VER
-	// Microsoft Visual Studio 2003 and earlier or WinCE
-	#define TIXML_SNPRINTF	_snprintf
-	#define TIXML_VSNPRINTF _vsnprintf
-	#define TIXML_SSCANF	sscanf
-	#if (_MSC_VER < 1400 ) && (!defined WINCE)
-		// Microsoft Visual Studio 2003 and not WinCE.
-		#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.
-	#else
-		// Microsoft Visual Studio 2003 and earlier or WinCE.
-		static inline int TIXML_VSCPRINTF( const char* format, va_list va )
-		{
-			int len = 512;
-			for (;;) {
-				len = len*2;
-				char* str = new char[len]();
-				const int required = _vsnprintf(str, len, format, va);
-				delete[] str;
-				if ( required != -1 ) {
-					TIXMLASSERT( required >= 0 );
-					len = required;
-					break;
-				}
-			}
-			TIXMLASSERT( len >= 0 );
-			return len;
-		}
-	#endif
+// Microsoft Visual Studio 2003 and earlier or WinCE
+#define TIXML_SNPRINTF _snprintf
+#define TIXML_VSNPRINTF _vsnprintf
+#define TIXML_SSCANF sscanf
+#if (_MSC_VER < 1400) && (!defined WINCE)
+// Microsoft Visual Studio 2003 and not WinCE.
+#define TIXML_VSCPRINTF \
+  _vscprintf  // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK
+              // doesn't have.
 #else
-	// GCC version 3 and higher
-	//#warning( "Using sn* functions." )
-	#define TIXML_SNPRINTF	snprintf
-	#define TIXML_VSNPRINTF	vsnprintf
-	static inline int TIXML_VSCPRINTF( const char* format, va_list va )
-	{
-		int len = vsnprintf( 0, 0, format, va );
-		TIXMLASSERT( len >= 0 );
-		return len;
-	}
-	#define TIXML_SSCANF   sscanf
+// Microsoft Visual Studio 2003 and earlier or WinCE.
+static inline int TIXML_VSCPRINTF(const char* format, va_list va) {
+  int len = 512;
+  for (;;) {
+    len = len * 2;
+    char* str = new char[len]();
+    const int required = _vsnprintf(str, len, format, va);
+    delete[] str;
+    if (required != -1) {
+      TIXMLASSERT(required >= 0);
+      len = required;
+      break;
+    }
+  }
+  TIXMLASSERT(len >= 0);
+  return len;
+}
 #endif
+#else
+// GCC version 3 and higher
+// #warning( "Using sn* functions." )
+#define TIXML_SNPRINTF snprintf
+#define TIXML_VSNPRINTF vsnprintf
+static inline int TIXML_VSCPRINTF(const char* format, va_list va) {
+  int len = vsnprintf(0, 0, format, va);
+  TIXMLASSERT(len >= 0);
+  return len;
+}
+#define TIXML_SSCANF sscanf
+#endif
 
 #if defined(_WIN64)
-	#define TIXML_FSEEK _fseeki64
-	#define TIXML_FTELL _ftelli64
-#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)
-	#define TIXML_FSEEK fseeko
-	#define TIXML_FTELL ftello
+#define TIXML_FSEEK _fseeki64
+#define TIXML_FTELL _ftelli64
+#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || \
+    defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)
+#define TIXML_FSEEK fseeko
+#define TIXML_FTELL ftello
 #elif defined(__ANDROID__) && __ANDROID_API__ > 24
-	#define TIXML_FSEEK fseeko64
-	#define TIXML_FTELL ftello64
+#define TIXML_FSEEK fseeko64
+#define TIXML_FTELL ftello64
 #else
-	#define TIXML_FSEEK fseek
-	#define TIXML_FTELL ftell
+#define TIXML_FSEEK fseek
+#define TIXML_FTELL ftell
 #endif
 
-
-static const char LINE_FEED				= static_cast<char>(0x0a);			// all line endings are normalized to LF
+static const char LINE_FEED =
+    static_cast<char>(0x0a);  // all line endings are normalized to LF
 static const char LF = LINE_FEED;
-static const char CARRIAGE_RETURN		= static_cast<char>(0x0d);			// CR gets filtered out
+static const char CARRIAGE_RETURN =
+    static_cast<char>(0x0d);  // CR gets filtered out
 static const char CR = CARRIAGE_RETURN;
-static const char SINGLE_QUOTE			= '\'';
-static const char DOUBLE_QUOTE			= '\"';
+static const char SINGLE_QUOTE = '\'';
+static const char DOUBLE_QUOTE = '\"';
 
 // Bunch of unicode info at:
 //		http://www.unicode.org/faq/utf_bom.html
@@ -130,2029 +133,1773 @@

 static const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
 static const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
 
-namespace tinyxml2
-{
+namespace tinyxml2 {
 
 struct Entity {
-    const char* pattern;
-    int length;
-    char value;
+  const char* pattern;
+  int length;
+  char value;
 };
 
 static const int NUM_ENTITIES = 5;
-static const Entity entities[NUM_ENTITIES] = {
-    { "quot", 4,	DOUBLE_QUOTE },
-    { "amp", 3,		'&'  },
-    { "apos", 4,	SINGLE_QUOTE },
-    { "lt",	2, 		'<'	 },
-    { "gt",	2,		'>'	 }
-};
-
-
-StrPair::~StrPair()
-{
-    Reset();
-}
-
-
-void StrPair::TransferTo( StrPair* other )
-{
-    if ( this == other ) {
-        return;
-    }
-    // This in effect implements the assignment operator by "moving"
-    // ownership (as in auto_ptr).
-
-    TIXMLASSERT( other != 0 );
-    TIXMLASSERT( other->_flags == 0 );
-    TIXMLASSERT( other->_start == 0 );
-    TIXMLASSERT( other->_end == 0 );
-
-    other->Reset();
-
-    other->_flags = _flags;
-    other->_start = _start;
-    other->_end = _end;
-
-    _flags = 0;
-    _start = 0;
-    _end = 0;
-}
-
-
-void StrPair::Reset()
-{
-    if ( _flags & NEEDS_DELETE ) {
-        delete [] _start;
-    }
-    _flags = 0;
-    _start = 0;
-    _end = 0;
-}
-
-
-void StrPair::SetStr( const char* str, int flags )
-{
-    TIXMLASSERT( str );
-    Reset();
-    size_t len = strlen( str );
-    TIXMLASSERT( _start == 0 );
-    _start = new char[ len+1 ];
-    memcpy( _start, str, len+1 );
-    _end = _start + len;
-    _flags = flags | NEEDS_DELETE;
-}
-
-
-char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )
-{
-    TIXMLASSERT( p );
-    TIXMLASSERT( endTag && *endTag );
-	TIXMLASSERT(curLineNumPtr);
-
-    char* start = p;
-    const char  endChar = *endTag;
-    size_t length = strlen( endTag );
-
-    // Inner loop of text parsing.
-    while ( *p ) {
-        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {
-            Set( start, p, strFlags );
-            return p + length;
-        } else if (*p == '\n') {
-            ++(*curLineNumPtr);
+static const Entity entities[NUM_ENTITIES] = {{"quot", 4, DOUBLE_QUOTE},
+                                              {"amp", 3, '&'},
+                                              {"apos", 4, SINGLE_QUOTE},
+                                              {"lt", 2, '<'},
+                                              {"gt", 2, '>'}};
+
+StrPair::~StrPair() { Reset(); }
+
+void StrPair::TransferTo(StrPair* other) {
+  if (this == other) {
+    return;
+  }
+  // This in effect implements the assignment operator by "moving"
+  // ownership (as in auto_ptr).
+
+  TIXMLASSERT(other != 0);
+  TIXMLASSERT(other->_flags == 0);
+  TIXMLASSERT(other->_start == 0);
+  TIXMLASSERT(other->_end == 0);
+
+  other->Reset();
+
+  other->_flags = _flags;
+  other->_start = _start;
+  other->_end = _end;
+
+  _flags = 0;
+  _start = 0;
+  _end = 0;
+}
+
+void StrPair::Reset() {
+  if (_flags & NEEDS_DELETE) {
+    delete[] _start;
+  }
+  _flags = 0;
+  _start = 0;
+  _end = 0;
+}
+
+void StrPair::SetStr(const char* str, int flags) {
+  TIXMLASSERT(str);
+  Reset();
+  size_t len = strlen(str);
+  TIXMLASSERT(_start == 0);
+  _start = new char[len + 1];
+  memcpy(_start, str, len + 1);
+  _end = _start + len;
+  _flags = flags | NEEDS_DELETE;
+}
+
+char* StrPair::ParseText(char* p, const char* endTag, int strFlags,
+                         int* curLineNumPtr) {
+  TIXMLASSERT(p);
+  TIXMLASSERT(endTag && *endTag);
+  TIXMLASSERT(curLineNumPtr);
+
+  char* start = p;
+  const char endChar = *endTag;
+  size_t length = strlen(endTag);
+
+  // Inner loop of text parsing.
+  while (*p) {
+    if (*p == endChar && strncmp(p, endTag, length) == 0) {
+      Set(start, p, strFlags);
+      return p + length;
+    } else if (*p == '\n') {
+      ++(*curLineNumPtr);
+    }
+    ++p;
+    TIXMLASSERT(p);
+  }
+  return 0;
+}
+
+char* StrPair::ParseName(char* p) {
+  if (!p || !(*p)) {
+    return 0;
+  }
+  if (!XMLUtil::IsNameStartChar(static_cast<unsigned char>(*p))) {
+    return 0;
+  }
+
+  char* const start = p;
+  ++p;
+  while (*p && XMLUtil::IsNameChar(static_cast<unsigned char>(*p))) {
+    ++p;
+  }
+
+  Set(start, p, 0);
+  return p;
+}
+
+void StrPair::CollapseWhitespace() {
+  // Adjusting _start would cause undefined behavior on delete[]
+  TIXMLASSERT((_flags & NEEDS_DELETE) == 0);
+  // Trim leading space.
+  _start = XMLUtil::SkipWhiteSpace(_start, 0);
+
+  if (*_start) {
+    const char* p = _start;  // the read pointer
+    char* q = _start;        // the write pointer
+
+    while (*p) {
+      if (XMLUtil::IsWhiteSpace(*p)) {
+        p = XMLUtil::SkipWhiteSpace(p, 0);
+        if (*p == 0) {
+          break;  // don't write to q; this trims the trailing space.
         }
-        ++p;
-        TIXMLASSERT( p );
-    }
+        *q = ' ';
+        ++q;
+      }
+      *q = *p;
+      ++q;
+      ++p;
+    }
+    *q = 0;
+  }
+}
+
+const char* StrPair::GetStr() {
+  TIXMLASSERT(_start);
+  TIXMLASSERT(_end);
+  if (_flags & NEEDS_FLUSH) {
+    *_end = 0;
+    _flags ^= NEEDS_FLUSH;
+
+    if (_flags) {
+      const char* p = _start;  // the read pointer
+      char* q = _start;        // the write pointer
+
+      while (p < _end) {
+        if ((_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR) {
+          // CR-LF pair becomes LF
+          // CR alone becomes LF
+          // LF-CR becomes LF
+          if (*(p + 1) == LF) {
+            p += 2;
+          } else {
+            ++p;
+          }
+          *q = LF;
+          ++q;
+        } else if ((_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF) {
+          if (*(p + 1) == CR) {
+            p += 2;
+          } else {
+            ++p;
+          }
+          *q = LF;
+          ++q;
+        } else if ((_flags & NEEDS_ENTITY_PROCESSING) && *p == '&') {
+          // Entities handled by tinyXML2:
+          // - special entities in the entity table [in/out]
+          // - numeric character reference [in]
+          //   &#20013; or &#x4e2d;
+
+          if (*(p + 1) == '#') {
+            const int buflen = 10;
+            char buf[buflen] = {0};
+            int len = 0;
+            const char* adjusted =
+                const_cast<char*>(XMLUtil::GetCharacterRef(p, buf, &len));
+            if (adjusted == 0) {
+              *q = *p;
+              ++p;
+              ++q;
+            } else {
+              TIXMLASSERT(0 <= len && len <= buflen);
+              TIXMLASSERT(q + len <= adjusted);
+              p = adjusted;
+              memcpy(q, buf, len);
+              q += len;
+            }
+          } else {
+            bool entityFound = false;
+            for (int i = 0; i < NUM_ENTITIES; ++i) {
+              const Entity& entity = entities[i];
+              if (strncmp(p + 1, entity.pattern, entity.length) == 0 &&
+                  *(p + entity.length + 1) == ';') {
+                // Found an entity - convert.
+                *q = entity.value;
+                ++q;
+                p += entity.length + 2;
+                entityFound = true;
+                break;
+              }
+            }
+            if (!entityFound) {
+              // fixme: treat as error?
+              ++p;
+              ++q;
+            }
+          }
+        } else {
+          *q = *p;
+          ++p;
+          ++q;
+        }
+      }
+      *q = 0;
+    }
+    // The loop below has plenty going on, and this
+    // is a less useful mode. Break it out.
+    if (_flags & NEEDS_WHITESPACE_COLLAPSING) {
+      CollapseWhitespace();
+    }
+    _flags = (_flags & NEEDS_DELETE);
+  }
+  TIXMLASSERT(_start);
+  return _start;
+}
+
+// --------- XMLUtil ----------- //
+
+const char* XMLUtil::writeBoolTrue = "true";
+const char* XMLUtil::writeBoolFalse = "false";
+
+void XMLUtil::SetBoolSerialization(const char* writeTrue,
+                                   const char* writeFalse) {
+  static const char* defTrue = "true";
+  static const char* defFalse = "false";
+
+  writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
+  writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
+}
+
+const char* XMLUtil::ReadBOM(const char* p, bool* bom) {
+  TIXMLASSERT(p);
+  TIXMLASSERT(bom);
+  *bom = false;
+  const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
+  // Check for BOM:
+  if (*(pu + 0) == TIXML_UTF_LEAD_0 && *(pu + 1) == TIXML_UTF_LEAD_1 &&
+      *(pu + 2) == TIXML_UTF_LEAD_2) {
+    *bom = true;
+    p += 3;
+  }
+  TIXMLASSERT(p);
+  return p;
+}
+
+void XMLUtil::ConvertUTF32ToUTF8(unsigned long input, char* output,
+                                 int* length) {
+  const unsigned long BYTE_MASK = 0xBF;
+  const unsigned long BYTE_MARK = 0x80;
+  const unsigned long FIRST_BYTE_MARK[7] = {0x00, 0x00, 0xC0, 0xE0,
+                                            0xF0, 0xF8, 0xFC};
+
+  if (input < 0x80) {
+    *length = 1;
+  } else if (input < 0x800) {
+    *length = 2;
+  } else if (input < 0x10000) {
+    *length = 3;
+  } else if (input < 0x200000) {
+    *length = 4;
+  } else {
+    *length = 0;  // This code won't convert this correctly anyway.
+    return;
+  }
+
+  output += *length;
+
+  // Scary scary fall throughs are annotated with carefully designed comments
+  // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
+  switch (*length) {
+    case 4:
+      --output;
+      *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
+      input >>= 6;
+      // fall through
+    case 3:
+      --output;
+      *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
+      input >>= 6;
+      // fall through
+    case 2:
+      --output;
+      *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
+      input >>= 6;
+      // fall through
+    case 1:
+      --output;
+      *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
+      break;
+    default:
+      TIXMLASSERT(false);
+  }
+}
+
+const char* XMLUtil::GetCharacterRef(const char* p, char* value, int* length) {
+  // Assume an entity, and pull it out.
+  *length = 0;
+
+  static const uint32_t MAX_CODE_POINT = 0x10FFFF;
+
+  if (*(p + 1) == '#' && *(p + 2)) {
+    uint32_t ucs = 0;
+    ptrdiff_t delta = 0;
+    uint32_t mult = 1;
+    static const char SEMICOLON = ';';
+
+    bool hex = false;
+    uint32_t radix = 10;
+    const char* q = 0;
+    char terminator = '#';
+
+    if (*(p + 2) == 'x') {
+      // Hexadecimal.
+      hex = true;
+      radix = 16;
+      terminator = 'x';
+
+      q = p + 3;
+    } else {
+      // Decimal.
+      q = p + 2;
+    }
+    if (!(*q)) {
+      return 0;
+    }
+
+    q = strchr(q, SEMICOLON);
+    if (!q) {
+      return 0;
+    }
+    TIXMLASSERT(*q == SEMICOLON);
+
+    delta = q - p;
+    --q;
+
+    while (*q != terminator) {
+      uint32_t digit = 0;
+
+      if (*q >= '0' && *q <= '9') {
+        digit = *q - '0';
+      } else if (hex && (*q >= 'a' && *q <= 'f')) {
+        digit = *q - 'a' + 10;
+      } else if (hex && (*q >= 'A' && *q <= 'F')) {
+        digit = *q - 'A' + 10;
+      } else {
+        return 0;
+      }
+      TIXMLASSERT(digit < radix);
+
+      const unsigned int digitScaled = mult * digit;
+      ucs += digitScaled;
+      mult *= radix;
+
+      // Security check: could a value exist that is out of range?
+      // Easily; limit to the MAX_CODE_POINT, which also allows for a
+      // bunch of leading zeroes.
+      if (mult > MAX_CODE_POINT) {
+        mult = MAX_CODE_POINT;
+      }
+      --q;
+    }
+    // Out of range:
+    if (ucs > MAX_CODE_POINT) {
+      return 0;
+    }
+    // convert the UCS to UTF-8
+    ConvertUTF32ToUTF8(ucs, value, length);
+    if (length == 0) {
+      // If length is 0, there was an error. (Security? Bad input?)
+      // Fail safely.
+      return 0;
+    }
+    return p + delta + 1;
+  }
+  return p + 1;
+}
+
+void XMLUtil::ToStr(int v, char* buffer, int bufferSize) {
+  TIXML_SNPRINTF(buffer, bufferSize, "%d", v);
+}
+
+void XMLUtil::ToStr(unsigned v, char* buffer, int bufferSize) {
+  TIXML_SNPRINTF(buffer, bufferSize, "%u", v);
+}
+
+void XMLUtil::ToStr(bool v, char* buffer, int bufferSize) {
+  TIXML_SNPRINTF(buffer, bufferSize, "%s", v ? writeBoolTrue : writeBoolFalse);
+}
+
+/*
+        ToStr() of a number is a very tricky topic.
+        https://github.com/leethomason/tinyxml2/issues/106
+*/
+void XMLUtil::ToStr(float v, char* buffer, int bufferSize) {
+  TIXML_SNPRINTF(buffer, bufferSize, "%.8g", v);
+}
+
+void XMLUtil::ToStr(double v, char* buffer, int bufferSize) {
+  TIXML_SNPRINTF(buffer, bufferSize, "%.17g", v);
+}
+
+void XMLUtil::ToStr(int64_t v, char* buffer, int bufferSize) {
+  // horrible syntax trick to make the compiler happy about %lld
+  TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
+}
+
+void XMLUtil::ToStr(uint64_t v, char* buffer, int bufferSize) {
+  // horrible syntax trick to make the compiler happy about %llu
+  TIXML_SNPRINTF(buffer, bufferSize, "%llu",
+                 static_cast<unsigned long long>(v));
+}
+
+bool XMLUtil::ToInt(const char* str, int* value) {
+  if (IsPrefixHex(str)) {
+    unsigned v;
+    if (TIXML_SSCANF(str, "%x", &v) == 1) {
+      *value = static_cast<int>(v);
+      return true;
+    }
+  } else {
+    if (TIXML_SSCANF(str, "%d", value) == 1) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool XMLUtil::ToUnsigned(const char* str, unsigned* value) {
+  if (TIXML_SSCANF(str, IsPrefixHex(str) ? "%x" : "%u", value) == 1) {
+    return true;
+  }
+  return false;
+}
+
+bool XMLUtil::ToBool(const char* str, bool* value) {
+  int ival = 0;
+  if (ToInt(str, &ival)) {
+    *value = (ival == 0) ? false : true;
+    return true;
+  }
+  static const char* TRUE_VALS[] = {"true", "True", "TRUE", 0};
+  static const char* FALSE_VALS[] = {"false", "False", "FALSE", 0};
+
+  for (int i = 0; TRUE_VALS[i]; ++i) {
+    if (StringEqual(str, TRUE_VALS[i])) {
+      *value = true;
+      return true;
+    }
+  }
+  for (int i = 0; FALSE_VALS[i]; ++i) {
+    if (StringEqual(str, FALSE_VALS[i])) {
+      *value = false;
+      return true;
+    }
+  }
+  return false;
+}
+
+bool XMLUtil::ToFloat(const char* str, float* value) {
+  if (TIXML_SSCANF(str, "%f", value) == 1) {
+    return true;
+  }
+  return false;
+}
+
+bool XMLUtil::ToDouble(const char* str, double* value) {
+  if (TIXML_SSCANF(str, "%lf", value) == 1) {
+    return true;
+  }
+  return false;
+}
+
+bool XMLUtil::ToInt64(const char* str, int64_t* value) {
+  if (IsPrefixHex(str)) {
+    unsigned long long v =
+        0;  // horrible syntax trick to make the compiler happy about %llx
+    if (TIXML_SSCANF(str, "%llx", &v) == 1) {
+      *value = static_cast<int64_t>(v);
+      return true;
+    }
+  } else {
+    long long v =
+        0;  // horrible syntax trick to make the compiler happy about %lld
+    if (TIXML_SSCANF(str, "%lld", &v) == 1) {
+      *value = static_cast<int64_t>(v);
+      return true;
+    }
+  }
+  return false;
+}
+
+bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
+  unsigned long long v =
+      0;  // horrible syntax trick to make the compiler happy about %llu
+  if (TIXML_SSCANF(str, IsPrefixHex(str) ? "%llx" : "%llu", &v) == 1) {
+    *value = static_cast<uint64_t>(v);
+    return true;
+  }
+  return false;
+}
+
+char* XMLDocument::Identify(char* p, XMLNode** node, bool first) {
+  TIXMLASSERT(node);
+  TIXMLASSERT(p);
+  char* const start = p;
+  int const startLine = _parseCurLineNum;
+  p = XMLUtil::SkipWhiteSpace(p, &_parseCurLineNum);
+  if (!*p) {
+    *node = 0;
+    TIXMLASSERT(p);
+    return p;
+  }
+
+  // These strings define the matching patterns:
+  static const char* xmlHeader = {"<?"};
+  static const char* commentHeader = {"<!--"};
+  static const char* cdataHeader = {"<![CDATA["};
+  static const char* dtdHeader = {"<!"};
+  static const char* elementHeader = {
+      "<"};  // and a header for everything else; check last.
+
+  static const int xmlHeaderLen = 2;
+  static const int commentHeaderLen = 4;
+  static const int cdataHeaderLen = 9;
+  static const int dtdHeaderLen = 2;
+  static const int elementHeaderLen = 1;
+
+  TIXMLASSERT(sizeof(XMLComment) ==
+              sizeof(XMLUnknown));  // use same memory pool
+  TIXMLASSERT(sizeof(XMLComment) ==
+              sizeof(XMLDeclaration));  // use same memory pool
+  XMLNode* returnNode = 0;
+  if (XMLUtil::StringEqual(p, xmlHeader, xmlHeaderLen)) {
+    returnNode = CreateUnlinkedNode<XMLDeclaration>(_commentPool);
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += xmlHeaderLen;
+  } else if (XMLUtil::StringEqual(p, commentHeader, commentHeaderLen)) {
+    returnNode = CreateUnlinkedNode<XMLComment>(_commentPool);
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += commentHeaderLen;
+  } else if (XMLUtil::StringEqual(p, cdataHeader, cdataHeaderLen)) {
+    XMLText* text = CreateUnlinkedNode<XMLText>(_textPool);
+    returnNode = text;
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += cdataHeaderLen;
+    text->SetCData(true);
+  } else if (XMLUtil::StringEqual(p, dtdHeader, dtdHeaderLen)) {
+    returnNode = CreateUnlinkedNode<XMLUnknown>(_commentPool);
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += dtdHeaderLen;
+  } else if (XMLUtil::StringEqual(p, elementHeader, elementHeaderLen)) {
+    // Preserve whitespace pedantically before closing tag, when it's
+    // immediately after opening tag
+    if (WhitespaceMode() == PEDANTIC_WHITESPACE && first && p != start &&
+        *(p + elementHeaderLen) == '/') {
+      returnNode = CreateUnlinkedNode<XMLText>(_textPool);
+      returnNode->_parseLineNum = startLine;
+      p = start;  // Back it up, all the text counts.
+      _parseCurLineNum = startLine;
+    } else {
+      returnNode = CreateUnlinkedNode<XMLElement>(_elementPool);
+      returnNode->_parseLineNum = _parseCurLineNum;
+      p += elementHeaderLen;
+    }
+  } else {
+    returnNode = CreateUnlinkedNode<XMLText>(_textPool);
+    returnNode->_parseLineNum =
+        _parseCurLineNum;  // Report line of first non-whitespace character
+    p = start;             // Back it up, all the text counts.
+    _parseCurLineNum = startLine;
+  }
+
+  TIXMLASSERT(returnNode);
+  TIXMLASSERT(p);
+  *node = returnNode;
+  return p;
+}
+
+bool XMLDocument::Accept(XMLVisitor* visitor) const {
+  TIXMLASSERT(visitor);
+  if (visitor->VisitEnter(*this)) {
+    for (const XMLNode* node = FirstChild(); node; node = node->NextSibling()) {
+      if (!node->Accept(visitor)) {
+        break;
+      }
+    }
+  }
+  return visitor->VisitExit(*this);
+}
+
+// --------- XMLNode ----------- //
+
+XMLNode::XMLNode(XMLDocument* doc)
+    : _document(doc),
+      _parent(0),
+      _value(),
+      _parseLineNum(0),
+      _firstChild(0),
+      _lastChild(0),
+      _prev(0),
+      _next(0),
+      _userData(0),
+      _memPool(0) {}
+
+XMLNode::~XMLNode() {
+  DeleteChildren();
+  if (_parent) {
+    _parent->Unlink(this);
+  }
+}
+
+// ChildElementCount was originally suggested by msteiger on the sourceforge
+// page for TinyXML and modified by KB1SPH for TinyXML-2.
+
+int XMLNode::ChildElementCount(const char* value) const {
+  int count = 0;
+
+  const XMLElement* e = FirstChildElement(value);
+
+  while (e) {
+    e = e->NextSiblingElement(value);
+    count++;
+  }
+
+  return count;
+}
+
+int XMLNode::ChildElementCount() const {
+  int count = 0;
+
+  const XMLElement* e = FirstChildElement();
+
+  while (e) {
+    e = e->NextSiblingElement();
+    count++;
+  }
+
+  return count;
+}
+
+const char* XMLNode::Value() const {
+  // Edge case: XMLDocuments don't have a Value. Return null.
+  if (this->ToDocument()) return 0;
+  return _value.GetStr();
+}
+
+void XMLNode::SetValue(const char* str, bool staticMem) {
+  if (staticMem) {
+    _value.SetInternedStr(str);
+  } else {
+    _value.SetStr(str);
+  }
+}
+
+XMLNode* XMLNode::DeepClone(XMLDocument* target) const {
+  XMLNode* clone = this->ShallowClone(target);
+  if (!clone) return 0;
+
+  for (const XMLNode* child = this->FirstChild(); child;
+       child = child->NextSibling()) {
+    XMLNode* childClone = child->DeepClone(target);
+    TIXMLASSERT(childClone);
+    clone->InsertEndChild(childClone);
+  }
+  return clone;
+}
+
+void XMLNode::DeleteChildren() {
+  while (_firstChild) {
+    TIXMLASSERT(_lastChild);
+    DeleteChild(_firstChild);
+  }
+  _firstChild = _lastChild = 0;
+}
+
+void XMLNode::Unlink(XMLNode* child) {
+  TIXMLASSERT(child);
+  TIXMLASSERT(child->_document == _document);
+  TIXMLASSERT(child->_parent == this);
+  if (child == _firstChild) {
+    _firstChild = _firstChild->_next;
+  }
+  if (child == _lastChild) {
+    _lastChild = _lastChild->_prev;
+  }
+
+  if (child->_prev) {
+    child->_prev->_next = child->_next;
+  }
+  if (child->_next) {
+    child->_next->_prev = child->_prev;
+  }
+  child->_next = 0;
+  child->_prev = 0;
+  child->_parent = 0;
+}
+
+void XMLNode::DeleteChild(XMLNode* node) {
+  TIXMLASSERT(node);
+  TIXMLASSERT(node->_document == _document);
+  TIXMLASSERT(node->_parent == this);
+  Unlink(node);
+  TIXMLASSERT(node->_prev == 0);
+  TIXMLASSERT(node->_next == 0);
+  TIXMLASSERT(node->_parent == 0);
+  DeleteNode(node);
+}
+
+XMLNode* XMLNode::InsertEndChild(XMLNode* addThis) {
+  TIXMLASSERT(addThis);
+  if (addThis->_document != _document) {
+    TIXMLASSERT(false);
     return 0;
-}
-
-
-char* StrPair::ParseName( char* p )
-{
-    if ( !p || !(*p) ) {
+  }
+  InsertChildPreamble(addThis);
+
+  if (_lastChild) {
+    TIXMLASSERT(_firstChild);
+    TIXMLASSERT(_lastChild->_next == 0);
+    _lastChild->_next = addThis;
+    addThis->_prev = _lastChild;
+    _lastChild = addThis;
+
+    addThis->_next = 0;
+  } else {
+    TIXMLASSERT(_firstChild == 0);
+    _firstChild = _lastChild = addThis;
+
+    addThis->_prev = 0;
+    addThis->_next = 0;
+  }
+  addThis->_parent = this;
+  return addThis;
+}
+
+XMLNode* XMLNode::InsertFirstChild(XMLNode* addThis) {
+  TIXMLASSERT(addThis);
+  if (addThis->_document != _document) {
+    TIXMLASSERT(false);
+    return 0;
+  }
+  InsertChildPreamble(addThis);
+
+  if (_firstChild) {
+    TIXMLASSERT(_lastChild);
+    TIXMLASSERT(_firstChild->_prev == 0);
+
+    _firstChild->_prev = addThis;
+    addThis->_next = _firstChild;
+    _firstChild = addThis;
+
+    addThis->_prev = 0;
+  } else {
+    TIXMLASSERT(_lastChild == 0);
+    _firstChild = _lastChild = addThis;
+
+    addThis->_prev = 0;
+    addThis->_next = 0;
+  }
+  addThis->_parent = this;
+  return addThis;
+}
+
+XMLNode* XMLNode::InsertAfterChild(XMLNode* afterThis, XMLNode* addThis) {
+  TIXMLASSERT(addThis);
+  if (addThis->_document != _document) {
+    TIXMLASSERT(false);
+    return 0;
+  }
+
+  TIXMLASSERT(afterThis);
+
+  if (afterThis->_parent != this) {
+    TIXMLASSERT(false);
+    return 0;
+  }
+  if (afterThis == addThis) {
+    // Current state: BeforeThis -> AddThis -> OneAfterAddThis
+    // Now AddThis must disappear from it's location and then
+    // reappear between BeforeThis and OneAfterAddThis.
+    // So just leave it where it is.
+    return addThis;
+  }
+
+  if (afterThis->_next == 0) {
+    // The last node or the only node.
+    return InsertEndChild(addThis);
+  }
+  InsertChildPreamble(addThis);
+  addThis->_prev = afterThis;
+  addThis->_next = afterThis->_next;
+  afterThis->_next->_prev = addThis;
+  afterThis->_next = addThis;
+  addThis->_parent = this;
+  return addThis;
+}
+
+const XMLElement* XMLNode::FirstChildElement(const char* name) const {
+  for (const XMLNode* node = _firstChild; node; node = node->_next) {
+    const XMLElement* element = node->ToElementWithName(name);
+    if (element) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+const XMLElement* XMLNode::LastChildElement(const char* name) const {
+  for (const XMLNode* node = _lastChild; node; node = node->_prev) {
+    const XMLElement* element = node->ToElementWithName(name);
+    if (element) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+const XMLElement* XMLNode::NextSiblingElement(const char* name) const {
+  for (const XMLNode* node = _next; node; node = node->_next) {
+    const XMLElement* element = node->ToElementWithName(name);
+    if (element) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+const XMLElement* XMLNode::PreviousSiblingElement(const char* name) const {
+  for (const XMLNode* node = _prev; node; node = node->_prev) {
+    const XMLElement* element = node->ToElementWithName(name);
+    if (element) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+char* XMLNode::ParseDeep(char* p, StrPair* parentEndTag, int* curLineNumPtr) {
+  // This is a recursive method, but thinking about it "at the current level"
+  // it is a pretty simple flat list:
+  //		<foo/>
+  //		<!-- comment -->
+  //
+  // With a special case:
+  //		<foo>
+  //		</foo>
+  //		<!-- comment -->
+  //
+  // Where the closing element (/foo) *must* be the next thing after the opening
+  // element, and the names must match. BUT the tricky bit is that the closing
+  // element will be read by the child.
+  //
+  // 'endTag' is the end tag for this node, it is returned by a call to a child.
+  // 'parentEnd' is the end tag for the parent, which is filled in and returned.
+
+  XMLDocument::DepthTracker tracker(_document);
+  if (_document->Error()) return 0;
+
+  bool first = true;
+  while (p && *p) {
+    XMLNode* node = 0;
+
+    p = _document->Identify(p, &node, first);
+    TIXMLASSERT(p);
+    if (node == 0) {
+      break;
+    }
+    first = false;
+
+    const int initialLineNum = node->_parseLineNum;
+
+    StrPair endTag;
+    p = node->ParseDeep(p, &endTag, curLineNumPtr);
+    if (!p) {
+      _document->DeleteNode(node);
+      if (!_document->Error()) {
+        _document->SetError(XML_ERROR_PARSING, initialLineNum, 0);
+      }
+      break;
+    }
+
+    const XMLDeclaration* const decl = node->ToDeclaration();
+    if (decl) {
+      // Declarations are only allowed at document level
+      //
+      // Multiple declarations are allowed but all declarations
+      // must occur before anything else.
+      //
+      // Optimized due to a security test case. If the first node is
+      // a declaration, and the last node is a declaration, then only
+      // declarations have so far been added.
+      bool wellLocated = false;
+
+      if (ToDocument()) {
+        if (FirstChild()) {
+          wellLocated = FirstChild() && FirstChild()->ToDeclaration() &&
+                        LastChild() && LastChild()->ToDeclaration();
+        } else {
+          wellLocated = true;
+        }
+      }
+      if (!wellLocated) {
+        _document->SetError(XML_ERROR_PARSING_DECLARATION, initialLineNum,
+                            "XMLDeclaration value=%s", decl->Value());
+        _document->DeleteNode(node);
+        break;
+      }
+    }
+
+    XMLElement* ele = node->ToElement();
+    if (ele) {
+      // We read the end tag. Return it to the parent.
+      if (ele->ClosingType() == XMLElement::CLOSING) {
+        if (parentEndTag) {
+          ele->_value.TransferTo(parentEndTag);
+        }
+        node->_memPool->SetTracked();  // created and then immediately deleted.
+        DeleteNode(node);
+        return p;
+      }
+
+      // Handle an end tag returned to this level.
+      // And handle a bunch of annoying errors.
+      bool mismatch = false;
+      if (endTag.Empty()) {
+        if (ele->ClosingType() == XMLElement::OPEN) {
+          mismatch = true;
+        }
+      } else {
+        if (ele->ClosingType() != XMLElement::OPEN) {
+          mismatch = true;
+        } else if (!XMLUtil::StringEqual(endTag.GetStr(), ele->Name())) {
+          mismatch = true;
+        }
+      }
+      if (mismatch) {
+        _document->SetError(XML_ERROR_MISMATCHED_ELEMENT, initialLineNum,
+                            "XMLElement name=%s", ele->Name());
+        _document->DeleteNode(node);
+        break;
+      }
+    }
+    InsertEndChild(node);
+  }
+  return 0;
+}
+
+/*static*/ void XMLNode::DeleteNode(XMLNode* node) {
+  if (node == 0) {
+    return;
+  }
+  TIXMLASSERT(node->_document);
+  if (!node->ToDocument()) {
+    node->_document->MarkInUse(node);
+  }
+
+  MemPool* pool = node->_memPool;
+  node->~XMLNode();
+  pool->Free(node);
+}
+
+void XMLNode::InsertChildPreamble(XMLNode* insertThis) const {
+  TIXMLASSERT(insertThis);
+  TIXMLASSERT(insertThis->_document == _document);
+
+  if (insertThis->_parent) {
+    insertThis->_parent->Unlink(insertThis);
+  } else {
+    insertThis->_document->MarkInUse(insertThis);
+    insertThis->_memPool->SetTracked();
+  }
+}
+
+const XMLElement* XMLNode::ToElementWithName(const char* name) const {
+  const XMLElement* element = this->ToElement();
+  if (element == 0) {
+    return 0;
+  }
+  if (name == 0) {
+    return element;
+  }
+  if (XMLUtil::StringEqual(element->Name(), name)) {
+    return element;
+  }
+  return 0;
+}
+
+// --------- XMLText ---------- //
+char* XMLText::ParseDeep(char* p, StrPair*, int* curLineNumPtr) {
+  if (this->CData()) {
+    p = _value.ParseText(p, "]]>", StrPair::NEEDS_NEWLINE_NORMALIZATION,
+                         curLineNumPtr);
+    if (!p) {
+      _document->SetError(XML_ERROR_PARSING_CDATA, _parseLineNum, 0);
+    }
+    return p;
+  } else {
+    int flags = _document->ProcessEntities()
+                    ? StrPair::TEXT_ELEMENT
+                    : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
+    if (_document->WhitespaceMode() == COLLAPSE_WHITESPACE) {
+      flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
+    }
+
+    p = _value.ParseText(p, "<", flags, curLineNumPtr);
+    if (p && *p) {
+      return p - 1;
+    }
+    if (!p) {
+      _document->SetError(XML_ERROR_PARSING_TEXT, _parseLineNum, 0);
+    }
+  }
+  return 0;
+}
+
+XMLNode* XMLText::ShallowClone(XMLDocument* doc) const {
+  if (!doc) {
+    doc = _document;
+  }
+  XMLText* text = doc->NewText(
+      Value());  // fixme: this will always allocate memory. Intern?
+  text->SetCData(this->CData());
+  return text;
+}
+
+bool XMLText::ShallowEqual(const XMLNode* compare) const {
+  TIXMLASSERT(compare);
+  const XMLText* text = compare->ToText();
+  return (text && XMLUtil::StringEqual(text->Value(), Value()));
+}
+
+bool XMLText::Accept(XMLVisitor* visitor) const {
+  TIXMLASSERT(visitor);
+  return visitor->Visit(*this);
+}
+
+// --------- XMLComment ---------- //
+
+XMLComment::XMLComment(XMLDocument* doc) : XMLNode(doc) {}
+
+XMLComment::~XMLComment() {}
+
+char* XMLComment::ParseDeep(char* p, StrPair*, int* curLineNumPtr) {
+  // Comment parses as text.
+  p = _value.ParseText(p, "-->", StrPair::COMMENT, curLineNumPtr);
+  if (p == 0) {
+    _document->SetError(XML_ERROR_PARSING_COMMENT, _parseLineNum, 0);
+  }
+  return p;
+}
+
+XMLNode* XMLComment::ShallowClone(XMLDocument* doc) const {
+  if (!doc) {
+    doc = _document;
+  }
+  XMLComment* comment = doc->NewComment(
+      Value());  // fixme: this will always allocate memory. Intern?
+  return comment;
+}
+
+bool XMLComment::ShallowEqual(const XMLNode* compare) const {
+  TIXMLASSERT(compare);
+  const XMLComment* comment = compare->ToComment();
+  return (comment && XMLUtil::StringEqual(comment->Value(), Value()));
+}
+
+bool XMLComment::Accept(XMLVisitor* visitor) const {
+  TIXMLASSERT(visitor);
+  return visitor->Visit(*this);
+}
+
+// --------- XMLDeclaration ---------- //
+
+XMLDeclaration::XMLDeclaration(XMLDocument* doc) : XMLNode(doc) {}
+
+XMLDeclaration::~XMLDeclaration() {
+  // printf( "~XMLDeclaration\n" );
+}
+
+char* XMLDeclaration::ParseDeep(char* p, StrPair*, int* curLineNumPtr) {
+  // Declaration parses as text.
+  p = _value.ParseText(p, "?>", StrPair::NEEDS_NEWLINE_NORMALIZATION,
+                       curLineNumPtr);
+  if (p == 0) {
+    _document->SetError(XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0);
+  }
+  return p;
+}
+
+XMLNode* XMLDeclaration::ShallowClone(XMLDocument* doc) const {
+  if (!doc) {
+    doc = _document;
+  }
+  XMLDeclaration* dec = doc->NewDeclaration(
+      Value());  // fixme: this will always allocate memory. Intern?
+  return dec;
+}
+
+bool XMLDeclaration::ShallowEqual(const XMLNode* compare) const {
+  TIXMLASSERT(compare);
+  const XMLDeclaration* declaration = compare->ToDeclaration();
+  return (declaration && XMLUtil::StringEqual(declaration->Value(), Value()));
+}
+
+bool XMLDeclaration::Accept(XMLVisitor* visitor) const {
+  TIXMLASSERT(visitor);
+  return visitor->Visit(*this);
+}
+
+// --------- XMLUnknown ---------- //
+
+XMLUnknown::XMLUnknown(XMLDocument* doc) : XMLNode(doc) {}
+
+XMLUnknown::~XMLUnknown() {}
+
+char* XMLUnknown::ParseDeep(char* p, StrPair*, int* curLineNumPtr) {
+  // Unknown parses as text.
+  p = _value.ParseText(p, ">", StrPair::NEEDS_NEWLINE_NORMALIZATION,
+                       curLineNumPtr);
+  if (!p) {
+    _document->SetError(XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0);
+  }
+  return p;
+}
+
+XMLNode* XMLUnknown::ShallowClone(XMLDocument* doc) const {
+  if (!doc) {
+    doc = _document;
+  }
+  XMLUnknown* text = doc->NewUnknown(
+      Value());  // fixme: this will always allocate memory. Intern?
+  return text;
+}
+
+bool XMLUnknown::ShallowEqual(const XMLNode* compare) const {
+  TIXMLASSERT(compare);
+  const XMLUnknown* unknown = compare->ToUnknown();
+  return (unknown && XMLUtil::StringEqual(unknown->Value(), Value()));
+}
+
+bool XMLUnknown::Accept(XMLVisitor* visitor) const {
+  TIXMLASSERT(visitor);
+  return visitor->Visit(*this);
+}
+
+// --------- XMLAttribute ---------- //
+
+const char* XMLAttribute::Name() const { return _name.GetStr(); }
+
+const char* XMLAttribute::Value() const { return _value.GetStr(); }
+
+char* XMLAttribute::ParseDeep(char* p, bool processEntities,
+                              int* curLineNumPtr) {
+  // Parse using the name rules: bug fix, was using ParseText before
+  p = _name.ParseName(p);
+  if (!p || !*p) {
+    return 0;
+  }
+
+  // Skip white space before =
+  p = XMLUtil::SkipWhiteSpace(p, curLineNumPtr);
+  if (*p != '=') {
+    return 0;
+  }
+
+  ++p;  // move up to opening quote
+  p = XMLUtil::SkipWhiteSpace(p, curLineNumPtr);
+  if (*p != '\"' && *p != '\'') {
+    return 0;
+  }
+
+  const char endTag[2] = {*p, 0};
+  ++p;  // move past opening quote
+
+  p = _value.ParseText(p, endTag,
+                       processEntities
+                           ? StrPair::ATTRIBUTE_VALUE
+                           : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES,
+                       curLineNumPtr);
+  return p;
+}
+
+void XMLAttribute::SetName(const char* n) { _name.SetStr(n); }
+
+XMLError XMLAttribute::QueryIntValue(int* value) const {
+  if (XMLUtil::ToInt(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
+}
+
+XMLError XMLAttribute::QueryUnsignedValue(unsigned int* value) const {
+  if (XMLUtil::ToUnsigned(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
+}
+
+XMLError XMLAttribute::QueryInt64Value(int64_t* value) const {
+  if (XMLUtil::ToInt64(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
+}
+
+XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const {
+  if (XMLUtil::ToUnsigned64(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
+}
+
+XMLError XMLAttribute::QueryBoolValue(bool* value) const {
+  if (XMLUtil::ToBool(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
+}
+
+XMLError XMLAttribute::QueryFloatValue(float* value) const {
+  if (XMLUtil::ToFloat(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
+}
+
+XMLError XMLAttribute::QueryDoubleValue(double* value) const {
+  if (XMLUtil::ToDouble(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
+}
+
+void XMLAttribute::SetAttribute(const char* v) { _value.SetStr(v); }
+
+void XMLAttribute::SetAttribute(int v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
+}
+
+void XMLAttribute::SetAttribute(unsigned v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
+}
+
+void XMLAttribute::SetAttribute(int64_t v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
+}
+
+void XMLAttribute::SetAttribute(uint64_t v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
+}
+
+void XMLAttribute::SetAttribute(bool v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
+}
+
+void XMLAttribute::SetAttribute(double v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
+}
+
+void XMLAttribute::SetAttribute(float v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
+}
+
+// --------- XMLElement ---------- //
+XMLElement::XMLElement(XMLDocument* doc)
+    : XMLNode(doc), _closingType(OPEN), _rootAttribute(0) {}
+
+XMLElement::~XMLElement() {
+  while (_rootAttribute) {
+    XMLAttribute* next = _rootAttribute->_next;
+    DeleteAttribute(_rootAttribute);
+    _rootAttribute = next;
+  }
+}
+
+const XMLAttribute* XMLElement::FindAttribute(const char* name) const {
+  for (XMLAttribute* a = _rootAttribute; a; a = a->_next) {
+    if (XMLUtil::StringEqual(a->Name(), name)) {
+      return a;
+    }
+  }
+  return 0;
+}
+
+const char* XMLElement::Attribute(const char* name, const char* value) const {
+  const XMLAttribute* a = FindAttribute(name);
+  if (!a) {
+    return 0;
+  }
+  if (!value || XMLUtil::StringEqual(a->Value(), value)) {
+    return a->Value();
+  }
+  return 0;
+}
+
+int XMLElement::IntAttribute(const char* name, int defaultValue) const {
+  int i = defaultValue;
+  QueryIntAttribute(name, &i);
+  return i;
+}
+
+unsigned XMLElement::UnsignedAttribute(const char* name,
+                                       unsigned defaultValue) const {
+  unsigned i = defaultValue;
+  QueryUnsignedAttribute(name, &i);
+  return i;
+}
+
+int64_t XMLElement::Int64Attribute(const char* name,
+                                   int64_t defaultValue) const {
+  int64_t i = defaultValue;
+  QueryInt64Attribute(name, &i);
+  return i;
+}
+
+uint64_t XMLElement::Unsigned64Attribute(const char* name,
+                                         uint64_t defaultValue) const {
+  uint64_t i = defaultValue;
+  QueryUnsigned64Attribute(name, &i);
+  return i;
+}
+
+bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const {
+  bool b = defaultValue;
+  QueryBoolAttribute(name, &b);
+  return b;
+}
+
+double XMLElement::DoubleAttribute(const char* name,
+                                   double defaultValue) const {
+  double d = defaultValue;
+  QueryDoubleAttribute(name, &d);
+  return d;
+}
+
+float XMLElement::FloatAttribute(const char* name, float defaultValue) const {
+  float f = defaultValue;
+  QueryFloatAttribute(name, &f);
+  return f;
+}
+
+const char* XMLElement::GetText() const {
+  /* skip comment node */
+  const XMLNode* node = FirstChild();
+  while (node) {
+    if (node->ToComment()) {
+      node = node->NextSibling();
+      continue;
+    }
+    break;
+  }
+
+  if (node && node->ToText()) {
+    return node->Value();
+  }
+  return 0;
+}
+
+void XMLElement::SetText(const char* inText) {
+  if (FirstChild() && FirstChild()->ToText())
+    FirstChild()->SetValue(inText);
+  else {
+    XMLText* theText = GetDocument()->NewText(inText);
+    InsertFirstChild(theText);
+  }
+}
+
+void XMLElement::SetText(int v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
+}
+
+void XMLElement::SetText(unsigned v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
+}
+
+void XMLElement::SetText(int64_t v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
+}
+
+void XMLElement::SetText(uint64_t v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
+}
+
+void XMLElement::SetText(bool v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
+}
+
+void XMLElement::SetText(float v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
+}
+
+void XMLElement::SetText(double v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
+}
+
+XMLError XMLElement::QueryIntText(int* ival) const {
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToInt(t, ival)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
+}
+
+XMLError XMLElement::QueryUnsignedText(unsigned* uval) const {
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToUnsigned(t, uval)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
+}
+
+XMLError XMLElement::QueryInt64Text(int64_t* ival) const {
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToInt64(t, ival)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
+}
+
+XMLError XMLElement::QueryUnsigned64Text(uint64_t* uval) const {
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToUnsigned64(t, uval)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
+}
+
+XMLError XMLElement::QueryBoolText(bool* bval) const {
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToBool(t, bval)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
+}
+
+XMLError XMLElement::QueryDoubleText(double* dval) const {
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToDouble(t, dval)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
+}
+
+XMLError XMLElement::QueryFloatText(float* fval) const {
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToFloat(t, fval)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
+}
+
+int XMLElement::IntText(int defaultValue) const {
+  int i = defaultValue;
+  QueryIntText(&i);
+  return i;
+}
+
+unsigned XMLElement::UnsignedText(unsigned defaultValue) const {
+  unsigned i = defaultValue;
+  QueryUnsignedText(&i);
+  return i;
+}
+
+int64_t XMLElement::Int64Text(int64_t defaultValue) const {
+  int64_t i = defaultValue;
+  QueryInt64Text(&i);
+  return i;
+}
+
+uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const {
+  uint64_t i = defaultValue;
+  QueryUnsigned64Text(&i);
+  return i;
+}
+
+bool XMLElement::BoolText(bool defaultValue) const {
+  bool b = defaultValue;
+  QueryBoolText(&b);
+  return b;
+}
+
+double XMLElement::DoubleText(double defaultValue) const {
+  double d = defaultValue;
+  QueryDoubleText(&d);
+  return d;
+}
+
+float XMLElement::FloatText(float defaultValue) const {
+  float f = defaultValue;
+  QueryFloatText(&f);
+  return f;
+}
+
+XMLAttribute* XMLElement::FindOrCreateAttribute(const char* name) {
+  XMLAttribute* last = 0;
+  XMLAttribute* attrib = 0;
+  for (attrib = _rootAttribute; attrib; last = attrib, attrib = attrib->_next) {
+    if (XMLUtil::StringEqual(attrib->Name(), name)) {
+      break;
+    }
+  }
+  if (!attrib) {
+    attrib = CreateAttribute();
+    TIXMLASSERT(attrib);
+    if (last) {
+      TIXMLASSERT(last->_next == 0);
+      last->_next = attrib;
+    } else {
+      TIXMLASSERT(_rootAttribute == 0);
+      _rootAttribute = attrib;
+    }
+    attrib->SetName(name);
+  }
+  return attrib;
+}
+
+void XMLElement::DeleteAttribute(const char* name) {
+  XMLAttribute* prev = 0;
+  for (XMLAttribute* a = _rootAttribute; a; a = a->_next) {
+    if (XMLUtil::StringEqual(name, a->Name())) {
+      if (prev) {
+        prev->_next = a->_next;
+      } else {
+        _rootAttribute = a->_next;
+      }
+      DeleteAttribute(a);
+      break;
+    }
+    prev = a;
+  }
+}
+
+char* XMLElement::ParseAttributes(char* p, int* curLineNumPtr) {
+  XMLAttribute* prevAttribute = 0;
+
+  // Read the attributes.
+  while (p) {
+    p = XMLUtil::SkipWhiteSpace(p, curLineNumPtr);
+    if (!(*p)) {
+      _document->SetError(XML_ERROR_PARSING_ELEMENT, _parseLineNum,
+                          "XMLElement name=%s", Name());
+      return 0;
+    }
+
+    // attribute.
+    if (XMLUtil::IsNameStartChar(static_cast<unsigned char>(*p))) {
+      XMLAttribute* attrib = CreateAttribute();
+      TIXMLASSERT(attrib);
+      attrib->_parseLineNum = _document->_parseCurLineNum;
+
+      const int attrLineNum = attrib->_parseLineNum;
+
+      p = attrib->ParseDeep(p, _document->ProcessEntities(), curLineNumPtr);
+      if (!p || Attribute(attrib->Name())) {
+        DeleteAttribute(attrib);
+        _document->SetError(XML_ERROR_PARSING_ATTRIBUTE, attrLineNum,
+                            "XMLElement name=%s", Name());
         return 0;
-    }
-    if ( !XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
-        return 0;
-    }
-
-    char* const start = p;
-    ++p;
-    while ( *p && XMLUtil::IsNameChar( static_cast<unsigned char>(*p) ) ) {
-        ++p;
-    }
-
-    Set( start, p, 0 );
-    return p;
-}
-
-
-void StrPair::CollapseWhitespace()
-{
-    // Adjusting _start would cause undefined behavior on delete[]
-    TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );
-    // Trim leading space.
-    _start = XMLUtil::SkipWhiteSpace( _start, 0 );
-
-    if ( *_start ) {
-        const char* p = _start;	// the read pointer
-        char* q = _start;	// the write pointer
-
-        while( *p ) {
-            if ( XMLUtil::IsWhiteSpace( *p )) {
-                p = XMLUtil::SkipWhiteSpace( p, 0 );
-                if ( *p == 0 ) {
-                    break;    // don't write to q; this trims the trailing space.
-                }
-                *q = ' ';
-                ++q;
-            }
-            *q = *p;
-            ++q;
-            ++p;
-        }
-        *q = 0;
-    }
-}
-
-
-const char* StrPair::GetStr()
-{
-    TIXMLASSERT( _start );
-    TIXMLASSERT( _end );
-    if ( _flags & NEEDS_FLUSH ) {
-        *_end = 0;
-        _flags ^= NEEDS_FLUSH;
-
-        if ( _flags ) {
-            const char* p = _start;	// the read pointer
-            char* q = _start;	// the write pointer
-
-            while( p < _end ) {
-                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {
-                    // CR-LF pair becomes LF
-                    // CR alone becomes LF
-                    // LF-CR becomes LF
-                    if ( *(p+1) == LF ) {
-                        p += 2;
-                    }
-                    else {
-                        ++p;
-                    }
-                    *q = LF;
-                    ++q;
-                }
-                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {
-                    if ( *(p+1) == CR ) {
-                        p += 2;
-                    }
-                    else {
-                        ++p;
-                    }
-                    *q = LF;
-                    ++q;
-                }
-                else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {
-                    // Entities handled by tinyXML2:
-                    // - special entities in the entity table [in/out]
-                    // - numeric character reference [in]
-                    //   &#20013; or &#x4e2d;
-
-                    if ( *(p+1) == '#' ) {
-                        const int buflen = 10;
-                        char buf[buflen] = { 0 };
-                        int len = 0;
-                        const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
-                        if ( adjusted == 0 ) {
-                            *q = *p;
-                            ++p;
-                            ++q;
-                        }
-                        else {
-                            TIXMLASSERT( 0 <= len && len <= buflen );
-                            TIXMLASSERT( q + len <= adjusted );
-                            p = adjusted;
-                            memcpy( q, buf, len );
-                            q += len;
-                        }
-                    }
-                    else {
-                        bool entityFound = false;
-                        for( int i = 0; i < NUM_ENTITIES; ++i ) {
-                            const Entity& entity = entities[i];
-                            if ( strncmp( p + 1, entity.pattern, entity.length ) == 0
-                                    && *( p + entity.length + 1 ) == ';' ) {
-                                // Found an entity - convert.
-                                *q = entity.value;
-                                ++q;
-                                p += entity.length + 2;
-                                entityFound = true;
-                                break;
-                            }
-                        }
-                        if ( !entityFound ) {
-                            // fixme: treat as error?
-                            ++p;
-                            ++q;
-                        }
-                    }
-                }
-                else {
-                    *q = *p;
-                    ++p;
-                    ++q;
-                }
-            }
-            *q = 0;
-        }
-        // The loop below has plenty going on, and this
-        // is a less useful mode. Break it out.
-        if ( _flags & NEEDS_WHITESPACE_COLLAPSING ) {
-            CollapseWhitespace();
-        }
-        _flags = (_flags & NEEDS_DELETE);
-    }
-    TIXMLASSERT( _start );
-    return _start;
-}
-
-
-
-
-// --------- XMLUtil ----------- //
-
-const char* XMLUtil::writeBoolTrue  = "true";
-const char* XMLUtil::writeBoolFalse = "false";
-
-void XMLUtil::SetBoolSerialization(const char* writeTrue, const char* writeFalse)
-{
-	static const char* defTrue  = "true";
-	static const char* defFalse = "false";
-
-	writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
-	writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
-}
-
-
-const char* XMLUtil::ReadBOM( const char* p, bool* bom )
-{
-    TIXMLASSERT( p );
-    TIXMLASSERT( bom );
-    *bom = false;
-    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
-    // Check for BOM:
-    if (    *(pu+0) == TIXML_UTF_LEAD_0
-            && *(pu+1) == TIXML_UTF_LEAD_1
-            && *(pu+2) == TIXML_UTF_LEAD_2 ) {
-        *bom = true;
-        p += 3;
-    }
-    TIXMLASSERT( p );
-    return p;
-}
-
-
-void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
-{
-    const unsigned long BYTE_MASK = 0xBF;
-    const unsigned long BYTE_MARK = 0x80;
-    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-
-    if (input < 0x80) {
-        *length = 1;
-    }
-    else if ( input < 0x800 ) {
-        *length = 2;
-    }
-    else if ( input < 0x10000 ) {
-        *length = 3;
-    }
-    else if ( input < 0x200000 ) {
-        *length = 4;
-    }
-    else {
-        *length = 0;    // This code won't convert this correctly anyway.
-        return;
-    }
-
-    output += *length;
-
-    // Scary scary fall throughs are annotated with carefully designed comments
-    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
-    switch (*length) {
-        case 4:
-            --output;
-            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
-            input >>= 6;
-            //fall through
-        case 3:
-            --output;
-            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
-            input >>= 6;
-            //fall through
-        case 2:
-            --output;
-            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
-            input >>= 6;
-            //fall through
-        case 1:
-            --output;
-            *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
-            break;
-        default:
-            TIXMLASSERT( false );
-    }
-}
-
-
-const char* XMLUtil::GetCharacterRef(const char* p, char* value, int* length)
-{
-    // Assume an entity, and pull it out.
-    *length = 0;
-
-    static const uint32_t MAX_CODE_POINT = 0x10FFFF;
-
-    if (*(p + 1) == '#' && *(p + 2)) {
-        uint32_t ucs = 0;
-        ptrdiff_t delta = 0;
-        uint32_t mult = 1;
-        static const char SEMICOLON = ';';
-
-        bool hex = false;
-        uint32_t radix = 10;
-        const char* q = 0;
-        char terminator = '#';
-
-        if (*(p + 2) == 'x') {
-            // Hexadecimal.
-            hex = true;
-            radix = 16;
-            terminator = 'x';
-
-            q = p + 3;
-        }
-        else {
-            // Decimal.
-            q = p + 2;
-        }
-        if (!(*q)) {
-            return 0;
-        }
-
-        q = strchr(q, SEMICOLON);
-        if (!q) {
-            return 0;
-        }
-        TIXMLASSERT(*q == SEMICOLON);
-
-        delta = q - p;
-        --q;
-
-        while (*q != terminator) {
-            uint32_t digit = 0;
-
-            if (*q >= '0' && *q <= '9') {
-                digit = *q - '0';
-            }
-            else if (hex && (*q >= 'a' && *q <= 'f')) {
-                digit = *q - 'a' + 10;
-            }
-            else if (hex && (*q >= 'A' && *q <= 'F')) {
-                digit = *q - 'A' + 10;
-            }
-            else {
-                return 0;
-            }
-            TIXMLASSERT(digit < radix);
-
-            const unsigned int digitScaled = mult * digit;
-            ucs += digitScaled;
-            mult *= radix;       
-            
-            // Security check: could a value exist that is out of range?
-            // Easily; limit to the MAX_CODE_POINT, which also allows for a
-            // bunch of leading zeroes.
-            if (mult > MAX_CODE_POINT) {
-                mult = MAX_CODE_POINT;
-            }
-            --q;
-        }
-        // Out of range:
-        if (ucs > MAX_CODE_POINT) {
-            return 0;
-        }
-        // convert the UCS to UTF-8
-        ConvertUTF32ToUTF8(ucs, value, length);
-		if (length == 0) {
-            // If length is 0, there was an error. (Security? Bad input?)
-            // Fail safely.
-			return 0;
-		}
-        return p + delta + 1;
-    }
-    return p + 1;
-}
-
-void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%d", v );
-}
-
-
-void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%u", v );
-}
-
-
-void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%s", v ? writeBoolTrue : writeBoolFalse);
-}
-
-/*
-	ToStr() of a number is a very tricky topic.
-	https://github.com/leethomason/tinyxml2/issues/106
-*/
-void XMLUtil::ToStr( float v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%.8g", v );
-}
-
-
-void XMLUtil::ToStr( double v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%.17g", v );
-}
-
-
-void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
-{
-	// horrible syntax trick to make the compiler happy about %lld
-	TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
-}
-
-void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
-{
-    // horrible syntax trick to make the compiler happy about %llu
-    TIXML_SNPRINTF(buffer, bufferSize, "%llu", static_cast<unsigned long long>(v));
-}
-
-bool XMLUtil::ToInt(const char* str, int* value)
-{
-    if (IsPrefixHex(str)) {
-        unsigned v;
-        if (TIXML_SSCANF(str, "%x", &v) == 1) {
-            *value = static_cast<int>(v);
-            return true;
-        }
-    }
-    else {
-        if (TIXML_SSCANF(str, "%d", value) == 1) {
-            return true;
-        }
-    }
-    return false;
-}
-
-bool XMLUtil::ToUnsigned(const char* str, unsigned* value)
-{
-    if (TIXML_SSCANF(str, IsPrefixHex(str) ? "%x" : "%u", value) == 1) {
-        return true;
-    }
-    return false;
-}
-
-bool XMLUtil::ToBool( const char* str, bool* value )
-{
-    int ival = 0;
-    if ( ToInt( str, &ival )) {
-        *value = (ival==0) ? false : true;
-        return true;
-    }
-    static const char* TRUE_VALS[] = { "true", "True", "TRUE", 0 };
-    static const char* FALSE_VALS[] = { "false", "False", "FALSE", 0 };
-
-    for (int i = 0; TRUE_VALS[i]; ++i) {
-        if (StringEqual(str, TRUE_VALS[i])) {
-            *value = true;
-            return true;
-        }
-    }
-    for (int i = 0; FALSE_VALS[i]; ++i) {
-        if (StringEqual(str, FALSE_VALS[i])) {
-            *value = false;
-            return true;
-        }
-    }
-    return false;
-}
-
-
-bool XMLUtil::ToFloat( const char* str, float* value )
-{
-    if ( TIXML_SSCANF( str, "%f", value ) == 1 ) {
-        return true;
-    }
-    return false;
-}
-
-
-bool XMLUtil::ToDouble( const char* str, double* value )
-{
-    if ( TIXML_SSCANF( str, "%lf", value ) == 1 ) {
-        return true;
-    }
-    return false;
-}
-
-
-bool XMLUtil::ToInt64(const char* str, int64_t* value)
-{
-    if (IsPrefixHex(str)) {
-        unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llx
-        if (TIXML_SSCANF(str, "%llx", &v) == 1) {
-            *value = static_cast<int64_t>(v);
-            return true;
-        }
-    }
-    else {
-        long long v = 0;	// horrible syntax trick to make the compiler happy about %lld
-        if (TIXML_SSCANF(str, "%lld", &v) == 1) {
-            *value = static_cast<int64_t>(v);
-            return true;
-        }
-    }
-	return false;
-}
-
-
-bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
-    unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llu
-    if(TIXML_SSCANF(str, IsPrefixHex(str) ? "%llx" : "%llu", &v) == 1) {
-        *value = static_cast<uint64_t>(v);
-        return true;
-    }
-    return false;
-}
-
-
-char* XMLDocument::Identify( char* p, XMLNode** node, bool first )
-{
-    TIXMLASSERT( node );
-    TIXMLASSERT( p );
-    char* const start = p;
-    int const startLine = _parseCurLineNum;
-    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
-    if( !*p ) {
-        *node = 0;
-        TIXMLASSERT( p );
-        return p;
-    }
-
-    // These strings define the matching patterns:
-    static const char* xmlHeader		= { "<?" };
-    static const char* commentHeader	= { "<!--" };
-    static const char* cdataHeader		= { "<![CDATA[" };
-    static const char* dtdHeader		= { "<!" };
-    static const char* elementHeader	= { "<" };	// and a header for everything else; check last.
-
-    static const int xmlHeaderLen		= 2;
-    static const int commentHeaderLen	= 4;
-    static const int cdataHeaderLen		= 9;
-    static const int dtdHeaderLen		= 2;
-    static const int elementHeaderLen	= 1;
-
-    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );		// use same memory pool
-    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );	// use same memory pool
-    XMLNode* returnNode = 0;
-    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {
-        returnNode = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += xmlHeaderLen;
-    }
-    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {
-        returnNode = CreateUnlinkedNode<XMLComment>( _commentPool );
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += commentHeaderLen;
-    }
-    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {
-        XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
-        returnNode = text;
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += cdataHeaderLen;
-        text->SetCData( true );
-    }
-    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {
-        returnNode = CreateUnlinkedNode<XMLUnknown>( _commentPool );
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += dtdHeaderLen;
-    }
-    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {
-
-        // Preserve whitespace pedantically before closing tag, when it's immediately after opening tag
-        if (WhitespaceMode() == PEDANTIC_WHITESPACE && first && p != start && *(p + elementHeaderLen) == '/') {
-            returnNode = CreateUnlinkedNode<XMLText>(_textPool);
-            returnNode->_parseLineNum = startLine;
-            p = start;	// Back it up, all the text counts.
-            _parseCurLineNum = startLine;
-        }
-        else {
-            returnNode = CreateUnlinkedNode<XMLElement>(_elementPool);
-            returnNode->_parseLineNum = _parseCurLineNum;
-            p += elementHeaderLen;
-        }
-    }
-    else {
-        returnNode = CreateUnlinkedNode<XMLText>( _textPool );
-        returnNode->_parseLineNum = _parseCurLineNum; // Report line of first non-whitespace character
-        p = start;	// Back it up, all the text counts.
-        _parseCurLineNum = startLine;
-    }
-
-    TIXMLASSERT( returnNode );
-    TIXMLASSERT( p );
-    *node = returnNode;
-    return p;
-}
-
-
-bool XMLDocument::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    if ( visitor->VisitEnter( *this ) ) {
-        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
-            if ( !node->Accept( visitor ) ) {
-                break;
-            }
-        }
-    }
-    return visitor->VisitExit( *this );
-}
-
-
-// --------- XMLNode ----------- //
-
-XMLNode::XMLNode( XMLDocument* doc ) :
-    _document( doc ),
-    _parent( 0 ),
-    _value(),
-    _parseLineNum( 0 ),
-    _firstChild( 0 ), _lastChild( 0 ),
-    _prev( 0 ), _next( 0 ),
-	_userData( 0 ),
-    _memPool( 0 )
-{
-}
-
-
-XMLNode::~XMLNode()
-{
-    DeleteChildren();
-    if ( _parent ) {
-        _parent->Unlink( this );
-    }
-}
-
-// ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.
-
-int XMLNode::ChildElementCount(const char *value) const {
-	int count = 0;
-
-	const XMLElement *e = FirstChildElement(value);
-
-	while (e) {
-		e = e->NextSiblingElement(value);
-		count++;
-	}
-
-	return count;
-}
-
-int XMLNode::ChildElementCount() const {
-	int count = 0;
-
-	const XMLElement *e = FirstChildElement();
-
-	while (e) {
-		e = e->NextSiblingElement();
-		count++;
-	}
-
-	return count;
-}
-
-const char* XMLNode::Value() const
-{
-    // Edge case: XMLDocuments don't have a Value. Return null.
-    if ( this->ToDocument() )
-        return 0;
-    return _value.GetStr();
-}
-
-void XMLNode::SetValue( const char* str, bool staticMem )
-{
-    if ( staticMem ) {
-        _value.SetInternedStr( str );
-    }
-    else {
-        _value.SetStr( str );
-    }
-}
-
-XMLNode* XMLNode::DeepClone(XMLDocument* target) const
-{
-	XMLNode* clone = this->ShallowClone(target);
-	if (!clone) return 0;
-
-	for (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {
-		XMLNode* childClone = child->DeepClone(target);
-		TIXMLASSERT(childClone);
-		clone->InsertEndChild(childClone);
-	}
-	return clone;
-}
-
-void XMLNode::DeleteChildren()
-{
-    while( _firstChild ) {
-        TIXMLASSERT( _lastChild );
-        DeleteChild( _firstChild );
-    }
-    _firstChild = _lastChild = 0;
-}
-
-
-void XMLNode::Unlink( XMLNode* child )
-{
-    TIXMLASSERT( child );
-    TIXMLASSERT( child->_document == _document );
-    TIXMLASSERT( child->_parent == this );
-    if ( child == _firstChild ) {
-        _firstChild = _firstChild->_next;
-    }
-    if ( child == _lastChild ) {
-        _lastChild = _lastChild->_prev;
-    }
-
-    if ( child->_prev ) {
-        child->_prev->_next = child->_next;
-    }
-    if ( child->_next ) {
-        child->_next->_prev = child->_prev;
-    }
-	child->_next = 0;
-	child->_prev = 0;
-	child->_parent = 0;
-}
-
-
-void XMLNode::DeleteChild( XMLNode* node )
-{
-    TIXMLASSERT( node );
-    TIXMLASSERT( node->_document == _document );
-    TIXMLASSERT( node->_parent == this );
-    Unlink( node );
-	TIXMLASSERT(node->_prev == 0);
-	TIXMLASSERT(node->_next == 0);
-	TIXMLASSERT(node->_parent == 0);
-    DeleteNode( node );
-}
-
-
-XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )
-{
-    TIXMLASSERT( addThis );
-    if ( addThis->_document != _document ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-    InsertChildPreamble( addThis );
-
-    if ( _lastChild ) {
-        TIXMLASSERT( _firstChild );
-        TIXMLASSERT( _lastChild->_next == 0 );
-        _lastChild->_next = addThis;
-        addThis->_prev = _lastChild;
-        _lastChild = addThis;
-
-        addThis->_next = 0;
-    }
-    else {
-        TIXMLASSERT( _firstChild == 0 );
-        _firstChild = _lastChild = addThis;
-
-        addThis->_prev = 0;
-        addThis->_next = 0;
-    }
-    addThis->_parent = this;
-    return addThis;
-}
-
-
-XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )
-{
-    TIXMLASSERT( addThis );
-    if ( addThis->_document != _document ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-    InsertChildPreamble( addThis );
-
-    if ( _firstChild ) {
-        TIXMLASSERT( _lastChild );
-        TIXMLASSERT( _firstChild->_prev == 0 );
-
-        _firstChild->_prev = addThis;
-        addThis->_next = _firstChild;
-        _firstChild = addThis;
-
-        addThis->_prev = 0;
-    }
-    else {
-        TIXMLASSERT( _lastChild == 0 );
-        _firstChild = _lastChild = addThis;
-
-        addThis->_prev = 0;
-        addThis->_next = 0;
-    }
-    addThis->_parent = this;
-    return addThis;
-}
-
-
-XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )
-{
-    TIXMLASSERT( addThis );
-    if ( addThis->_document != _document ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-
-    TIXMLASSERT( afterThis );
-
-    if ( afterThis->_parent != this ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-    if ( afterThis == addThis ) {
-        // Current state: BeforeThis -> AddThis -> OneAfterAddThis
-        // Now AddThis must disappear from it's location and then
-        // reappear between BeforeThis and OneAfterAddThis.
-        // So just leave it where it is.
-        return addThis;
-    }
-
-    if ( afterThis->_next == 0 ) {
-        // The last node or the only node.
-        return InsertEndChild( addThis );
-    }
-    InsertChildPreamble( addThis );
-    addThis->_prev = afterThis;
-    addThis->_next = afterThis->_next;
-    afterThis->_next->_prev = addThis;
-    afterThis->_next = addThis;
-    addThis->_parent = this;
-    return addThis;
-}
-
-
-
-
-const XMLElement* XMLNode::FirstChildElement( const char* name ) const
-{
-    for( const XMLNode* node = _firstChild; node; node = node->_next ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-const XMLElement* XMLNode::LastChildElement( const char* name ) const
-{
-    for( const XMLNode* node = _lastChild; node; node = node->_prev ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-const XMLElement* XMLNode::NextSiblingElement( const char* name ) const
-{
-    for( const XMLNode* node = _next; node; node = node->_next ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const
-{
-    for( const XMLNode* node = _prev; node; node = node->_prev ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
-{
-    // This is a recursive method, but thinking about it "at the current level"
-    // it is a pretty simple flat list:
-    //		<foo/>
-    //		<!-- comment -->
-    //
-    // With a special case:
-    //		<foo>
-    //		</foo>
-    //		<!-- comment -->
-    //
-    // Where the closing element (/foo) *must* be the next thing after the opening
-    // element, and the names must match. BUT the tricky bit is that the closing
-    // element will be read by the child.
-    //
-    // 'endTag' is the end tag for this node, it is returned by a call to a child.
-    // 'parentEnd' is the end tag for the parent, which is filled in and returned.
-
-	XMLDocument::DepthTracker tracker(_document);
-	if (_document->Error())
-		return 0;
-
-	bool first = true;
-	while( p && *p ) {
-        XMLNode* node = 0;
-
-        p = _document->Identify( p, &node, first );
-        TIXMLASSERT( p );
-        if ( node == 0 ) {
-            break;
-        }
-        first = false;
-
-       const int initialLineNum = node->_parseLineNum;
-
-        StrPair endTag;
-        p = node->ParseDeep( p, &endTag, curLineNumPtr );
-        if ( !p ) {
-            _document->DeleteNode( node );
-            if ( !_document->Error() ) {
-                _document->SetError( XML_ERROR_PARSING, initialLineNum, 0);
-            }
-            break;
-        }
-
-        const XMLDeclaration* const decl = node->ToDeclaration();
-        if ( decl ) {
-            // Declarations are only allowed at document level
-            //
-            // Multiple declarations are allowed but all declarations
-            // must occur before anything else. 
-            //
-            // Optimized due to a security test case. If the first node is 
-            // a declaration, and the last node is a declaration, then only 
-            // declarations have so far been added.
-            bool wellLocated = false;
-
-            if (ToDocument()) {
-                if (FirstChild()) {
-                    wellLocated =
-                        FirstChild() &&
-                        FirstChild()->ToDeclaration() &&
-                        LastChild() &&
-                        LastChild()->ToDeclaration();
-                }
-                else {
-                    wellLocated = true;
-                }
-            }
-            if ( !wellLocated ) {
-                _document->SetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, "XMLDeclaration value=%s", decl->Value());
-                _document->DeleteNode( node );
-                break;
-            }
-        }
-
-        XMLElement* ele = node->ToElement();
-        if ( ele ) {
-            // We read the end tag. Return it to the parent.
-            if ( ele->ClosingType() == XMLElement::CLOSING ) {
-                if ( parentEndTag ) {
-                    ele->_value.TransferTo( parentEndTag );
-                }
-                node->_memPool->SetTracked();   // created and then immediately deleted.
-                DeleteNode( node );
-                return p;
-            }
-
-            // Handle an end tag returned to this level.
-            // And handle a bunch of annoying errors.
-            bool mismatch = false;
-            if ( endTag.Empty() ) {
-                if ( ele->ClosingType() == XMLElement::OPEN ) {
-                    mismatch = true;
-                }
-            }
-            else {
-                if ( ele->ClosingType() != XMLElement::OPEN ) {
-                    mismatch = true;
-                }
-                else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele->Name() ) ) {
-                    mismatch = true;
-                }
-            }
-            if ( mismatch ) {
-                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, "XMLElement name=%s", ele->Name());
-                _document->DeleteNode( node );
-                break;
-            }
-        }
-        InsertEndChild( node );
-    }
-    return 0;
-}
-
-/*static*/ void XMLNode::DeleteNode( XMLNode* node )
-{
-    if ( node == 0 ) {
-        return;
-    }
-	TIXMLASSERT(node->_document);
-	if (!node->ToDocument()) {
-		node->_document->MarkInUse(node);
-	}
-
-    MemPool* pool = node->_memPool;
-    node->~XMLNode();
-    pool->Free( node );
-}
-
-void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const
-{
-    TIXMLASSERT( insertThis );
-    TIXMLASSERT( insertThis->_document == _document );
-
-	if (insertThis->_parent) {
-        insertThis->_parent->Unlink( insertThis );
-	}
-	else {
-		insertThis->_document->MarkInUse(insertThis);
-        insertThis->_memPool->SetTracked();
-	}
-}
-
-const XMLElement* XMLNode::ToElementWithName( const char* name ) const
-{
-    const XMLElement* element = this->ToElement();
-    if ( element == 0 ) {
-        return 0;
-    }
-    if ( name == 0 ) {
-        return element;
-    }
-    if ( XMLUtil::StringEqual( element->Name(), name ) ) {
-       return element;
-    }
-    return 0;
-}
-
-// --------- XMLText ---------- //
-char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
-{
-    if ( this->CData() ) {
-        p = _value.ParseText( p, "]]>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
-        if ( !p ) {
-            _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );
-        }
-        return p;
-    }
-    else {
-        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
-        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {
-            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
-        }
-
-        p = _value.ParseText( p, "<", flags, curLineNumPtr );
-        if ( p && *p ) {
-            return p-1;
-        }
-        if ( !p ) {
-            _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );
-        }
-    }
-    return 0;
-}
-
-
-XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLText* text = doc->NewText( Value() );	// fixme: this will always allocate memory. Intern?
-    text->SetCData( this->CData() );
-    return text;
-}
-
-
-bool XMLText::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLText* text = compare->ToText();
-    return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );
-}
-
-
-bool XMLText::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-
-// --------- XMLComment ---------- //
-
-XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )
-{
-}
-
-
-XMLComment::~XMLComment()
-{
-}
-
-
-char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
-{
-    // Comment parses as text.
-    p = _value.ParseText( p, "-->", StrPair::COMMENT, curLineNumPtr );
-    if ( p == 0 ) {
-        _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );
-    }
-    return p;
-}
-
-
-XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLComment* comment = doc->NewComment( Value() );	// fixme: this will always allocate memory. Intern?
-    return comment;
-}
-
-
-bool XMLComment::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLComment* comment = compare->ToComment();
-    return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));
-}
-
-
-bool XMLComment::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-
-// --------- XMLDeclaration ---------- //
-
-XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )
-{
-}
-
-
-XMLDeclaration::~XMLDeclaration()
-{
-    //printf( "~XMLDeclaration\n" );
-}
-
-
-char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
-{
-    // Declaration parses as text.
-    p = _value.ParseText( p, "?>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
-    if ( p == 0 ) {
-        _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );
-    }
-    return p;
-}
-
-
-XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLDeclaration* dec = doc->NewDeclaration( Value() );	// fixme: this will always allocate memory. Intern?
-    return dec;
-}
-
-
-bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLDeclaration* declaration = compare->ToDeclaration();
-    return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));
-}
-
-
-
-bool XMLDeclaration::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-// --------- XMLUnknown ---------- //
-
-XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )
-{
-}
-
-
-XMLUnknown::~XMLUnknown()
-{
-}
-
-
-char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
-{
-    // Unknown parses as text.
-    p = _value.ParseText( p, ">", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
-    if ( !p ) {
-        _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );
-    }
-    return p;
-}
-
-
-XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLUnknown* text = doc->NewUnknown( Value() );	// fixme: this will always allocate memory. Intern?
-    return text;
-}
-
-
-bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLUnknown* unknown = compare->ToUnknown();
-    return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));
-}
-
-
-bool XMLUnknown::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-// --------- XMLAttribute ---------- //
-
-const char* XMLAttribute::Name() const
-{
-    return _name.GetStr();
-}
-
-const char* XMLAttribute::Value() const
-{
-    return _value.GetStr();
-}
-
-char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )
-{
-    // Parse using the name rules: bug fix, was using ParseText before
-    p = _name.ParseName( p );
-    if ( !p || !*p ) {
-        return 0;
-    }
-
-    // Skip white space before =
-    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-    if ( *p != '=' ) {
-        return 0;
-    }
-
-    ++p;	// move up to opening quote
-    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-    if ( *p != '\"' && *p != '\'' ) {
-        return 0;
-    }
-
-    const char endTag[2] = { *p, 0 };
-    ++p;	// move past opening quote
-
-    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );
-    return p;
-}
-
-
-void XMLAttribute::SetName( const char* n )
-{
-    _name.SetStr( n );
-}
-
-
-XMLError XMLAttribute::QueryIntValue( int* value ) const
-{
-    if ( XMLUtil::ToInt( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
-}
-
-
-XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const
-{
-    if ( XMLUtil::ToUnsigned( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
-}
-
-
-XMLError XMLAttribute::QueryInt64Value(int64_t* value) const
-{
-	if (XMLUtil::ToInt64(Value(), value)) {
-		return XML_SUCCESS;
-	}
-	return XML_WRONG_ATTRIBUTE_TYPE;
-}
-
-
-XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const
-{
-    if(XMLUtil::ToUnsigned64(Value(), value)) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
-}
-
-
-XMLError XMLAttribute::QueryBoolValue( bool* value ) const
-{
-    if ( XMLUtil::ToBool( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
-}
-
-
-XMLError XMLAttribute::QueryFloatValue( float* value ) const
-{
-    if ( XMLUtil::ToFloat( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
-}
-
-
-XMLError XMLAttribute::QueryDoubleValue( double* value ) const
-{
-    if ( XMLUtil::ToDouble( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
-}
-
-
-void XMLAttribute::SetAttribute( const char* v )
-{
-    _value.SetStr( v );
-}
-
-
-void XMLAttribute::SetAttribute( int v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
-}
-
-
-void XMLAttribute::SetAttribute( unsigned v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
-}
-
-
-void XMLAttribute::SetAttribute(int64_t v)
-{
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	_value.SetStr(buf);
-}
-
-void XMLAttribute::SetAttribute(uint64_t v)
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr(v, buf, BUF_SIZE);
-    _value.SetStr(buf);
-}
-
-
-void XMLAttribute::SetAttribute( bool v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
-}
-
-void XMLAttribute::SetAttribute( double v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
-}
-
-void XMLAttribute::SetAttribute( float v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
-}
-
-
-// --------- XMLElement ---------- //
-XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),
-    _closingType( OPEN ),
-    _rootAttribute( 0 )
-{
-}
-
-
-XMLElement::~XMLElement()
-{
-    while( _rootAttribute ) {
-        XMLAttribute* next = _rootAttribute->_next;
-        DeleteAttribute( _rootAttribute );
-        _rootAttribute = next;
-    }
-}
-
-
-const XMLAttribute* XMLElement::FindAttribute( const char* name ) const
-{
-    for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {
-        if ( XMLUtil::StringEqual( a->Name(), name ) ) {
-            return a;
-        }
-    }
-    return 0;
-}
-
-
-const char* XMLElement::Attribute( const char* name, const char* value ) const
-{
-    const XMLAttribute* a = FindAttribute( name );
-    if ( !a ) {
-        return 0;
-    }
-    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {
-        return a->Value();
-    }
-    return 0;
-}
-
-int XMLElement::IntAttribute(const char* name, int defaultValue) const
-{
-	int i = defaultValue;
-	QueryIntAttribute(name, &i);
-	return i;
-}
-
-unsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const
-{
-	unsigned i = defaultValue;
-	QueryUnsignedAttribute(name, &i);
-	return i;
-}
-
-int64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const
-{
-	int64_t i = defaultValue;
-	QueryInt64Attribute(name, &i);
-	return i;
-}
-
-uint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const
-{
-	uint64_t i = defaultValue;
-	QueryUnsigned64Attribute(name, &i);
-	return i;
-}
-
-bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const
-{
-	bool b = defaultValue;
-	QueryBoolAttribute(name, &b);
-	return b;
-}
-
-double XMLElement::DoubleAttribute(const char* name, double defaultValue) const
-{
-	double d = defaultValue;
-	QueryDoubleAttribute(name, &d);
-	return d;
-}
-
-float XMLElement::FloatAttribute(const char* name, float defaultValue) const
-{
-	float f = defaultValue;
-	QueryFloatAttribute(name, &f);
-	return f;
-}
-
-const char* XMLElement::GetText() const
-{
-    /* skip comment node */
-    const XMLNode* node = FirstChild();
-    while (node) {
-        if (node->ToComment()) {
-            node = node->NextSibling();
-            continue;
-        }
-        break;
-    }
-
-    if ( node && node->ToText() ) {
-        return node->Value();
-    }
-    return 0;
-}
-
-
-void	XMLElement::SetText( const char* inText )
-{
-	if ( FirstChild() && FirstChild()->ToText() )
-		FirstChild()->SetValue( inText );
-	else {
-		XMLText*	theText = GetDocument()->NewText( inText );
-		InsertFirstChild( theText );
-	}
-}
-
-
-void XMLElement::SetText( int v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
-}
-
-
-void XMLElement::SetText( unsigned v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
-}
-
-
-void XMLElement::SetText(int64_t v)
-{
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	SetText(buf);
-}
-
-void XMLElement::SetText(uint64_t v) {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr(v, buf, BUF_SIZE);
-    SetText(buf);
-}
-
-
-void XMLElement::SetText( bool v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
-}
-
-
-void XMLElement::SetText( float v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
-}
-
-
-void XMLElement::SetText( double v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
-}
-
-
-XMLError XMLElement::QueryIntText( int* ival ) const
-{
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToInt( t, ival ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
-}
-
-
-XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const
-{
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToUnsigned( t, uval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
-}
-
-
-XMLError XMLElement::QueryInt64Text(int64_t* ival) const
-{
-	if (FirstChild() && FirstChild()->ToText()) {
-		const char* t = FirstChild()->Value();
-		if (XMLUtil::ToInt64(t, ival)) {
-			return XML_SUCCESS;
-		}
-		return XML_CAN_NOT_CONVERT_TEXT;
-	}
-	return XML_NO_TEXT_NODE;
-}
-
-
-XMLError XMLElement::QueryUnsigned64Text(uint64_t* uval) const
-{
-    if(FirstChild() && FirstChild()->ToText()) {
-        const char* t = FirstChild()->Value();
-        if(XMLUtil::ToUnsigned64(t, uval)) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
-}
-
-
-XMLError XMLElement::QueryBoolText( bool* bval ) const
-{
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToBool( t, bval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
-}
-
-
-XMLError XMLElement::QueryDoubleText( double* dval ) const
-{
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToDouble( t, dval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
-}
-
-
-XMLError XMLElement::QueryFloatText( float* fval ) const
-{
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToFloat( t, fval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
-}
-
-int XMLElement::IntText(int defaultValue) const
-{
-	int i = defaultValue;
-	QueryIntText(&i);
-	return i;
-}
-
-unsigned XMLElement::UnsignedText(unsigned defaultValue) const
-{
-	unsigned i = defaultValue;
-	QueryUnsignedText(&i);
-	return i;
-}
-
-int64_t XMLElement::Int64Text(int64_t defaultValue) const
-{
-	int64_t i = defaultValue;
-	QueryInt64Text(&i);
-	return i;
-}
-
-uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const
-{
-	uint64_t i = defaultValue;
-	QueryUnsigned64Text(&i);
-	return i;
-}
-
-bool XMLElement::BoolText(bool defaultValue) const
-{
-	bool b = defaultValue;
-	QueryBoolText(&b);
-	return b;
-}
-
-double XMLElement::DoubleText(double defaultValue) const
-{
-	double d = defaultValue;
-	QueryDoubleText(&d);
-	return d;
-}
-
-float XMLElement::FloatText(float defaultValue) const
-{
-	float f = defaultValue;
-	QueryFloatText(&f);
-	return f;
-}
-
-
-XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )
-{
-    XMLAttribute* last = 0;
-    XMLAttribute* attrib = 0;
-    for( attrib = _rootAttribute;
-            attrib;
-            last = attrib, attrib = attrib->_next ) {
-        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {
-            break;
-        }
-    }
-    if ( !attrib ) {
-        attrib = CreateAttribute();
-        TIXMLASSERT( attrib );
-        if ( last ) {
-            TIXMLASSERT( last->_next == 0 );
-            last->_next = attrib;
-        }
-        else {
-            TIXMLASSERT( _rootAttribute == 0 );
-            _rootAttribute = attrib;
-        }
-        attrib->SetName( name );
-    }
-    return attrib;
-}
-
-
-void XMLElement::DeleteAttribute( const char* name )
-{
-    XMLAttribute* prev = 0;
-    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {
-        if ( XMLUtil::StringEqual( name, a->Name() ) ) {
-            if ( prev ) {
-                prev->_next = a->_next;
-            }
-            else {
-                _rootAttribute = a->_next;
-            }
-            DeleteAttribute( a );
-            break;
-        }
-        prev = a;
-    }
-}
-
-
-char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )
-{
-    XMLAttribute* prevAttribute = 0;
-
-    // Read the attributes.
-    while( p ) {
-        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-        if ( !(*p) ) {
-            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, "XMLElement name=%s", Name() );
-            return 0;
-        }
-
-        // attribute.
-        if (XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
-            XMLAttribute* attrib = CreateAttribute();
-            TIXMLASSERT( attrib );
-            attrib->_parseLineNum = _document->_parseCurLineNum;
-
-            const int attrLineNum = attrib->_parseLineNum;
-
-            p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );
-            if ( !p || Attribute( attrib->Name() ) ) {
-                DeleteAttribute( attrib );
-                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, "XMLElement name=%s", Name() );
-                return 0;
-            }
-            // There is a minor bug here: if the attribute in the source xml
-            // document is duplicated, it will not be detected and the
-            // attribute will be doubly added. However, tracking the 'prevAttribute'
-            // avoids re-scanning the attribute list. Preferring performance for
-            // now, may reconsider in the future.
-            if ( prevAttribute ) {
-                TIXMLASSERT( prevAttribute->_next == 0 );
-                prevAttribute->_next = attrib;
-            }
-            else {
-                TIXMLASSERT( _rootAttribute == 0 );
-                _rootAttribute = attrib;
-            }
-            prevAttribute = attrib;
-        }
-        // end of the tag
-        else if ( *p == '>' ) {
-            ++p;
-            break;
-        }
-        // end of the tag
-        else if ( *p == '/' && *(p+1) == '>' ) {
-            _closingType = CLOSED;
-            return p+2;	// done; sealed element.
-        }
-        else {
-            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );
-            return 0;
-        }
-    }
-    return p;
-}
-
-void XMLElement::DeleteAttribute( XMLAttribute* attribute )
-{
-    if ( attribute == 0 ) {
-        return;
-    }
-    MemPool* pool = attribute->_memPool;
-    attribute->~XMLAttribute();
-    pool->Free( attribute );
-}
-
-XMLAttribute* XMLElement::CreateAttribute()
-{
-    TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );
-    XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();
-    TIXMLASSERT( attrib );
-    attrib->_memPool = &_document->_attributePool;
-    attrib->_memPool->SetTracked();
-    return attrib;
-}
-
-
-XMLElement* XMLElement::InsertNewChildElement(const char* name)
-{
-    XMLElement* node = _document->NewElement(name);
-    return InsertEndChild(node) ? node : 0;
-}
-
-XMLComment* XMLElement::InsertNewComment(const char* comment)
-{
-    XMLComment* node = _document->NewComment(comment);
-    return InsertEndChild(node) ? node : 0;
-}
-
-XMLText* XMLElement::InsertNewText(const char* text)
-{
-    XMLText* node = _document->NewText(text);
-    return InsertEndChild(node) ? node : 0;
-}
-
-XMLDeclaration* XMLElement::InsertNewDeclaration(const char* text)
-{
-    XMLDeclaration* node = _document->NewDeclaration(text);
-    return InsertEndChild(node) ? node : 0;
-}
-
-XMLUnknown* XMLElement::InsertNewUnknown(const char* text)
-{
-    XMLUnknown* node = _document->NewUnknown(text);
-    return InsertEndChild(node) ? node : 0;
-}
-
-
+      }
+      // There is a minor bug here: if the attribute in the source xml
+      // document is duplicated, it will not be detected and the
+      // attribute will be doubly added. However, tracking the 'prevAttribute'
+      // avoids re-scanning the attribute list. Preferring performance for
+      // now, may reconsider in the future.
+      if (prevAttribute) {
+        TIXMLASSERT(prevAttribute->_next == 0);
+        prevAttribute->_next = attrib;
+      } else {
+        TIXMLASSERT(_rootAttribute == 0);
+        _rootAttribute = attrib;
+      }
+      prevAttribute = attrib;
+    }
+    // end of the tag
+    else if (*p == '>') {
+      ++p;
+      break;
+    }
+    // end of the tag
+    else if (*p == '/' && *(p + 1) == '>') {
+      _closingType = CLOSED;
+      return p + 2;  // done; sealed element.
+    } else {
+      _document->SetError(XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0);
+      return 0;
+    }
+  }
+  return p;
+}
+
+void XMLElement::DeleteAttribute(XMLAttribute* attribute) {
+  if (attribute == 0) {
+    return;
+  }
+  MemPool* pool = attribute->_memPool;
+  attribute->~XMLAttribute();
+  pool->Free(attribute);
+}
+
+XMLAttribute* XMLElement::CreateAttribute() {
+  TIXMLASSERT(sizeof(XMLAttribute) == _document->_attributePool.ItemSize());
+  XMLAttribute* attrib = new (_document->_attributePool.Alloc()) XMLAttribute();
+  TIXMLASSERT(attrib);
+  attrib->_memPool = &_document->_attributePool;
+  attrib->_memPool->SetTracked();
+  return attrib;
+}
+
+XMLElement* XMLElement::InsertNewChildElement(const char* name) {
+  XMLElement* node = _document->NewElement(name);
+  return InsertEndChild(node) ? node : 0;
+}
+
+XMLComment* XMLElement::InsertNewComment(const char* comment) {
+  XMLComment* node = _document->NewComment(comment);
+  return InsertEndChild(node) ? node : 0;
+}
+
+XMLText* XMLElement::InsertNewText(const char* text) {
+  XMLText* node = _document->NewText(text);
+  return InsertEndChild(node) ? node : 0;
+}
+
+XMLDeclaration* XMLElement::InsertNewDeclaration(const char* text) {
+  XMLDeclaration* node = _document->NewDeclaration(text);
+  return InsertEndChild(node) ? node : 0;
+}
+
+XMLUnknown* XMLElement::InsertNewUnknown(const char* text) {
+  XMLUnknown* node = _document->NewUnknown(text);
+  return InsertEndChild(node) ? node : 0;
+}
 
 //
 //	<ele></ele>
 //	<ele>foo<b>bar</b></ele>
 //
-char* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
-{
-    // Read the element name.
-    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-
-    // The closing element is the </element> form. It is
-    // parsed just like a regular element then deleted from
-    // the DOM.
-    if ( *p == '/' ) {
-        _closingType = CLOSING;
-        ++p;
-    }
-
-    p = _value.ParseName( p );
-    if ( _value.Empty() ) {
-        return 0;
-    }
-
-    p = ParseAttributes( p, curLineNumPtr );
-    if ( !p || !*p || _closingType != OPEN ) {
-        return p;
-    }
-
-    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );
+char* XMLElement::ParseDeep(char* p, StrPair* parentEndTag,
+                            int* curLineNumPtr) {
+  // Read the element name.
+  p = XMLUtil::SkipWhiteSpace(p, curLineNumPtr);
+
+  // The closing element is the </element> form. It is
+  // parsed just like a regular element then deleted from
+  // the DOM.
+  if (*p == '/') {
+    _closingType = CLOSING;
+    ++p;
+  }
+
+  p = _value.ParseName(p);
+  if (_value.Empty()) {
+    return 0;
+  }
+
+  p = ParseAttributes(p, curLineNumPtr);
+  if (!p || !*p || _closingType != OPEN) {
     return p;
-}
-
-
-
-XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLElement* element = doc->NewElement( Value() );					// fixme: this will always allocate memory. Intern?
-    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {
-        element->SetAttribute( a->Name(), a->Value() );					// fixme: this will always allocate memory. Intern?
-    }
-    return element;
-}
-
-
-bool XMLElement::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLElement* other = compare->ToElement();
-    if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {
-
-        const XMLAttribute* a=FirstAttribute();
-        const XMLAttribute* b=other->FirstAttribute();
-
-        while ( a && b ) {
-            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {
-                return false;
-            }
-            a = a->Next();
-            b = b->Next();
-        }
-        if ( a || b ) {
-            // different count
-            return false;
-        }
-        return true;
-    }
-    return false;
-}
-
-
-bool XMLElement::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {
-        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
-            if ( !node->Accept( visitor ) ) {
-                break;
-            }
-        }
-    }
-    return visitor->VisitExit( *this );
-}
-
+  }
+
+  p = XMLNode::ParseDeep(p, parentEndTag, curLineNumPtr);
+  return p;
+}
+
+XMLNode* XMLElement::ShallowClone(XMLDocument* doc) const {
+  if (!doc) {
+    doc = _document;
+  }
+  XMLElement* element = doc->NewElement(
+      Value());  // fixme: this will always allocate memory. Intern?
+  for (const XMLAttribute* a = FirstAttribute(); a; a = a->Next()) {
+    element->SetAttribute(
+        a->Name(),
+        a->Value());  // fixme: this will always allocate memory. Intern?
+  }
+  return element;
+}
+
+bool XMLElement::ShallowEqual(const XMLNode* compare) const {
+  TIXMLASSERT(compare);
+  const XMLElement* other = compare->ToElement();
+  if (other && XMLUtil::StringEqual(other->Name(), Name())) {
+    const XMLAttribute* a = FirstAttribute();
+    const XMLAttribute* b = other->FirstAttribute();
+
+    while (a && b) {
+      if (!XMLUtil::StringEqual(a->Value(), b->Value())) {
+        return false;
+      }
+      a = a->Next();
+      b = b->Next();
+    }
+    if (a || b) {
+      // different count
+      return false;
+    }
+    return true;
+  }
+  return false;
+}
+
+bool XMLElement::Accept(XMLVisitor* visitor) const {
+  TIXMLASSERT(visitor);
+  if (visitor->VisitEnter(*this, _rootAttribute)) {
+    for (const XMLNode* node = FirstChild(); node; node = node->NextSibling()) {
+      if (!node->Accept(visitor)) {
+        break;
+      }
+    }
+  }
+  return visitor->VisitExit(*this);
+}
 
 // --------- XMLDocument ----------- //
 
@@ -2176,66 +1923,57 @@

     "XML_ERROR_PARSING",
     "XML_CAN_NOT_CONVERT_TEXT",
     "XML_NO_TEXT_NODE",
-	"XML_ELEMENT_DEPTH_EXCEEDED"
-};
-
-
-XMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :
-    XMLNode( 0 ),
-    _writeBOM( false ),
-    _processEntities( processEntities ),
-    _errorID(XML_SUCCESS),
-    _whitespaceMode( whitespaceMode ),
-    _errorStr(),
-    _errorLineNum( 0 ),
-    _charBuffer( 0 ),
-    _parseCurLineNum( 0 ),
-	_parsingDepth(0),
-    _unlinked(),
-    _elementPool(),
-    _attributePool(),
-    _textPool(),
-    _commentPool()
-{
-    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
-    _document = this;
-}
-
-
-XMLDocument::~XMLDocument()
-{
-    Clear();
-}
-
-
-void XMLDocument::MarkInUse(const XMLNode* const node)
-{
-	TIXMLASSERT(node);
-	TIXMLASSERT(node->_parent == 0);
-
-	for (size_t i = 0; i < _unlinked.Size(); ++i) {
-		if (node == _unlinked[i]) {
-			_unlinked.SwapRemove(i);
-			break;
-		}
-	}
-}
-
-void XMLDocument::Clear()
-{
-    DeleteChildren();
-	while( _unlinked.Size()) {
-		DeleteNode(_unlinked[0]);	// Will remove from _unlinked as part of delete.
-	}
+    "XML_ELEMENT_DEPTH_EXCEEDED"};
+
+XMLDocument::XMLDocument(bool processEntities, Whitespace whitespaceMode)
+    : XMLNode(0),
+      _writeBOM(false),
+      _processEntities(processEntities),
+      _errorID(XML_SUCCESS),
+      _whitespaceMode(whitespaceMode),
+      _errorStr(),
+      _errorLineNum(0),
+      _charBuffer(0),
+      _parseCurLineNum(0),
+      _parsingDepth(0),
+      _unlinked(),
+      _elementPool(),
+      _attributePool(),
+      _textPool(),
+      _commentPool() {
+  // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by
+  // default in VS2012+)
+  _document = this;
+}
+
+XMLDocument::~XMLDocument() { Clear(); }
+
+void XMLDocument::MarkInUse(const XMLNode* const node) {
+  TIXMLASSERT(node);
+  TIXMLASSERT(node->_parent == 0);
+
+  for (size_t i = 0; i < _unlinked.Size(); ++i) {
+    if (node == _unlinked[i]) {
+      _unlinked.SwapRemove(i);
+      break;
+    }
+  }
+}
+
+void XMLDocument::Clear() {
+  DeleteChildren();
+  while (_unlinked.Size()) {
+    DeleteNode(_unlinked[0]);  // Will remove from _unlinked as part of delete.
+  }
 
 #ifdef TINYXML2_DEBUG
-    const bool hadError = Error();
+  const bool hadError = Error();
 #endif
-    ClearError();
-
-    delete [] _charBuffer;
-    _charBuffer = 0;
-	_parsingDepth = 0;
+  ClearError();
+
+  delete[] _charBuffer;
+  _charBuffer = 0;
+  _parsingDepth = 0;
 
 #if 0
     _textPool.Trace( "text" );
@@ -2245,776 +1983,675 @@

 #endif
 
 #ifdef TINYXML2_DEBUG
-    if ( !hadError ) {
-        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );
-        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );
-        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );
-        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );
-    }
+  if (!hadError) {
+    TIXMLASSERT(_elementPool.CurrentAllocs() == _elementPool.Untracked());
+    TIXMLASSERT(_attributePool.CurrentAllocs() == _attributePool.Untracked());
+    TIXMLASSERT(_textPool.CurrentAllocs() == _textPool.Untracked());
+    TIXMLASSERT(_commentPool.CurrentAllocs() == _commentPool.Untracked());
+  }
 #endif
 }
 
-
-void XMLDocument::DeepCopy(XMLDocument* target) const
-{
-	TIXMLASSERT(target);
-    if (target == this) {
-        return; // technically success - a no-op.
-    }
-
-	target->Clear();
-	for (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {
-		target->InsertEndChild(node->DeepClone(target));
-	}
-}
-
-XMLElement* XMLDocument::NewElement( const char* name )
-{
-    XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );
-    ele->SetName( name );
-    return ele;
-}
-
-
-XMLComment* XMLDocument::NewComment( const char* str )
-{
-    XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );
-    comment->SetValue( str );
-    return comment;
-}
-
-
-XMLText* XMLDocument::NewText( const char* str )
-{
-    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
-    text->SetValue( str );
-    return text;
-}
-
-
-XMLDeclaration* XMLDocument::NewDeclaration( const char* str )
-{
-    XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
-    dec->SetValue( str ? str : "xml version=\"1.0\" encoding=\"UTF-8\"" );
-    return dec;
-}
-
-
-XMLUnknown* XMLDocument::NewUnknown( const char* str )
-{
-    XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );
-    unk->SetValue( str );
-    return unk;
-}
-
-static FILE* callfopen( const char* filepath, const char* mode )
-{
-    TIXMLASSERT( filepath );
-    TIXMLASSERT( mode );
-#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
-    FILE* fp = 0;
-    const errno_t err = fopen_s( &fp, filepath, mode );
-    if ( err ) {
-        return 0;
-    }
+void XMLDocument::DeepCopy(XMLDocument* target) const {
+  TIXMLASSERT(target);
+  if (target == this) {
+    return;  // technically success - a no-op.
+  }
+
+  target->Clear();
+  for (const XMLNode* node = this->FirstChild(); node;
+       node = node->NextSibling()) {
+    target->InsertEndChild(node->DeepClone(target));
+  }
+}
+
+XMLElement* XMLDocument::NewElement(const char* name) {
+  XMLElement* ele = CreateUnlinkedNode<XMLElement>(_elementPool);
+  ele->SetName(name);
+  return ele;
+}
+
+XMLComment* XMLDocument::NewComment(const char* str) {
+  XMLComment* comment = CreateUnlinkedNode<XMLComment>(_commentPool);
+  comment->SetValue(str);
+  return comment;
+}
+
+XMLText* XMLDocument::NewText(const char* str) {
+  XMLText* text = CreateUnlinkedNode<XMLText>(_textPool);
+  text->SetValue(str);
+  return text;
+}
+
+XMLDeclaration* XMLDocument::NewDeclaration(const char* str) {
+  XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>(_commentPool);
+  dec->SetValue(str ? str : "xml version=\"1.0\" encoding=\"UTF-8\"");
+  return dec;
+}
+
+XMLUnknown* XMLDocument::NewUnknown(const char* str) {
+  XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>(_commentPool);
+  unk->SetValue(str);
+  return unk;
+}
+
+static FILE* callfopen(const char* filepath, const char* mode) {
+  TIXMLASSERT(filepath);
+  TIXMLASSERT(mode);
+#if defined(_MSC_VER) && (_MSC_VER >= 1400) && (!defined WINCE)
+  FILE* fp = 0;
+  const errno_t err = fopen_s(&fp, filepath, mode);
+  if (err) {
+    return 0;
+  }
 #else
-    FILE* fp = fopen( filepath, mode );
+  FILE* fp = fopen(filepath, mode);
 #endif
-    return fp;
-}
-
-void XMLDocument::DeleteNode( XMLNode* node )	{
-    TIXMLASSERT( node );
-    TIXMLASSERT(node->_document == this );
-    if (node->_parent) {
-        node->_parent->DeleteChild( node );
-    }
-    else {
-        // Isn't in the tree.
-        // Use the parent delete.
-        // Also, we need to mark it tracked: we 'know'
-        // it was never used.
-        node->_memPool->SetTracked();
-        // Call the static XMLNode version:
-        XMLNode::DeleteNode(node);
-    }
-}
-
-
-XMLError XMLDocument::LoadFile( const char* filename )
-{
-    if ( !filename ) {
-        TIXMLASSERT( false );
-        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
-        return _errorID;
-    }
-
-    Clear();
-    FILE* fp = callfopen( filename, "rb" );
-    if ( !fp ) {
-        SetError( XML_ERROR_FILE_NOT_FOUND, 0, "filename=%s", filename );
-        return _errorID;
-    }
-    LoadFile( fp );
-    fclose( fp );
+  return fp;
+}
+
+void XMLDocument::DeleteNode(XMLNode* node) {
+  TIXMLASSERT(node);
+  TIXMLASSERT(node->_document == this);
+  if (node->_parent) {
+    node->_parent->DeleteChild(node);
+  } else {
+    // Isn't in the tree.
+    // Use the parent delete.
+    // Also, we need to mark it tracked: we 'know'
+    // it was never used.
+    node->_memPool->SetTracked();
+    // Call the static XMLNode version:
+    XMLNode::DeleteNode(node);
+  }
+}
+
+XMLError XMLDocument::LoadFile(const char* filename) {
+  if (!filename) {
+    TIXMLASSERT(false);
+    SetError(XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>");
     return _errorID;
-}
-
-XMLError XMLDocument::LoadFile( FILE* fp )
-{
-    Clear();
-
-    TIXML_FSEEK( fp, 0, SEEK_SET );
-    if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {
-        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-        return _errorID;
-    }
-
-    TIXML_FSEEK( fp, 0, SEEK_END );
-
-    unsigned long long filelength;
-    {
-        const long long fileLengthSigned = TIXML_FTELL( fp );
-        TIXML_FSEEK( fp, 0, SEEK_SET );
-        if ( fileLengthSigned == -1L ) {
-            SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-            return _errorID;
+  }
+
+  Clear();
+  FILE* fp = callfopen(filename, "rb");
+  if (!fp) {
+    SetError(XML_ERROR_FILE_NOT_FOUND, 0, "filename=%s", filename);
+    return _errorID;
+  }
+  LoadFile(fp);
+  fclose(fp);
+  return _errorID;
+}
+
+XMLError XMLDocument::LoadFile(FILE* fp) {
+  Clear();
+
+  TIXML_FSEEK(fp, 0, SEEK_SET);
+  if (fgetc(fp) == EOF && ferror(fp) != 0) {
+    SetError(XML_ERROR_FILE_READ_ERROR, 0, 0);
+    return _errorID;
+  }
+
+  TIXML_FSEEK(fp, 0, SEEK_END);
+
+  unsigned long long filelength;
+  {
+    const long long fileLengthSigned = TIXML_FTELL(fp);
+    TIXML_FSEEK(fp, 0, SEEK_SET);
+    if (fileLengthSigned == -1L) {
+      SetError(XML_ERROR_FILE_READ_ERROR, 0, 0);
+      return _errorID;
+    }
+    TIXMLASSERT(fileLengthSigned >= 0);
+    filelength = static_cast<unsigned long long>(fileLengthSigned);
+  }
+
+  const size_t maxSizeT = static_cast<size_t>(-1);
+  // We'll do the comparison as an unsigned long long, because that's guaranteed
+  // to be at least 8 bytes, even on a 32-bit platform.
+  if (filelength >= static_cast<unsigned long long>(maxSizeT)) {
+    // Cannot handle files which won't fit in buffer together with null
+    // terminator
+    SetError(XML_ERROR_FILE_READ_ERROR, 0, 0);
+    return _errorID;
+  }
+
+  if (filelength == 0) {
+    SetError(XML_ERROR_EMPTY_DOCUMENT, 0, 0);
+    return _errorID;
+  }
+
+  const size_t size = static_cast<size_t>(filelength);
+  TIXMLASSERT(_charBuffer == 0);
+  _charBuffer = new char[size + 1];
+  const size_t read = fread(_charBuffer, 1, size, fp);
+  if (read != size) {
+    SetError(XML_ERROR_FILE_READ_ERROR, 0, 0);
+    return _errorID;
+  }
+
+  _charBuffer[size] = 0;
+
+  Parse();
+  return _errorID;
+}
+
+XMLError XMLDocument::SaveFile(const char* filename, bool compact) {
+  if (!filename) {
+    TIXMLASSERT(false);
+    SetError(XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>");
+    return _errorID;
+  }
+
+  FILE* fp = callfopen(filename, "w");
+  if (!fp) {
+    SetError(XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=%s", filename);
+    return _errorID;
+  }
+  SaveFile(fp, compact);
+  fclose(fp);
+  return _errorID;
+}
+
+XMLError XMLDocument::SaveFile(FILE* fp, bool compact) {
+  // Clear any error from the last save, otherwise it will get reported
+  // for *this* call.
+  ClearError();
+  XMLPrinter stream(fp, compact);
+  Print(&stream);
+  return _errorID;
+}
+
+XMLError XMLDocument::Parse(const char* xml, size_t nBytes) {
+  Clear();
+
+  if (nBytes == 0 || !xml || !*xml) {
+    SetError(XML_ERROR_EMPTY_DOCUMENT, 0, 0);
+    return _errorID;
+  }
+  if (nBytes == static_cast<size_t>(-1)) {
+    nBytes = strlen(xml);
+  }
+  TIXMLASSERT(_charBuffer == 0);
+  _charBuffer = new char[nBytes + 1];
+  memcpy(_charBuffer, xml, nBytes);
+  _charBuffer[nBytes] = 0;
+
+  Parse();
+  if (Error()) {
+    // clean up now essentially dangling memory.
+    // and the parse fail can put objects in the
+    // pools that are dead and inaccessible.
+    DeleteChildren();
+    _elementPool.Clear();
+    _attributePool.Clear();
+    _textPool.Clear();
+    _commentPool.Clear();
+  }
+  return _errorID;
+}
+
+void XMLDocument::Print(XMLPrinter* streamer) const {
+  if (streamer) {
+    Accept(streamer);
+  } else {
+    XMLPrinter stdoutStreamer(stdout);
+    Accept(&stdoutStreamer);
+  }
+}
+
+void XMLDocument::ClearError() {
+  _errorID = XML_SUCCESS;
+  _errorLineNum = 0;
+  _errorStr.Reset();
+}
+
+void XMLDocument::SetError(XMLError error, int lineNum, const char* format,
+                           ...) {
+  TIXMLASSERT(error >= 0 && error < XML_ERROR_COUNT);
+  _errorID = error;
+  _errorLineNum = lineNum;
+  _errorStr.Reset();
+
+  const size_t BUFFER_SIZE = 1000;
+  char* buffer = new char[BUFFER_SIZE];
+
+  TIXMLASSERT(sizeof(error) <= sizeof(int));
+  TIXML_SNPRINTF(buffer, BUFFER_SIZE,
+                 "Error=%s ErrorID=%d (0x%x) Line number=%d",
+                 ErrorIDToName(error), static_cast<int>(error),
+                 static_cast<unsigned int>(error), lineNum);
+
+  if (format) {
+    size_t len = strlen(buffer);
+    TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, ": ");
+    len = strlen(buffer);
+
+    va_list va;
+    va_start(va, format);
+    TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
+    va_end(va);
+  }
+  _errorStr.SetStr(buffer);
+  delete[] buffer;
+}
+
+/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID) {
+  TIXMLASSERT(errorID >= 0 && errorID < XML_ERROR_COUNT);
+  const char* errorName = _errorNames[errorID];
+  TIXMLASSERT(errorName && errorName[0]);
+  return errorName;
+}
+
+const char* XMLDocument::ErrorStr() const {
+  return _errorStr.Empty() ? "" : _errorStr.GetStr();
+}
+
+void XMLDocument::PrintError() const { printf("%s\n", ErrorStr()); }
+
+const char* XMLDocument::ErrorName() const { return ErrorIDToName(_errorID); }
+
+void XMLDocument::Parse() {
+  TIXMLASSERT(NoChildren());  // Clear() must have been called previously
+  TIXMLASSERT(_charBuffer);
+  _parseCurLineNum = 1;
+  _parseLineNum = 1;
+  char* p = _charBuffer;
+  p = XMLUtil::SkipWhiteSpace(p, &_parseCurLineNum);
+  p = const_cast<char*>(XMLUtil::ReadBOM(p, &_writeBOM));
+  if (!*p) {
+    SetError(XML_ERROR_EMPTY_DOCUMENT, 0, 0);
+    return;
+  }
+  ParseDeep(p, 0, &_parseCurLineNum);
+}
+
+void XMLDocument::PushDepth() {
+  _parsingDepth++;
+  if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
+    SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum,
+             "Element nesting is too deep.");
+  }
+}
+
+void XMLDocument::PopDepth() {
+  TIXMLASSERT(_parsingDepth > 0);
+  --_parsingDepth;
+}
+
+XMLPrinter::XMLPrinter(FILE* file, bool compact, int depth)
+    : _elementJustOpened(false),
+      _stack(),
+      _firstElement(true),
+      _fp(file),
+      _depth(depth),
+      _textDepth(-1),
+      _processEntities(true),
+      _compactMode(compact),
+      _buffer() {
+  for (int i = 0; i < ENTITY_RANGE; ++i) {
+    _entityFlag[i] = false;
+    _restrictedEntityFlag[i] = false;
+  }
+  for (int i = 0; i < NUM_ENTITIES; ++i) {
+    const char entityValue = entities[i].value;
+    const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
+    TIXMLASSERT(flagIndex < ENTITY_RANGE);
+    _entityFlag[flagIndex] = true;
+  }
+  _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
+  _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
+  _restrictedEntityFlag[static_cast<unsigned char>('>')] =
+      true;  // not required, but consistency is nice
+  _buffer.Push(0);
+}
+
+void XMLPrinter::Print(const char* format, ...) {
+  va_list va;
+  va_start(va, format);
+
+  if (_fp) {
+    vfprintf(_fp, format, va);
+  } else {
+    const int len = TIXML_VSCPRINTF(format, va);
+    // Close out and re-start the va-args
+    va_end(va);
+    TIXMLASSERT(len >= 0);
+    va_start(va, format);
+    TIXMLASSERT(_buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0);
+    char* p = _buffer.PushArr(len) - 1;  // back up over the null terminator.
+    TIXML_VSNPRINTF(p, len + 1, format, va);
+  }
+  va_end(va);
+}
+
+void XMLPrinter::Write(const char* data, size_t size) {
+  if (_fp) {
+    fwrite(data, sizeof(char), size, _fp);
+  } else {
+    char* p = _buffer.PushArr(static_cast<int>(size)) -
+              1;  // back up over the null terminator.
+    memcpy(p, data, size);
+    p[size] = 0;
+  }
+}
+
+void XMLPrinter::Putc(char ch) {
+  if (_fp) {
+    fputc(ch, _fp);
+  } else {
+    char* p =
+        _buffer.PushArr(sizeof(char)) - 1;  // back up over the null terminator.
+    p[0] = ch;
+    p[1] = 0;
+  }
+}
+
+void XMLPrinter::PrintSpace(int depth) {
+  for (int i = 0; i < depth; ++i) {
+    Write("    ");
+  }
+}
+
+void XMLPrinter::PrintString(const char* p, bool restricted) {
+  // Look for runs of bytes between entities to print.
+  const char* q = p;
+
+  if (_processEntities) {
+    const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
+    while (*q) {
+      TIXMLASSERT(p <= q);
+      // Remember, char is sometimes signed. (How many times has that bitten
+      // me?)
+      if (*q > 0 && *q < ENTITY_RANGE) {
+        // Check for entities. If one is found, flush
+        // the stream up until the entity, write the
+        // entity, and keep looking.
+        if (flag[static_cast<unsigned char>(*q)]) {
+          while (p < q) {
+            const size_t delta = q - p;
+            const int toPrint =
+                (INT_MAX < delta) ? INT_MAX : static_cast<int>(delta);
+            Write(p, toPrint);
+            p += toPrint;
+          }
+          bool entityPatternPrinted = false;
+          for (int i = 0; i < NUM_ENTITIES; ++i) {
+            if (entities[i].value == *q) {
+              Putc('&');
+              Write(entities[i].pattern, entities[i].length);
+              Putc(';');
+              entityPatternPrinted = true;
+              break;
+            }
+          }
+          if (!entityPatternPrinted) {
+            // TIXMLASSERT( entityPatternPrinted ) causes gcc
+            // -Wunused-but-set-variable in release
+            TIXMLASSERT(false);
+          }
+          ++p;
         }
-        TIXMLASSERT( fileLengthSigned >= 0 );
-        filelength = static_cast<unsigned long long>(fileLengthSigned);
-    }
-
-    const size_t maxSizeT = static_cast<size_t>(-1);
-    // We'll do the comparison as an unsigned long long, because that's guaranteed to be at
-    // least 8 bytes, even on a 32-bit platform.
-    if ( filelength >= static_cast<unsigned long long>(maxSizeT) ) {
-        // Cannot handle files which won't fit in buffer together with null terminator
-        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-        return _errorID;
-    }
-
-    if ( filelength == 0 ) {
-        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
-        return _errorID;
-    }
-
-    const size_t size = static_cast<size_t>(filelength);
-    TIXMLASSERT( _charBuffer == 0 );
-    _charBuffer = new char[size+1];
-    const size_t read = fread( _charBuffer, 1, size, fp );
-    if ( read != size ) {
-        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-        return _errorID;
-    }
-
-    _charBuffer[size] = 0;
-
-    Parse();
-    return _errorID;
-}
-
-
-XMLError XMLDocument::SaveFile( const char* filename, bool compact )
-{
-    if ( !filename ) {
-        TIXMLASSERT( false );
-        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
-        return _errorID;
-    }
-
-    FILE* fp = callfopen( filename, "w" );
-    if ( !fp ) {
-        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=%s", filename );
-        return _errorID;
-    }
-    SaveFile(fp, compact);
-    fclose( fp );
-    return _errorID;
-}
-
-
-XMLError XMLDocument::SaveFile( FILE* fp, bool compact )
-{
-    // Clear any error from the last save, otherwise it will get reported
-    // for *this* call.
-    ClearError();
-    XMLPrinter stream( fp, compact );
-    Print( &stream );
-    return _errorID;
-}
-
-
-XMLError XMLDocument::Parse( const char* xml, size_t nBytes )
-{
-    Clear();
-
-    if ( nBytes == 0 || !xml || !*xml ) {
-        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
-        return _errorID;
-    }
-    if ( nBytes == static_cast<size_t>(-1) ) {
-        nBytes = strlen( xml );
-    }
-    TIXMLASSERT( _charBuffer == 0 );
-    _charBuffer = new char[ nBytes+1 ];
-    memcpy( _charBuffer, xml, nBytes );
-    _charBuffer[nBytes] = 0;
-
-    Parse();
-    if ( Error() ) {
-        // clean up now essentially dangling memory.
-        // and the parse fail can put objects in the
-        // pools that are dead and inaccessible.
-        DeleteChildren();
-        _elementPool.Clear();
-        _attributePool.Clear();
-        _textPool.Clear();
-        _commentPool.Clear();
-    }
-    return _errorID;
-}
-
-
-void XMLDocument::Print( XMLPrinter* streamer ) const
-{
-    if ( streamer ) {
-        Accept( streamer );
-    }
-    else {
-        XMLPrinter stdoutStreamer( stdout );
-        Accept( &stdoutStreamer );
-    }
-}
-
-
-void XMLDocument::ClearError() {
-    _errorID = XML_SUCCESS;
-    _errorLineNum = 0;
-    _errorStr.Reset();
-}
-
-
-void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )
-{
-    TIXMLASSERT(error >= 0 && error < XML_ERROR_COUNT);
-    _errorID = error;
-    _errorLineNum = lineNum;
-	_errorStr.Reset();
-
-    const size_t BUFFER_SIZE = 1000;
-    char* buffer = new char[BUFFER_SIZE];
-
-    TIXMLASSERT(sizeof(error) <= sizeof(int));
-    TIXML_SNPRINTF(buffer, BUFFER_SIZE, "Error=%s ErrorID=%d (0x%x) Line number=%d",
-        ErrorIDToName(error), static_cast<int>(error), static_cast<unsigned int>(error), lineNum);
-
-	if (format) {
-		size_t len = strlen(buffer);
-		TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, ": ");
-		len = strlen(buffer);
-
-		va_list va;
-		va_start(va, format);
-		TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
-		va_end(va);
-	}
-	_errorStr.SetStr(buffer);
-	delete[] buffer;
-}
-
-
-/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID)
-{
-	TIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );
-    const char* errorName = _errorNames[errorID];
-    TIXMLASSERT( errorName && errorName[0] );
-    return errorName;
-}
-
-const char* XMLDocument::ErrorStr() const
-{
-	return _errorStr.Empty() ? "" : _errorStr.GetStr();
-}
-
-
-void XMLDocument::PrintError() const
-{
-    printf("%s\n", ErrorStr());
-}
-
-const char* XMLDocument::ErrorName() const
-{
-    return ErrorIDToName(_errorID);
-}
-
-void XMLDocument::Parse()
-{
-    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously
-    TIXMLASSERT( _charBuffer );
-    _parseCurLineNum = 1;
-    _parseLineNum = 1;
-    char* p = _charBuffer;
-    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
-    p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );
-    if ( !*p ) {
-        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
-        return;
-    }
-    ParseDeep(p, 0, &_parseCurLineNum );
-}
-
-void XMLDocument::PushDepth()
-{
-	_parsingDepth++;
-	if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
-		SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, "Element nesting is too deep." );
-	}
-}
-
-void XMLDocument::PopDepth()
-{
-	TIXMLASSERT(_parsingDepth > 0);
-	--_parsingDepth;
-}
-
-XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :
-    _elementJustOpened( false ),
-    _stack(),
-    _firstElement( true ),
-    _fp( file ),
-    _depth( depth ),
-    _textDepth( -1 ),
-    _processEntities( true ),
-    _compactMode( compact ),
-    _buffer()
-{
-    for( int i=0; i<ENTITY_RANGE; ++i ) {
-        _entityFlag[i] = false;
-        _restrictedEntityFlag[i] = false;
-    }
-    for( int i=0; i<NUM_ENTITIES; ++i ) {
-        const char entityValue = entities[i].value;
-        const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
-        TIXMLASSERT( flagIndex < ENTITY_RANGE );
-        _entityFlag[flagIndex] = true;
-    }
-    _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
-    _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
-    _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;	// not required, but consistency is nice
-    _buffer.Push( 0 );
-}
-
-
-void XMLPrinter::Print( const char* format, ... )
-{
-    va_list     va;
-    va_start( va, format );
-
-    if ( _fp ) {
-        vfprintf( _fp, format, va );
-    }
-    else {
-        const int len = TIXML_VSCPRINTF( format, va );
-        // Close out and re-start the va-args
-        va_end( va );
-        TIXMLASSERT( len >= 0 );
-        va_start( va, format );
-        TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );
-        char* p = _buffer.PushArr( len ) - 1;	// back up over the null terminator.
-		TIXML_VSNPRINTF( p, len+1, format, va );
-    }
-    va_end( va );
-}
-
-
-void XMLPrinter::Write( const char* data, size_t size )
-{
-    if ( _fp ) {
-        fwrite ( data , sizeof(char), size, _fp);
-    }
-    else {
-        char* p = _buffer.PushArr( static_cast<int>(size) ) - 1;   // back up over the null terminator.
-        memcpy( p, data, size );
-        p[size] = 0;
-    }
-}
-
-
-void XMLPrinter::Putc( char ch )
-{
-    if ( _fp ) {
-        fputc ( ch, _fp);
-    }
-    else {
-        char* p = _buffer.PushArr( sizeof(char) ) - 1;   // back up over the null terminator.
-        p[0] = ch;
-        p[1] = 0;
-    }
-}
-
-
-void XMLPrinter::PrintSpace( int depth )
-{
-    for( int i=0; i<depth; ++i ) {
-        Write( "    " );
-    }
-}
-
-
-void XMLPrinter::PrintString( const char* p, bool restricted )
-{
-    // Look for runs of bytes between entities to print.
-    const char* q = p;
-
-    if ( _processEntities ) {
-        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
-        while ( *q ) {
-            TIXMLASSERT( p <= q );
-            // Remember, char is sometimes signed. (How many times has that bitten me?)
-            if ( *q > 0 && *q < ENTITY_RANGE ) {
-                // Check for entities. If one is found, flush
-                // the stream up until the entity, write the
-                // entity, and keep looking.
-                if ( flag[static_cast<unsigned char>(*q)] ) {
-                    while ( p < q ) {
-                        const size_t delta = q - p;
-                        const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
-                        Write( p, toPrint );
-                        p += toPrint;
-                    }
-                    bool entityPatternPrinted = false;
-                    for( int i=0; i<NUM_ENTITIES; ++i ) {
-                        if ( entities[i].value == *q ) {
-                            Putc( '&' );
-                            Write( entities[i].pattern, entities[i].length );
-                            Putc( ';' );
-                            entityPatternPrinted = true;
-                            break;
-                        }
-                    }
-                    if ( !entityPatternPrinted ) {
-                        // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release
-                        TIXMLASSERT( false );
-                    }
-                    ++p;
-                }
-            }
-            ++q;
-            TIXMLASSERT( p <= q );
-        }
-        // Flush the remaining string. This will be the entire
-        // string if an entity wasn't found.
-        if ( p < q ) {
-            const size_t delta = q - p;
-            const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
-            Write( p, toPrint );
-        }
-    }
-    else {
-        Write( p );
-    }
-}
-
-
-void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )
-{
-    if ( writeBOM ) {
-        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };
-        Write( reinterpret_cast< const char* >( bom ) );
-    }
-    if ( writeDec ) {
-        PushDeclaration( "xml version=\"1.0\"" );
-    }
-}
-
-void XMLPrinter::PrepareForNewNode( bool compactMode )
-{
-    SealElementIfJustOpened();
-
-    if ( compactMode ) {
-        return;
-    }
-
-    if ( _firstElement ) {
-        PrintSpace (_depth);
-    } else if ( _textDepth < 0) {
-        Putc( '\n' );
-        PrintSpace( _depth );
-    }
-
-    _firstElement = false;
-}
-
-void XMLPrinter::OpenElement( const char* name, bool compactMode )
-{
-    PrepareForNewNode( compactMode );
-    _stack.Push( name );
-
-    Write ( "<" );
-    Write ( name );
-
-    _elementJustOpened = true;
-    ++_depth;
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, const char* value )
-{
-    TIXMLASSERT( _elementJustOpened );
-    Putc ( ' ' );
-    Write( name );
-    Write( "=\"" );
-    PrintString( value, false );
-    Putc ( '\"' );
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, int v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, unsigned v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::PushAttribute(const char* name, int64_t v)
-{
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	PushAttribute(name, buf);
-}
-
-
-void XMLPrinter::PushAttribute(const char* name, uint64_t v)
-{
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	PushAttribute(name, buf);
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, bool v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, double v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::CloseElement( bool compactMode )
-{
-    --_depth;
-    const char* name = _stack.Pop();
-
-    if ( _elementJustOpened ) {
-        Write( "/>" );
-    }
-    else {
-        if ( _textDepth < 0 && !compactMode) {
-            Putc( '\n' );
-            PrintSpace( _depth );
-        }
-        Write ( "</" );
-        Write ( name );
-        Write ( ">" );
-    }
-
-    if ( _textDepth == _depth ) {
-        _textDepth = -1;
-    }
-    if ( _depth == 0 && !compactMode) {
-        Putc( '\n' );
-    }
-    _elementJustOpened = false;
-}
-
-
-void XMLPrinter::SealElementIfJustOpened()
-{
-    if ( !_elementJustOpened ) {
-        return;
-    }
-    _elementJustOpened = false;
-    Putc( '>' );
-}
-
-
-void XMLPrinter::PushText( const char* text, bool cdata )
-{
-    _textDepth = _depth-1;
-
-    SealElementIfJustOpened();
-    if ( cdata ) {
-        Write( "<![CDATA[" );
-        Write( text );
-        Write( "]]>" );
-    }
-    else {
-        PrintString( text, true );
-    }
-}
-
-
-void XMLPrinter::PushText( int64_t value )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
-}
-
-
-void XMLPrinter::PushText( uint64_t value )
-{
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(value, buf, BUF_SIZE);
-	PushText(buf, false);
-}
-
-
-void XMLPrinter::PushText( int value )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
-}
-
-
-void XMLPrinter::PushText( unsigned value )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
-}
-
-
-void XMLPrinter::PushText( bool value )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
-}
-
-
-void XMLPrinter::PushText( float value )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
-}
-
-
-void XMLPrinter::PushText( double value )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
-}
-
-
-void XMLPrinter::PushComment( const char* comment )
-{
-    PrepareForNewNode( _compactMode );
-
-    Write( "<!--" );
-    Write( comment );
-    Write( "-->" );
-}
-
-
-void XMLPrinter::PushDeclaration( const char* value )
-{
-    PrepareForNewNode( _compactMode );
-
-    Write( "<?" );
-    Write( value );
-    Write( "?>" );
-}
-
-
-void XMLPrinter::PushUnknown( const char* value )
-{
-    PrepareForNewNode( _compactMode );
-
-    Write( "<!" );
-    Write( value );
-    Putc( '>' );
-}
-
-
-bool XMLPrinter::VisitEnter( const XMLDocument& doc )
-{
-    _processEntities = doc.ProcessEntities();
-    if ( doc.HasBOM() ) {
-        PushHeader( true, false );
-    }
-    return true;
-}
-
-
-bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )
-{
-    const XMLElement* parentElem = 0;
-    if ( element.Parent() ) {
-        parentElem = element.Parent()->ToElement();
-    }
-    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;
-    OpenElement( element.Name(), compactMode );
-    while ( attribute ) {
-        PushAttribute( attribute->Name(), attribute->Value() );
-        attribute = attribute->Next();
-    }
-    return true;
-}
-
-
-bool XMLPrinter::VisitExit( const XMLElement& element )
-{
-    CloseElement( CompactMode(element) );
-    return true;
-}
-
-
-bool XMLPrinter::Visit( const XMLText& text )
-{
-    PushText( text.Value(), text.CData() );
-    return true;
-}
-
-
-bool XMLPrinter::Visit( const XMLComment& comment )
-{
-    PushComment( comment.Value() );
-    return true;
-}
-
-bool XMLPrinter::Visit( const XMLDeclaration& declaration )
-{
-    PushDeclaration( declaration.Value() );
-    return true;
-}
-
-
-bool XMLPrinter::Visit( const XMLUnknown& unknown )
-{
-    PushUnknown( unknown.Value() );
-    return true;
-}
-
-}   // namespace tinyxml2
+      }
+      ++q;
+      TIXMLASSERT(p <= q);
+    }
+    // Flush the remaining string. This will be the entire
+    // string if an entity wasn't found.
+    if (p < q) {
+      const size_t delta = q - p;
+      const int toPrint = (INT_MAX < delta) ? INT_MAX : static_cast<int>(delta);
+      Write(p, toPrint);
+    }
+  } else {
+    Write(p);
+  }
+}
+
+void XMLPrinter::PushHeader(bool writeBOM, bool writeDec) {
+  if (writeBOM) {
+    static const unsigned char bom[] = {TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1,
+                                        TIXML_UTF_LEAD_2, 0};
+    Write(reinterpret_cast<const char*>(bom));
+  }
+  if (writeDec) {
+    PushDeclaration("xml version=\"1.0\"");
+  }
+}
+
+void XMLPrinter::PrepareForNewNode(bool compactMode) {
+  SealElementIfJustOpened();
+
+  if (compactMode) {
+    return;
+  }
+
+  if (_firstElement) {
+    PrintSpace(_depth);
+  } else if (_textDepth < 0) {
+    Putc('\n');
+    PrintSpace(_depth);
+  }
+
+  _firstElement = false;
+}
+
+void XMLPrinter::OpenElement(const char* name, bool compactMode) {
+  PrepareForNewNode(compactMode);
+  _stack.Push(name);
+
+  Write("<");
+  Write(name);
+
+  _elementJustOpened = true;
+  ++_depth;
+}
+
+void XMLPrinter::PushAttribute(const char* name, const char* value) {
+  TIXMLASSERT(_elementJustOpened);
+  Putc(' ');
+  Write(name);
+  Write("=\"");
+  PrintString(value, false);
+  Putc('\"');
+}
+
+void XMLPrinter::PushAttribute(const char* name, int v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+void XMLPrinter::PushAttribute(const char* name, unsigned v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+void XMLPrinter::PushAttribute(const char* name, int64_t v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+void XMLPrinter::PushAttribute(const char* name, uint64_t v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+void XMLPrinter::PushAttribute(const char* name, bool v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+void XMLPrinter::PushAttribute(const char* name, double v) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+void XMLPrinter::CloseElement(bool compactMode) {
+  --_depth;
+  const char* name = _stack.Pop();
+
+  if (_elementJustOpened) {
+    Write("/>");
+  } else {
+    if (_textDepth < 0 && !compactMode) {
+      Putc('\n');
+      PrintSpace(_depth);
+    }
+    Write("</");
+    Write(name);
+    Write(">");
+  }
+
+  if (_textDepth == _depth) {
+    _textDepth = -1;
+  }
+  if (_depth == 0 && !compactMode) {
+    Putc('\n');
+  }
+  _elementJustOpened = false;
+}
+
+void XMLPrinter::SealElementIfJustOpened() {
+  if (!_elementJustOpened) {
+    return;
+  }
+  _elementJustOpened = false;
+  Putc('>');
+}
+
+void XMLPrinter::PushText(const char* text, bool cdata) {
+  _textDepth = _depth - 1;
+
+  SealElementIfJustOpened();
+  if (cdata) {
+    Write("<![CDATA[");
+    Write(text);
+    Write("]]>");
+  } else {
+    PrintString(text, true);
+  }
+}
+
+void XMLPrinter::PushText(int64_t value) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
+}
+
+void XMLPrinter::PushText(uint64_t value) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
+}
+
+void XMLPrinter::PushText(int value) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
+}
+
+void XMLPrinter::PushText(unsigned value) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
+}
+
+void XMLPrinter::PushText(bool value) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
+}
+
+void XMLPrinter::PushText(float value) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
+}
+
+void XMLPrinter::PushText(double value) {
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
+}
+
+void XMLPrinter::PushComment(const char* comment) {
+  PrepareForNewNode(_compactMode);
+
+  Write("<!--");
+  Write(comment);
+  Write("-->");
+}
+
+void XMLPrinter::PushDeclaration(const char* value) {
+  PrepareForNewNode(_compactMode);
+
+  Write("<?");
+  Write(value);
+  Write("?>");
+}
+
+void XMLPrinter::PushUnknown(const char* value) {
+  PrepareForNewNode(_compactMode);
+
+  Write("<!");
+  Write(value);
+  Putc('>');
+}
+
+bool XMLPrinter::VisitEnter(const XMLDocument& doc) {
+  _processEntities = doc.ProcessEntities();
+  if (doc.HasBOM()) {
+    PushHeader(true, false);
+  }
+  return true;
+}
+
+bool XMLPrinter::VisitEnter(const XMLElement& element,
+                            const XMLAttribute* attribute) {
+  const XMLElement* parentElem = 0;
+  if (element.Parent()) {
+    parentElem = element.Parent()->ToElement();
+  }
+  const bool compactMode = parentElem ? CompactMode(*parentElem) : _compactMode;
+  OpenElement(element.Name(), compactMode);
+  while (attribute) {
+    PushAttribute(attribute->Name(), attribute->Value());
+    attribute = attribute->Next();
+  }
+  return true;
+}
+
+bool XMLPrinter::VisitExit(const XMLElement& element) {
+  CloseElement(CompactMode(element));
+  return true;
+}
+
+bool XMLPrinter::Visit(const XMLText& text) {
+  PushText(text.Value(), text.CData());
+  return true;
+}
+
+bool XMLPrinter::Visit(const XMLComment& comment) {
+  PushComment(comment.Value());
+  return true;
+}
+
+bool XMLPrinter::Visit(const XMLDeclaration& declaration) {
+  PushDeclaration(declaration.Value());
+  return true;
+}
+
+bool XMLPrinter::Visit(const XMLUnknown& unknown) {
+  PushUnknown(unknown.Value());
+  return true;
+}
+
+}  // namespace tinyxml2
 
tests/mechanical_layer/include/InputStatic.h
====================
--- original

+++ formatted

@@ -5,27 +5,18 @@

 
 /// Read input files
 int readParameters(const std::string& file);
-int readMaterials(
-    const std::string& file,
-    std::map<std::string,
-    int32_t>& materialMapping);
-int readGeometry(
-    const std::string& file,
-    std::map<std::string, int32_t>& materialMapping);
-int readAgents(
-    const std::string& file,
-    std::vector<unsigned>& nShapesPerAgent,
-    std::vector<unsigned>& shapeIDagent,
-    std::vector<int>& edges,
-    std::vector<double>& radii,
-    std::vector<double>& masses,
-    std::vector<double>& mois,
-    std::vector<double2>& delta_gtos,
-    std::map<std::string, int32_t>& materialMapping);
+int readMaterials(const std::string& file,
+                  std::map<std::string, int32_t>& materialMapping);
+int readGeometry(const std::string& file,
+                 std::map<std::string, int32_t>& materialMapping);
+int readAgents(const std::string& file, std::vector<unsigned>& nShapesPerAgent,
+               std::vector<unsigned>& shapeIDagent, std::vector<int>& edges,
+               std::vector<double>& radii, std::vector<double>& masses,
+               std::vector<double>& mois, std::vector<double2>& delta_gtos,
+               std::map<std::string, int32_t>& materialMapping);
 
 /// Computes k_n and k_t for the given materials
 double computeStiffnessNormal(uint32_t i, uint32_t j);
 double computeStiffnessTangential(uint32_t i, uint32_t j);
 
-
 #endif
tests/mechanical_layer/src/Crowd.cpp
====================
--- original

+++ formatted

@@ -1,9 +1,10 @@

 /*
-    Crowd.cpp is responsible for setting up the global situation, decide which agents
-    are mechanically active and call the mechanical layer for the latter.
+    Crowd.cpp is responsible for setting up the global situation, decide which
+   agents are mechanically active and call the mechanical layer for the latter.
 
  */
 #include "Crowd.h"
+
 #include "MechanicalLayer.h"
 
 using namespace std;
@@ -12,367 +13,392 @@

 list<Agent*> mech_active_agents;
 
 /**
- * @brief The function creates all agents from the Agents (static) and agentDynamics (dynamic) XML files.
- *        It initiates the list of neighbours.
- *
- * @param dynamicsFile The input file containing the current state and driving forces for all agents
- * @param nb_shapes_allagents The number of shapes by agent (size: number of agents)
- * @param shapeIDagent A correspondence between the shape ids (index) and the agent (value) (size: number of shapes)
- * @param edges The indices of the first shape for each agent (size:  number of agents + 1)
+ * @brief The function creates all agents from the Agents (static) and
+ * agentDynamics (dynamic) XML files. It initiates the list of neighbours.
+ *
+ * @param dynamicsFile The input file containing the current state and driving
+ * forces for all agents
+ * @param nb_shapes_allagents The number of shapes by agent (size: number of
+ * agents)
+ * @param shapeIDagent A correspondence between the shape ids (index) and the
+ * agent (value) (size: number of shapes)
+ * @param edges The indices of the first shape for each agent (size:  number of
+ * agents + 1)
  * @param radius_allshapes The radii of all shapes (size: number of shapes)
  * @param masses The masses of the agents
  * @param mois The moment of inertia of the agents
- * @param delta_gtos The relative positions of the shapes with respect to the center of mass of each agent
+ * @param delta_gtos The relative positions of the shapes with respect to the
+ * center of mass of each agent
  *
  * @return EXIT_SUCCESS if no issue with the Dynamics file
  *         EXIT_FAILURE otherwise
  */
-int initialiseSetting(const string &dynamicsFile,
-                       vector<unsigned> &nb_shapes_allagents, vector<unsigned> &shapeIDagent, vector<int> &edges,
-                       vector<double> &radius_allshapes, vector<double> &masses, vector<double> &mois,
-                       vector<double2> &delta_gtos) {
-    /*  Allocate agents */
-    agents = new Agent*[nAgents];
-
-    /*  Create ids of shapes for agents */
-    vector<unsigned> Id_shapes(shapeIDagent.size());
-    for (size_t i = 0; i < shapeIDagent.size(); i++)
-    {
-        Id_shapes[i] = i;
-    }
-
-    /*  Create agents: read the dynamics file first  */
-    tinyxml2::XMLDocument document;
-    document.LoadFile(dynamicsFile.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << dynamicsFile << endl;
-        return EXIT_FAILURE;
-    }
-    //  Read the Agents block
-    tinyxml2::XMLElement* agentsElement         = document.FirstChildElement("Agents");
-    if (!agentsElement) {
-        cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-    const tinyxml2::XMLElement* agentElement    = agentsElement->FirstChildElement("Agent");
-    if (!agentElement) {
-        cerr << "Error: no Agent tag present in " << dynamicsFile << endl;
-        return EXIT_FAILURE;
-    }
-    uint32_t agentCounter = 0;
-    while (agentElement != nullptr) {
-        const char* agentId = nullptr;
-        uint32_t a;
-        agentElement->QueryStringAttribute("Id", &agentId);
-        if (!agentId) {
-            cerr << "Error: agent tag with no id in dynamics file" << endl;
-            return EXIT_FAILURE;
+int initialiseSetting(const string& dynamicsFile,
+                      vector<unsigned>& nb_shapes_allagents,
+                      vector<unsigned>& shapeIDagent, vector<int>& edges,
+                      vector<double>& radius_allshapes, vector<double>& masses,
+                      vector<double>& mois, vector<double2>& delta_gtos) {
+  /*  Allocate agents */
+  agents = new Agent*[nAgents];
+
+  /*  Create ids of shapes for agents */
+  vector<unsigned> Id_shapes(shapeIDagent.size());
+  for (size_t i = 0; i < shapeIDagent.size(); i++) {
+    Id_shapes[i] = i;
+  }
+
+  /*  Create agents: read the dynamics file first  */
+  tinyxml2::XMLDocument document;
+  document.LoadFile(dynamicsFile.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << dynamicsFile << endl;
+    return EXIT_FAILURE;
+  }
+  //  Read the Agents block
+  tinyxml2::XMLElement* agentsElement = document.FirstChildElement("Agents");
+  if (!agentsElement) {
+    cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+  const tinyxml2::XMLElement* agentElement =
+      agentsElement->FirstChildElement("Agent");
+  if (!agentElement) {
+    cerr << "Error: no Agent tag present in " << dynamicsFile << endl;
+    return EXIT_FAILURE;
+  }
+  uint32_t agentCounter = 0;
+  while (agentElement != nullptr) {
+    const char* agentId = nullptr;
+    uint32_t a;
+    agentElement->QueryStringAttribute("Id", &agentId);
+    if (!agentId) {
+      cerr << "Error: agent tag with no id in dynamics file" << endl;
+      return EXIT_FAILURE;
+    }
+    if (!agentMap.contains(agentId)) {
+      cerr << "Error: unknown agent " << agentId << " in dynamics file" << endl;
+      return EXIT_FAILURE;
+    } else
+      a = agentMap[agentId];
+
+    const unsigned ID_agent(a);
+    vector<double2> delta_gtos_curr(&delta_gtos[edges[a]],
+                                    &delta_gtos[edges[a + 1]]);
+    double2 shoulders_direction(delta_gtos[edges[a + 1] - 1] -
+                                delta_gtos[edges[a]]);  // from left to right
+    double2 orientation_vec(
+        {-shoulders_direction.second,
+         shoulders_direction.first});  // normal to the shoulders direction
+    double theta_body_init(0.);
+    if (not(orientation_vec.first == 0. and orientation_vec.second == 0.))
+      theta_body_init = atan2(orientation_vec.second, orientation_vec.first);
+
+    vector<double> radius_shapes(&radius_allshapes[edges[a]],
+                                 &radius_allshapes[edges[a + 1]]);
+    const vector<unsigned> Ids_shapes_agent(&Id_shapes[edges[a]],
+                                            &Id_shapes[edges[a + 1]]);
+    const double mass_curr(masses[a]), moi_curr(mois[a]);
+
+    /// Kinematics and Dynamics
+    const tinyxml2::XMLElement* kinematicsElement =
+        agentElement->FirstChildElement("Kinematics");
+    if (!kinematicsElement) {
+      cerr << "Error: no Kinematics tag present for agent " << agentId << endl;
+      return EXIT_FAILURE;
+    }
+    const char* buffer = nullptr;
+    if (kinematicsElement->QueryStringAttribute("Position", &buffer) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: Could not parse agent position from XML file "
+           << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    auto [rcPosition, position] = parse2DComponents(buffer);
+    if (rcPosition != EXIT_SUCCESS) {
+      cerr << "Error: Could not parse corner coordinates from XML file "
+           << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+
+    if (kinematicsElement->QueryStringAttribute("Velocity", &buffer) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: Could not parse agent velocity from XML file "
+           << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    auto [rcVelocity, velocity] = parse2DComponents(buffer);
+    if (rcVelocity != EXIT_SUCCESS) {
+      cerr << "Error: Could not parse corner coordinates from XML file "
+           << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    double theta, omega;
+    if (kinematicsElement->QueryDoubleAttribute("theta", &theta) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get orientation of agent " << agentId << endl;
+    };
+    if (kinematicsElement->QueryDoubleAttribute("omega", &omega) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get angular velocity of agent " << agentId
+           << endl;
+    };
+
+    const tinyxml2::XMLElement* dynamicsElement =
+        agentElement->FirstChildElement("Dynamics");
+    if (!dynamicsElement) {
+      cerr << "Error: no Dynamics tag present for agent " << agentId << endl;
+      return EXIT_FAILURE;
+    }
+    if (dynamicsElement->QueryStringAttribute("Fp", &buffer) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get driving force of agent " << agentId << endl;
+      return EXIT_FAILURE;
+    }
+    auto [rcFp, Fp] = parse2DComponents(buffer);
+    if (rcFp != EXIT_SUCCESS) {
+      cerr << "Error: Could not parse corner coordinates from XML file "
+           << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    double Mp;
+    if (dynamicsElement->QueryDoubleAttribute("Mp", &Mp) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get driving torque of agent " << agentId
+           << endl;
+      return EXIT_FAILURE;
+    };
+    /// Actual creation of the Agent object
+    agents[ID_agent] =
+        new Agent(ID_agent, Ids_shapes_agent, position.first, position.second,
+                  velocity.first, velocity.second, omega, Fp, Mp,
+                  nb_shapes_allagents[a], delta_gtos_curr, radius_shapes, theta,
+                  theta_body_init, mass_curr, moi_curr);
+
+    agentElement = agentElement->NextSiblingElement("Agent");
+    agentCounter++;
+  }
+  /// Check if the number of agents in the Dynamics file is the same as in the
+  /// Agents file
+  if (agentCounter != nAgents) {
+    cerr << "Not all agents are present in the dynamics file" << dynamicsFile
+         << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Update neighbours before calling the mechanical layer   */
+  determine_agents_neighbours();
+
+  return EXIT_SUCCESS;
+}
+
+/**
+ * @brief Updates the list of neighbors for each agent in the crowd.
+ *
+ * This function creates the lists based on the proximity of each agent to other
+ * agents and to walls.
+ *
+ */
+void determine_agents_neighbours() {
+  /// We will consider all agents within a certain distance from one another, ie
+  /// the maximum distance that can be traveled by an agent within dt seconds at
+  /// max speed vMaxAgent. We multiply it by 2 in the "extreme" case of two
+  /// pedestrians walking (running) fast towards each other. All this ensures
+  /// that all agents who can potentially collide within dt are taken into
+  /// account.
+  const double criticalDistanceWall = dt * vMaxAgent;
+  const double criticalDistance = 2 * criticalDistanceWall;
+
+  for (uint32_t a1 = 0; a1 < nAgents; a1++) {
+    Agent* agent1 = agents[a1];
+    //  First, check walls
+    for (uint32_t iobs = 0; iobs < listObstacles.size(); iobs++) {
+      for (uint32_t iwall = 0; iwall < listObstacles[iobs].size() - 1;
+           iwall++) {
+        auto [distance, closest_point] = get_distance_to_wall_and_closest_point(
+            listObstacles[iobs][iwall], listObstacles[iobs][iwall + 1],
+            agent1->get_r());
+        if (distance < criticalDistanceWall) {
+          agent1->_neighbours_walls.emplace_back(iobs, iwall);
         }
-        if (!agentMap.contains(agentId)) {
-            cerr << "Error: unknown agent " << agentId << " in dynamics file" << endl;
-            return EXIT_FAILURE;
-        }
-        else a = agentMap[agentId];
-
-        const unsigned ID_agent(a);
-        vector<double2> delta_gtos_curr(&delta_gtos[edges[a]],
-                                        &delta_gtos[edges[a + 1]]);
-        double2 shoulders_direction(delta_gtos[edges[a + 1] - 1] - delta_gtos[edges[a]]);       // from left to right
-        double2 orientation_vec({-shoulders_direction.second, shoulders_direction.first});   // normal to the shoulders direction
-        double theta_body_init(0.);
-        if (not(orientation_vec.first == 0. and orientation_vec.second == 0.))
-            theta_body_init = atan2(orientation_vec.second, orientation_vec.first);
-
-        vector<double> radius_shapes(&radius_allshapes[edges[a]], &radius_allshapes[edges[a + 1]]);
-        const vector<unsigned> Ids_shapes_agent(&Id_shapes[edges[a]], &Id_shapes[edges[a + 1]]);
-        const double mass_curr(masses[a]), moi_curr(mois[a]);
-
-        /// Kinematics and Dynamics
-        const tinyxml2::XMLElement* kinematicsElement    = agentElement->FirstChildElement("Kinematics");
-        if (!kinematicsElement) {
-            cerr << "Error: no Kinematics tag present for agent " << agentId << endl;
-            return EXIT_FAILURE;
-        }
-        const char* buffer = nullptr;
-        if (kinematicsElement->QueryStringAttribute("Position", &buffer) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: Could not parse agent position from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        auto [rcPosition, position] = parse2DComponents(buffer);
-        if (rcPosition != EXIT_SUCCESS) {
-            cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-
-        if (kinematicsElement->QueryStringAttribute("Velocity", &buffer) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: Could not parse agent velocity from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        auto [rcVelocity, velocity] = parse2DComponents(buffer);
-        if (rcVelocity != EXIT_SUCCESS) {
-            cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        double theta, omega;
-        if (kinematicsElement->QueryDoubleAttribute("theta", &theta) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get orientation of agent " << agentId << endl;
-        };
-        if (kinematicsElement->QueryDoubleAttribute("omega", &omega) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get angular velocity of agent " << agentId << endl;
-        };
-
-        const tinyxml2::XMLElement* dynamicsElement    = agentElement->FirstChildElement("Dynamics");
-        if (!dynamicsElement) {
-            cerr << "Error: no Dynamics tag present for agent " << agentId << endl;
-            return EXIT_FAILURE;
-        }
-        if (dynamicsElement->QueryStringAttribute("Fp", &buffer) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get driving force of agent " << agentId << endl;
-            return EXIT_FAILURE;
-        }
-        auto [rcFp, Fp] = parse2DComponents(buffer);
-        if (rcFp != EXIT_SUCCESS) {
-            cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        double Mp;
-        if (dynamicsElement->QueryDoubleAttribute("Mp", &Mp) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get driving torque of agent " << agentId << endl;
-            return EXIT_FAILURE;
-        };
-        /// Actual creation of the Agent object
-        agents[ID_agent] = new Agent(ID_agent, Ids_shapes_agent, position.first, position.second,
-                                    velocity.first, velocity.second, omega, Fp, Mp,
-                                    nb_shapes_allagents[a], delta_gtos_curr, radius_shapes,
-                                    theta, theta_body_init, mass_curr, moi_curr);
-
-        agentElement = agentElement->NextSiblingElement("Agent");
-        agentCounter++;
-    }
-    /// Check if the number of agents in the Dynamics file is the same as in the Agents file
-    if (agentCounter != nAgents) {
-        cerr << "Not all agents are present in the dynamics file" << dynamicsFile << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Update neighbours before calling the mechanical layer   */
-    determine_agents_neighbours();
-
-    return EXIT_SUCCESS;
-}
-
-/**
- * @brief Updates the list of neighbors for each agent in the crowd.
- *
- * This function creates the lists based on the proximity of each agent to other agents and to walls.
- *
- */
-void determine_agents_neighbours()
-{
-    /// We will consider all agents within a certain distance from one another, ie the maximum distance
-    /// that can be traveled by an agent within dt seconds at max speed vMaxAgent. We multiply it by 2 in the "extreme"
-    /// case of two pedestrians walking (running) fast towards each other. All this ensures that all agents who can
-    /// potentially collide within dt are taken into account.
-    const double criticalDistanceWall   = dt * vMaxAgent;
-    const double criticalDistance       = 2 * criticalDistanceWall;
-
-    for (uint32_t a1 = 0; a1 < nAgents; a1++)
-    {
-        Agent* agent1 = agents[a1];
-        //  First, check walls
-        for (uint32_t iobs = 0; iobs < listObstacles.size(); iobs++) {
-            for (uint32_t iwall = 0; iwall < listObstacles[iobs].size() - 1; iwall++) {
-                auto [distance, closest_point] =
-                    get_distance_to_wall_and_closest_point(
-                        listObstacles[iobs][iwall],
-                        listObstacles[iobs][iwall + 1],
-                        agent1->get_r());
-                if (distance < criticalDistanceWall) {
-                    agent1->_neighbours_walls.emplace_back(iobs, iwall);
-                }
-            }
-        }
-        //  Then, other agents
-        for (uint32_t a2 = a1 + 1; a2 < nAgents; a2++)
-        {
-            Agent* agent2 = agents[a2];
-
-            const double2 r1 = agent1->get_r();
-            const double2 r2 = agent2->get_r();
-            if (const double r = get_distance(r1, r2); r < criticalDistance) {
-                agent1->_neighbours.push_back(agent2->_id);
-                agent2->_neighbours.push_back(agent1->_id);
-            }
-        }
-    }
+      }
+    }
+    //  Then, other agents
+    for (uint32_t a2 = a1 + 1; a2 < nAgents; a2++) {
+      Agent* agent2 = agents[a2];
+
+      const double2 r1 = agent1->get_r();
+      const double2 r2 = agent2->get_r();
+      if (const double r = get_distance(r1, r2); r < criticalDistance) {
+        agent1->_neighbours.push_back(agent2->_id);
+        agent2->_neighbours.push_back(agent1->_id);
+      }
+    }
+  }
 }
 /**
  * @brief Executes the mechanical layer.
  *
- * This function is responsible for updating the state of each agent in the Crowd.
- * It performs the following steps:
+ * This function is responsible for updating the state of each agent in the
+ * Crowd. It performs the following steps:
  * 1. Handles mechanically active agents using the mechanical layer.
  * 2. Handles non-mechanically active agents by updating their position.
- * 3. Generate and output file with the new position and velocity, plus their angular counterparts.
- *
- * @param dynamicsFile The input dynamics file will be overwritten with the output of the mechanical layer.
- */
-void handleMechanicalLayer(const string &dynamicsFile)
-{
-    /*  Handle mechanically active agents: mechanical layer */
-    if (get_future_collision())
-    {
-        const MechanicalLayer* crowdMech = new MechanicalLayer(mech_active_agents);
-        delete crowdMech;
-    }
-
-    /*  Handle non mechanically active agents: simple positional update */
-    for (uint32_t a = 0; a < nAgents; a++) {
-        Agent* agent = agents[a];
-        if (is_mechanically_active(agent))
-            continue;
-        /// The dynamics follow a simple relaxation equation, ie
-        /// dv/dt = (v_des - v) / tau_mech  ==> v(t)= v_des (1 - e^-t/tau_mech) + v(t=0) e^-t/tau_mech
-        const double inverseTauMechTranslation   = agentProperties[agent->_id].first;
-        const double inverseTauMechRotation      = agentProperties[agent->_id].second;
-        agent->_vx = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vx_des
-                    + exp(-dt * inverseTauMechTranslation) * agent->_vx;
-        agent->_vy = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vy_des
-                    + exp(-dt * inverseTauMechTranslation) * agent->_vy;
-        agent->_w  = (1.0 - exp(-dt * inverseTauMechRotation)) * agent->_w_des
-                    + exp(-dt * inverseTauMechRotation) * agent->_w;
-        agent->move();
-    }
-
-    /*  Save output of mechanical layer to file */
-    generateDynamicsOutputFile(dynamicsFile);
+ * 3. Generate and output file with the new position and velocity, plus their
+ * angular counterparts.
+ *
+ * @param dynamicsFile The input dynamics file will be overwritten with the
+ * output of the mechanical layer.
+ */
+void handleMechanicalLayer(const string& dynamicsFile) {
+  /*  Handle mechanically active agents: mechanical layer */
+  if (get_future_collision()) {
+    const MechanicalLayer* crowdMech = new MechanicalLayer(mech_active_agents);
+    delete crowdMech;
+  }
+
+  /*  Handle non mechanically active agents: simple positional update */
+  for (uint32_t a = 0; a < nAgents; a++) {
+    Agent* agent = agents[a];
+    if (is_mechanically_active(agent)) continue;
+    /// The dynamics follow a simple relaxation equation, ie
+    /// dv/dt = (v_des - v) / tau_mech  ==> v(t)= v_des (1 - e^-t/tau_mech) +
+    /// v(t=0) e^-t/tau_mech
+    const double inverseTauMechTranslation = agentProperties[agent->_id].first;
+    const double inverseTauMechRotation = agentProperties[agent->_id].second;
+    agent->_vx = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vx_des +
+                 exp(-dt * inverseTauMechTranslation) * agent->_vx;
+    agent->_vy = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vy_des +
+                 exp(-dt * inverseTauMechTranslation) * agent->_vy;
+    agent->_w = (1.0 - exp(-dt * inverseTauMechRotation)) * agent->_w_des +
+                exp(-dt * inverseTauMechRotation) * agent->_w;
+    agent->move();
+  }
+
+  /*  Save output of mechanical layer to file */
+  generateDynamicsOutputFile(dynamicsFile);
 }
 
 /**
  * @brief Checks if the given agent is mechanically active in the crowd.
- * An agent is considered mechanically active if it is present in the mech_active_agents container.
+ * An agent is considered mechanically active if it is present in the
+ * mech_active_agents container.
  *
  * @param agent The agent to check.
  * @return True if the agent is mechanically active, false otherwise.
  */
-bool is_mechanically_active(const Agent* agent)
-{
-    return (ranges::find(mech_active_agents, agent) != mech_active_agents.end());
-}
-
-/**
- * @brief Checks if there will be any future collisions between agents in the crowd.
+bool is_mechanically_active(const Agent* agent) {
+  return (ranges::find(mech_active_agents, agent) != mech_active_agents.end());
+}
+
+/**
+ * @brief Checks if there will be any future collisions between agents in the
+ * crowd.
  *
  * @return true if there will be future collisions, false otherwise.
  */
-bool get_future_collision()
-{
-    /* Test new positions   */
-    for (uint32_t a = 0; a < nAgents; a++)
-    {
-        Agent* agent = agents[a];
-
-        agent->_x += agent->_vx_des * dt;
-        agent->_y += agent->_vy_des * dt;
-        agent->_theta += agent->_w_des * dt;
-    }
-
-    /// Check if overlaps
-    mech_active_agents.clear();
-    for (uint32_t a = 0; a < nAgents; a++)
-    {
-        Agent* agent1 = agents[a];
-        /// Loop over current agent's wall neighbours
-        for (const auto& [iobs, iwall] : agent1->_neighbours_walls) {
-            double2 middlePointWall = 0.5 * (listObstacles[iobs][iwall] + listObstacles[iobs][iwall + 1]);
-            if ((!(agent1->get_r() - middlePointWall)) < agent1->_radius + 1e-1) {
-                if (not is_mechanically_active(agent1))
-                    mech_active_agents.push_back(agent1);
-            }
-        }
-        /// Loop over current agent's neighbours
-        for (const unsigned agent2_id : agent1->_neighbours)
-        {
-            if (Agent* agent2 = agents[agent2_id];
-                    (!(agent1->get_r() - agent2->get_r())) < fabs(agent1->_radius + agent2->_radius) + 1e-1)
-            {
-                if (not is_mechanically_active(agent1))
-                    mech_active_agents.push_back(agent1);
-                if (not is_mechanically_active(agent2))
-                    mech_active_agents.push_back(agent2);
-            }
-        }
-    }
-
-    /// Revert to former positions
-    for (uint32_t a = 0; a < nAgents; a++)
-    {
-        Agent* agent = agents[a];
-
-        agent->_x -= agent->_vx_des * dt;
-        agent->_y -= agent->_vy_des * dt;
-        agent->_theta -= agent->_w_des * dt;
-    }
-
-    /// Add agents with significant velocity changes
-    for (uint32_t a = 0; a < nAgents; a++)
-    {
-        if (Agent* agent = agents[a];
-                pow(agent->_vx - agent->_vx_des, 2)
-                + pow(agent->_vy - agent->_vy_des, 2)
-                + pow(agent->_w - agent->_w_des, 2) > 1e-4
-                and not is_mechanically_active(agent)
-            )
-            mech_active_agents.push_back(agent);
-    }
-
-    /// Add neighbours of active agents
-    for (const Agent* agent : mech_active_agents)
-    {
-        for (const unsigned neighbour : agent->_neighbours)
-        {
-            if (not is_mechanically_active(agents[neighbour]))
-                mech_active_agents.push_back(agents[neighbour]);
-        }
-    }
-    return (!mech_active_agents.empty());
-}
-
-/**
- * @brief The function generates the final state of the agents by overwriting the input dynamics file.
+bool get_future_collision() {
+  /* Test new positions   */
+  for (uint32_t a = 0; a < nAgents; a++) {
+    Agent* agent = agents[a];
+
+    agent->_x += agent->_vx_des * dt;
+    agent->_y += agent->_vy_des * dt;
+    agent->_theta += agent->_w_des * dt;
+  }
+
+  /// Check if overlaps
+  mech_active_agents.clear();
+  for (uint32_t a = 0; a < nAgents; a++) {
+    Agent* agent1 = agents[a];
+    /// Loop over current agent's wall neighbours
+    for (const auto& [iobs, iwall] : agent1->_neighbours_walls) {
+      double2 middlePointWall =
+          0.5 * (listObstacles[iobs][iwall] + listObstacles[iobs][iwall + 1]);
+      if ((!(agent1->get_r() - middlePointWall)) < agent1->_radius + 1e-1) {
+        if (not is_mechanically_active(agent1))
+          mech_active_agents.push_back(agent1);
+      }
+    }
+    /// Loop over current agent's neighbours
+    for (const unsigned agent2_id : agent1->_neighbours) {
+      if (Agent* agent2 = agents[agent2_id];
+          (!(agent1->get_r() - agent2->get_r())) <
+          fabs(agent1->_radius + agent2->_radius) + 1e-1) {
+        if (not is_mechanically_active(agent1))
+          mech_active_agents.push_back(agent1);
+        if (not is_mechanically_active(agent2))
+          mech_active_agents.push_back(agent2);
+      }
+    }
+  }
+
+  /// Revert to former positions
+  for (uint32_t a = 0; a < nAgents; a++) {
+    Agent* agent = agents[a];
+
+    agent->_x -= agent->_vx_des * dt;
+    agent->_y -= agent->_vy_des * dt;
+    agent->_theta -= agent->_w_des * dt;
+  }
+
+  /// Add agents with significant velocity changes
+  for (uint32_t a = 0; a < nAgents; a++) {
+    if (Agent* agent = agents[a]; pow(agent->_vx - agent->_vx_des, 2) +
+                                          pow(agent->_vy - agent->_vy_des, 2) +
+                                          pow(agent->_w - agent->_w_des, 2) >
+                                      1e-4 and
+                                  not is_mechanically_active(agent))
+      mech_active_agents.push_back(agent);
+  }
+
+  /// Add neighbours of active agents
+  for (const Agent* agent : mech_active_agents) {
+    for (const unsigned neighbour : agent->_neighbours) {
+      if (not is_mechanically_active(agents[neighbour]))
+        mech_active_agents.push_back(agents[neighbour]);
+    }
+  }
+  return (!mech_active_agents.empty());
+}
+
+/**
+ * @brief The function generates the final state of the agents by overwriting
+ * the input dynamics file.
  *
  * @param dynamicsFile The name of the file.
  */
-void generateDynamicsOutputFile(const std::string &dynamicsFile)
-{
-    //  We'll  build the output from the input (the structure and fields are exactly the same)
-    tinyxml2::XMLDocument inputDoc;
-    inputDoc.LoadFile((dynamicsFile).data());
-    ofstream outputDoc;
-    outputDoc.open(dynamicsFile);
-
-    outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
-    //  Read the Agents block
-    tinyxml2::XMLElement* InAgentsElement   = inputDoc.FirstChildElement("Agents");
-    outputDoc << "<Agents>" << endl;
-
-    const tinyxml2::XMLElement* InAgentElement    = InAgentsElement->FirstChildElement("Agent");
-    while (InAgentElement != nullptr) {
-        //  First, get our internal id
-        const char* agentId = nullptr;
-        InAgentElement->QueryStringAttribute("Id", &agentId);
-        const uint32_t a = agentMap[agentId];
-        struct Agent* agent = agents[a];
-        outputDoc << "    <Agent Id=\"" << agentId << "\">" << endl;
-        //  Kinematics
-        outputDoc << "        <Kinematics Position=\"" << agent->_x << "," << agent->_y << "\" ";
-        outputDoc << "Velocity=\"" << agent->_vx << "," << agent->_vy << "\" ";
-        outputDoc << "theta=\"" << agent->_theta << "\" omega=\"" << agent->_w << "\"/>" << endl;
-
-        InAgentElement = InAgentElement->NextSiblingElement("Agent");
-        outputDoc << "    </Agent>" << endl;
-    }
-    outputDoc << "</Agents>";
-
-    outputDoc.close();
-}
+void generateDynamicsOutputFile(const std::string& dynamicsFile) {
+  //  We'll  build the output from the input (the structure and fields are
+  //  exactly the same)
+  tinyxml2::XMLDocument inputDoc;
+  inputDoc.LoadFile((dynamicsFile).data());
+  ofstream outputDoc;
+  outputDoc.open(dynamicsFile);
+
+  outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
+  //  Read the Agents block
+  tinyxml2::XMLElement* InAgentsElement = inputDoc.FirstChildElement("Agents");
+  outputDoc << "<Agents>" << endl;
+
+  const tinyxml2::XMLElement* InAgentElement =
+      InAgentsElement->FirstChildElement("Agent");
+  while (InAgentElement != nullptr) {
+    //  First, get our internal id
+    const char* agentId = nullptr;
+    InAgentElement->QueryStringAttribute("Id", &agentId);
+    const uint32_t a = agentMap[agentId];
+    struct Agent* agent = agents[a];
+    outputDoc << "    <Agent Id=\"" << agentId << "\">" << endl;
+    //  Kinematics
+    outputDoc << "        <Kinematics Position=\"" << agent->_x << ","
+              << agent->_y << "\" ";
+    outputDoc << "Velocity=\"" << agent->_vx << "," << agent->_vy << "\" ";
+    outputDoc << "theta=\"" << agent->_theta << "\" omega=\"" << agent->_w
+              << "\"/>" << endl;
+
+    InAgentElement = InAgentElement->NextSiblingElement("Agent");
+    outputDoc << "    </Agent>" << endl;
+  }
+  outputDoc << "</Agents>";
+
+  outputDoc.close();
+}
tests/mechanical_layer/build/CMakeFiles/4.0.1/CompilerIdC/CMakeCCompilerId.c
====================
--- original

+++ formatted

@@ -1,469 +1,479 @@

 #ifdef __cplusplus
-# error "A C++ compiler has been selected for C."
+#error "A C++ compiler has been selected for C."
 #endif
 
 #if defined(__18CXX)
-# define ID_VOID_MAIN
+#define ID_VOID_MAIN
 #endif
 #if defined(__CLASSIC_C__)
 /* cv-qualifiers did not exist in K&R C */
-# define const
-# define volatile
+#define const
+#define volatile
 #endif
 
 #if !defined(__has_include)
 /* If the compiler does not have __has_include, pretend the answer is
    always no.  */
-#  define __has_include(x) 0
-#endif
-
+#define __has_include(x) 0
+#endif
 
 /* Version number components: V=Version, R=Revision, P=Patch
    Version date components:   YYYY=Year, MM=Month,   DD=Day  */
 
 #if defined(__INTEL_COMPILER) || defined(__ICC)
-# define COMPILER_ID "Intel"
-# if defined(_MSC_VER)
-#  define SIMULATE_ID "MSVC"
-# endif
-# if defined(__GNUC__)
-#  define SIMULATE_ID "GNU"
-# endif
-  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
-     except that a few beta releases use the old format with V=2021.  */
-# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
-#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
-#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
-#  if defined(__INTEL_COMPILER_UPDATE)
-#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
-#  else
-#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
-#  endif
-# else
-#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
-#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
-   /* The third version component from --version is an update index,
-      but no macro is provided for it.  */
-#  define COMPILER_VERSION_PATCH DEC(0)
-# endif
-# if defined(__INTEL_COMPILER_BUILD_DATE)
-   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
-#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
-# endif
-# if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
-#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
-# endif
-# if defined(__GNUC__)
-#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
-# elif defined(__GNUG__)
-#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
-# endif
-# if defined(__GNUC_MINOR__)
-#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
-# endif
-# if defined(__GNUC_PATCHLEVEL__)
-#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
-# endif
-
-#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
-# define COMPILER_ID "IntelLLVM"
+#define COMPILER_ID "Intel"
 #if defined(_MSC_VER)
-# define SIMULATE_ID "MSVC"
+#define SIMULATE_ID "MSVC"
 #endif
 #if defined(__GNUC__)
-# define SIMULATE_ID "GNU"
+#define SIMULATE_ID "GNU"
+#endif
+/* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
+   except that a few beta releases use the old format with V=2021.  */
+#if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || \
+    __INTEL_COMPILER == 202111
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER / 100)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER / 10 % 10)
+#if defined(__INTEL_COMPILER_UPDATE)
+#define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
+#else
+#define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER % 10)
+#endif
+#else
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
+/* The third version component from --version is an update index,
+   but no macro is provided for it.  */
+#define COMPILER_VERSION_PATCH DEC(0)
+#endif
+#if defined(__INTEL_COMPILER_BUILD_DATE)
+/* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
+#define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
+#endif
+#if defined(_MSC_VER)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+#endif
+#if defined(__GNUC__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
+#elif defined(__GNUG__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
+#endif
+#if defined(__GNUC_MINOR__)
+#define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
+#endif
+#if defined(__GNUC_PATCHLEVEL__)
+#define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#endif
+
+#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || \
+    defined(__INTEL_LLVM_COMPILER)
+#define COMPILER_ID "IntelLLVM"
+#if defined(_MSC_VER)
+#define SIMULATE_ID "MSVC"
+#endif
+#if defined(__GNUC__)
+#define SIMULATE_ID "GNU"
 #endif
 /* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
  * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
  * VVVV is no smaller than the current year when a version is released.
  */
 #if __INTEL_LLVM_COMPILER < 1000000L
-# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
-# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
-#else
-# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
-# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
-# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER / 100)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER % 10)
+#else
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER / 10000)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER / 100 % 100)
+#define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER % 100)
 #endif
 #if defined(_MSC_VER)
-  /* _MSC_VER = VVRR */
-# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 #endif
 #if defined(__GNUC__)
-# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
 #elif defined(__GNUG__)
-# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
 #endif
 #if defined(__GNUC_MINOR__)
-# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
+#define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
 #endif
 #if defined(__GNUC_PATCHLEVEL__)
-# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
 #endif
 
 #elif defined(__PATHCC__)
-# define COMPILER_ID "PathScale"
-# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
-# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
-# if defined(__PATHCC_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "PathScale"
+#define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
+#define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
+#if defined(__PATHCC_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
+#endif
 
 #elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
-# define COMPILER_ID "Embarcadero"
-# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
-# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
-# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)
+#define COMPILER_ID "Embarcadero"
+#define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__ >> 24 & 0x00FF)
+#define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__ >> 16 & 0x00FF)
+#define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__ & 0xFFFF)
 
 #elif defined(__BORLANDC__)
-# define COMPILER_ID "Borland"
-  /* __BORLANDC__ = 0xVRR */
-# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
-# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
+#define COMPILER_ID "Borland"
+/* __BORLANDC__ = 0xVRR */
+#define COMPILER_VERSION_MAJOR HEX(__BORLANDC__ >> 8)
+#define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
 
 #elif defined(__WATCOMC__) && __WATCOMC__ < 1200
-# define COMPILER_ID "Watcom"
-   /* __WATCOMC__ = VVRR */
-# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
-# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
-# if (__WATCOMC__ % 10) > 0
-#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
-# endif
+#define COMPILER_ID "Watcom"
+/* __WATCOMC__ = VVRR */
+#define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
+#define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
+#if (__WATCOMC__ % 10) > 0
+#define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
+#endif
 
 #elif defined(__WATCOMC__)
-# define COMPILER_ID "OpenWatcom"
-   /* __WATCOMC__ = VVRP + 1100 */
-# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
-# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
-# if (__WATCOMC__ % 10) > 0
-#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
-# endif
+#define COMPILER_ID "OpenWatcom"
+/* __WATCOMC__ = VVRP + 1100 */
+#define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
+#define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
+#if (__WATCOMC__ % 10) > 0
+#define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
+#endif
 
 #elif defined(__SUNPRO_C)
-# define COMPILER_ID "SunPro"
-# if __SUNPRO_C >= 0x5100
-   /* __SUNPRO_C = 0xVRRP */
-#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)
-#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)
-#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
-# else
-   /* __SUNPRO_CC = 0xVRP */
-#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)
-#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)
-#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
-# endif
+#define COMPILER_ID "SunPro"
+#if __SUNPRO_C >= 0x5100
+/* __SUNPRO_C = 0xVRRP */
+#define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C >> 12)
+#define COMPILER_VERSION_MINOR HEX(__SUNPRO_C >> 4 & 0xFF)
+#define COMPILER_VERSION_PATCH HEX(__SUNPRO_C & 0xF)
+#else
+/* __SUNPRO_CC = 0xVRP */
+#define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C >> 8)
+#define COMPILER_VERSION_MINOR HEX(__SUNPRO_C >> 4 & 0xF)
+#define COMPILER_VERSION_PATCH HEX(__SUNPRO_C & 0xF)
+#endif
 
 #elif defined(__HP_cc)
-# define COMPILER_ID "HP"
-  /* __HP_cc = VVRRPP */
-# define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)
-# define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)
-# define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)
+#define COMPILER_ID "HP"
+/* __HP_cc = VVRRPP */
+#define COMPILER_VERSION_MAJOR DEC(__HP_cc / 10000)
+#define COMPILER_VERSION_MINOR DEC(__HP_cc / 100 % 100)
+#define COMPILER_VERSION_PATCH DEC(__HP_cc % 100)
 
 #elif defined(__DECC)
-# define COMPILER_ID "Compaq"
-  /* __DECC_VER = VVRRTPPPP */
-# define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)
-# define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)
-# define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)
+#define COMPILER_ID "Compaq"
+/* __DECC_VER = VVRRTPPPP */
+#define COMPILER_VERSION_MAJOR DEC(__DECC_VER / 10000000)
+#define COMPILER_VERSION_MINOR DEC(__DECC_VER / 100000 % 100)
+#define COMPILER_VERSION_PATCH DEC(__DECC_VER % 10000)
 
 #elif defined(__IBMC__) && defined(__COMPILER_VER__)
-# define COMPILER_ID "zOS"
-  /* __IBMC__ = VRP */
-# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
-# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)
+#define COMPILER_ID "zOS"
+/* __IBMC__ = VRP */
+#define COMPILER_VERSION_MAJOR DEC(__IBMC__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__IBMC__ / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__IBMC__ % 10)
 
 #elif defined(__open_xl__) && defined(__clang__)
-# define COMPILER_ID "IBMClang"
-# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
-# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
-# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
-# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
-# define COMPILER_VERSION_INTERNAL_STR  __clang_version__
-
+#define COMPILER_ID "IBMClang"
+#define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
+#define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
+#define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
+#define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
+#define COMPILER_VERSION_INTERNAL_STR __clang_version__
 
 #elif defined(__ibmxl__) && defined(__clang__)
-# define COMPILER_ID "XLClang"
-# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
-# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
-# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
-# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)
-
+#define COMPILER_ID "XLClang"
+#define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
+#define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
+#define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
+#define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)
 
 #elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800
-# define COMPILER_ID "XL"
-  /* __IBMC__ = VRP */
-# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
-# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)
+#define COMPILER_ID "XL"
+/* __IBMC__ = VRP */
+#define COMPILER_VERSION_MAJOR DEC(__IBMC__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__IBMC__ / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__IBMC__ % 10)
 
 #elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800
-# define COMPILER_ID "VisualAge"
-  /* __IBMC__ = VRP */
-# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
-# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)
+#define COMPILER_ID "VisualAge"
+/* __IBMC__ = VRP */
+#define COMPILER_VERSION_MAJOR DEC(__IBMC__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__IBMC__ / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__IBMC__ % 10)
 
 #elif defined(__NVCOMPILER)
-# define COMPILER_ID "NVHPC"
-# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
-# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
-# if defined(__NVCOMPILER_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "NVHPC"
+#define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
+#define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
+#if defined(__NVCOMPILER_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
+#endif
 
 #elif defined(__PGI)
-# define COMPILER_ID "PGI"
-# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
-# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
-# if defined(__PGIC_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "PGI"
+#define COMPILER_VERSION_MAJOR DEC(__PGIC__)
+#define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
+#if defined(__PGIC_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
+#endif
 
 #elif defined(__clang__) && defined(__cray__)
-# define COMPILER_ID "CrayClang"
-# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
-# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
-# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
-# define COMPILER_VERSION_INTERNAL_STR __clang_version__
-
+#define COMPILER_ID "CrayClang"
+#define COMPILER_VERSION_MAJOR DEC(__cray_major__)
+#define COMPILER_VERSION_MINOR DEC(__cray_minor__)
+#define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
+#define COMPILER_VERSION_INTERNAL_STR __clang_version__
 
 #elif defined(_CRAYC)
-# define COMPILER_ID "Cray"
-# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
-# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)
+#define COMPILER_ID "Cray"
+#define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
+#define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)
 
 #elif defined(__TI_COMPILER_VERSION__)
-# define COMPILER_ID "TI"
-  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
-# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
-# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
-# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)
+#define COMPILER_ID "TI"
+/* __TI_COMPILER_VERSION__ = VVVRRRPPP */
+#define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__ / 1000000)
+#define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__ / 1000 % 1000)
+#define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__ % 1000)
 
 #elif defined(__CLANG_FUJITSU)
-# define COMPILER_ID "FujitsuClang"
-# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
-# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
-# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
-# define COMPILER_VERSION_INTERNAL_STR __clang_version__
-
+#define COMPILER_ID "FujitsuClang"
+#define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
+#define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
+#define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
+#define COMPILER_VERSION_INTERNAL_STR __clang_version__
 
 #elif defined(__FUJITSU)
-# define COMPILER_ID "Fujitsu"
-# if defined(__FCC_version__)
-#   define COMPILER_VERSION __FCC_version__
-# elif defined(__FCC_major__)
-#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
-#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
-#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
-# endif
-# if defined(__fcc_version)
-#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
-# elif defined(__FCC_VERSION)
-#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
-# endif
-
+#define COMPILER_ID "Fujitsu"
+#if defined(__FCC_version__)
+#define COMPILER_VERSION __FCC_version__
+#elif defined(__FCC_major__)
+#define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
+#define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
+#define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
+#endif
+#if defined(__fcc_version)
+#define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
+#elif defined(__FCC_VERSION)
+#define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
+#endif
 
 #elif defined(__ghs__)
-# define COMPILER_ID "GHS"
+#define COMPILER_ID "GHS"
 /* __GHS_VERSION_NUMBER = VVVVRP */
-# ifdef __GHS_VERSION_NUMBER
-# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
-# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
-# endif
+#ifdef __GHS_VERSION_NUMBER
+#define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
+#define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER % 10)
+#endif
 
 #elif defined(__TASKING__)
-# define COMPILER_ID "Tasking"
-  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
-  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
-# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)
+#define COMPILER_ID "Tasking"
+#define COMPILER_VERSION_MAJOR DEC(__VERSION__ / 1000)
+#define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
+#define COMPILER_VERSION_INTERNAL DEC(__VERSION__)
 
 #elif defined(__ORANGEC__)
-# define COMPILER_ID "OrangeC"
-# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
-# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
-# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)
+#define COMPILER_ID "OrangeC"
+#define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
+#define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
+#define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)
 
 #elif defined(__TINYC__)
-# define COMPILER_ID "TinyCC"
+#define COMPILER_ID "TinyCC"
 
 #elif defined(__BCC__)
-# define COMPILER_ID "Bruce"
+#define COMPILER_ID "Bruce"
 
 #elif defined(__SCO_VERSION__)
-# define COMPILER_ID "SCO"
+#define COMPILER_ID "SCO"
 
 #elif defined(__ARMCC_VERSION) && !defined(__clang__)
-# define COMPILER_ID "ARMCC"
+#define COMPILER_ID "ARMCC"
 #if __ARMCC_VERSION >= 1000000
-  /* __ARMCC_VERSION = VRRPPPP */
-  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
-  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
-  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
-#else
-  /* __ARMCC_VERSION = VRPPPP */
-  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
-  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
-  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
-#endif
-
+/* __ARMCC_VERSION = VRRPPPP */
+#define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION / 1000000)
+#define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION / 10000 % 100)
+#define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000)
+#else
+/* __ARMCC_VERSION = VRPPPP */
+#define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION / 100000)
+#define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION / 10000 % 10)
+#define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000)
+#endif
 
 #elif defined(__clang__) && defined(__apple_build_version__)
-# define COMPILER_ID "AppleClang"
-# if defined(_MSC_VER)
-#  define SIMULATE_ID "MSVC"
-# endif
-# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
-# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
-# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
-# if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
-#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
-# endif
-# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)
+#define COMPILER_ID "AppleClang"
+#if defined(_MSC_VER)
+#define SIMULATE_ID "MSVC"
+#endif
+#define COMPILER_VERSION_MAJOR DEC(__clang_major__)
+#define COMPILER_VERSION_MINOR DEC(__clang_minor__)
+#define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
+#if defined(_MSC_VER)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+#endif
+#define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)
 
 #elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
-# define COMPILER_ID "ARMClang"
-  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
-  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
-  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
-# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)
+#define COMPILER_ID "ARMClang"
+#define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION / 1000000)
+#define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION / 10000 % 100)
+#define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION / 100 % 100)
+#define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)
 
 #elif defined(__clang__) && defined(__ti__)
-# define COMPILER_ID "TIClang"
-  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
-  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
-  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
-# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)
+#define COMPILER_ID "TIClang"
+#define COMPILER_VERSION_MAJOR DEC(__ti_major__)
+#define COMPILER_VERSION_MINOR DEC(__ti_minor__)
+#define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
+#define COMPILER_VERSION_INTERNAL DEC(__ti_version__)
 
 #elif defined(__clang__)
-# define COMPILER_ID "Clang"
-# if defined(_MSC_VER)
-#  define SIMULATE_ID "MSVC"
-# endif
-# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
-# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
-# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
-# if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
-#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
-# endif
-
-#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
-# define COMPILER_ID "LCC"
-# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
-# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
-# if defined(__LCC_MINOR__)
-#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
-# endif
-# if defined(__GNUC__) && defined(__GNUC_MINOR__)
-#  define SIMULATE_ID "GNU"
-#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
-#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
-#  endif
-# endif
+#define COMPILER_ID "Clang"
+#if defined(_MSC_VER)
+#define SIMULATE_ID "MSVC"
+#endif
+#define COMPILER_VERSION_MAJOR DEC(__clang_major__)
+#define COMPILER_VERSION_MINOR DEC(__clang_minor__)
+#define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
+#if defined(_MSC_VER)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+#endif
+
+#elif defined(__LCC__) && \
+    (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
+#define COMPILER_ID "LCC"
+#define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
+#if defined(__LCC_MINOR__)
+#define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
+#endif
+#if defined(__GNUC__) && defined(__GNUC_MINOR__)
+#define SIMULATE_ID "GNU"
+#define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
+#define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
+#if defined(__GNUC_PATCHLEVEL__)
+#define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#endif
+#endif
 
 #elif defined(__GNUC__)
-# define COMPILER_ID "GNU"
-# define COMPILER_VERSION_MAJOR DEC(__GNUC__)
-# if defined(__GNUC_MINOR__)
-#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
-# endif
-# if defined(__GNUC_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "GNU"
+#define COMPILER_VERSION_MAJOR DEC(__GNUC__)
+#if defined(__GNUC_MINOR__)
+#define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
+#endif
+#if defined(__GNUC_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#endif
 
 #elif defined(_MSC_VER)
-# define COMPILER_ID "MSVC"
-  /* _MSC_VER = VVRR */
-# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
-# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
-# if defined(_MSC_FULL_VER)
-#  if _MSC_VER >= 1400
-    /* _MSC_FULL_VER = VVRRPPPPP */
-#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
-#  else
-    /* _MSC_FULL_VER = VVRRPPPP */
-#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
-#  endif
-# endif
-# if defined(_MSC_BUILD)
-#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
-# endif
+#define COMPILER_ID "MSVC"
+/* _MSC_VER = VVRR */
+#define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
+#if defined(_MSC_FULL_VER)
+#if _MSC_VER >= 1400
+/* _MSC_FULL_VER = VVRRPPPPP */
+#define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
+#else
+/* _MSC_FULL_VER = VVRRPPPP */
+#define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
+#endif
+#endif
+#if defined(_MSC_BUILD)
+#define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
+#endif
 
 #elif defined(_ADI_COMPILER)
-# define COMPILER_ID "ADSP"
+#define COMPILER_ID "ADSP"
 #if defined(__VERSIONNUM__)
-  /* __VERSIONNUM__ = 0xVVRRPPTT */
-#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
-#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
-#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
-#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
+/* __VERSIONNUM__ = 0xVVRRPPTT */
+#define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
+#define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
+#define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
+#define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
 #endif
 
 #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
-# define COMPILER_ID "IAR"
-# if defined(__VER__) && defined(__ICCARM__)
-#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
-#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
-#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
-#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
-# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
-#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
-#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
-#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
-#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
-# endif
+#define COMPILER_ID "IAR"
+#if defined(__VER__) && defined(__ICCARM__)
+#define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
+#define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
+#define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
+#define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
+#elif defined(__VER__) &&                                                    \
+    (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) ||   \
+     defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || \
+     defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
+#define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
+#define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100) * 100))
+#define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
+#define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
+#endif
 
 #elif defined(__SDCC_VERSION_MAJOR) || defined(SDCC)
-# define COMPILER_ID "SDCC"
-# if defined(__SDCC_VERSION_MAJOR)
-#  define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)
-#  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)
-#  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)
-# else
-  /* SDCC = VRP */
-#  define COMPILER_VERSION_MAJOR DEC(SDCC/100)
-#  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)
-#  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)
-# endif
-
+#define COMPILER_ID "SDCC"
+#if defined(__SDCC_VERSION_MAJOR)
+#define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)
+#define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)
+#define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)
+#else
+/* SDCC = VRP */
+#define COMPILER_VERSION_MAJOR DEC(SDCC / 100)
+#define COMPILER_VERSION_MINOR DEC(SDCC / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(SDCC % 10)
+#endif
 
 /* These compilers are either not known or too old to define an
   identification macro.  Try to identify the platform and guess that
   it is the native compiler.  */
 #elif defined(__hpux) || defined(__hpua)
-# define COMPILER_ID "HP"
+#define COMPILER_ID "HP"
 
 #else /* unknown compiler */
-# define COMPILER_ID ""
+#define COMPILER_ID ""
 #endif
 
 /* Construct the string literal in pieces to prevent the source from
    getting matched.  Store it in a pointer rather than an array
    because some compilers will just produce instructions to fill the
    array rather than assigning a pointer to a static array.  */
-char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
+char const* info_compiler =
+    "INFO"
+    ":"
+    "compiler[" COMPILER_ID "]";
 #ifdef SIMULATE_ID
-char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
+char const* info_simulate =
+    "INFO"
+    ":"
+    "simulate[" SIMULATE_ID "]";
 #endif
 
 #ifdef __QNXNTO__
-char const* qnxnto = "INFO" ":" "qnxnto[]";
+char const* qnxnto =
+    "INFO"
+    ":"
+    "qnxnto[]";
 #endif
 
 #if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
-char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
+char const* info_cray =
+    "INFO"
+    ":"
+    "compiler_wrapper[CrayPrgEnv]";
 #endif
 
 #define STRINGIFY_HELPER(X) #X
@@ -471,113 +481,114 @@

 
 /* Identify known platforms by name.  */
 #if defined(__linux) || defined(__linux__) || defined(linux)
-# define PLATFORM_ID "Linux"
+#define PLATFORM_ID "Linux"
 
 #elif defined(__MSYS__)
-# define PLATFORM_ID "MSYS"
+#define PLATFORM_ID "MSYS"
 
 #elif defined(__CYGWIN__)
-# define PLATFORM_ID "Cygwin"
+#define PLATFORM_ID "Cygwin"
 
 #elif defined(__MINGW32__)
-# define PLATFORM_ID "MinGW"
+#define PLATFORM_ID "MinGW"
 
 #elif defined(__APPLE__)
-# define PLATFORM_ID "Darwin"
+#define PLATFORM_ID "Darwin"
 
 #elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
-# define PLATFORM_ID "Windows"
+#define PLATFORM_ID "Windows"
 
 #elif defined(__FreeBSD__) || defined(__FreeBSD)
-# define PLATFORM_ID "FreeBSD"
+#define PLATFORM_ID "FreeBSD"
 
 #elif defined(__NetBSD__) || defined(__NetBSD)
-# define PLATFORM_ID "NetBSD"
+#define PLATFORM_ID "NetBSD"
 
 #elif defined(__OpenBSD__) || defined(__OPENBSD)
-# define PLATFORM_ID "OpenBSD"
+#define PLATFORM_ID "OpenBSD"
 
 #elif defined(__sun) || defined(sun)
-# define PLATFORM_ID "SunOS"
-
-#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
-# define PLATFORM_ID "AIX"
+#define PLATFORM_ID "SunOS"
+
+#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || \
+    defined(__aix__)
+#define PLATFORM_ID "AIX"
 
 #elif defined(__hpux) || defined(__hpux__)
-# define PLATFORM_ID "HP-UX"
+#define PLATFORM_ID "HP-UX"
 
 #elif defined(__HAIKU__)
-# define PLATFORM_ID "Haiku"
+#define PLATFORM_ID "Haiku"
 
 #elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
-# define PLATFORM_ID "BeOS"
+#define PLATFORM_ID "BeOS"
 
 #elif defined(__QNX__) || defined(__QNXNTO__)
-# define PLATFORM_ID "QNX"
+#define PLATFORM_ID "QNX"
 
 #elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
-# define PLATFORM_ID "Tru64"
+#define PLATFORM_ID "Tru64"
 
 #elif defined(__riscos) || defined(__riscos__)
-# define PLATFORM_ID "RISCos"
+#define PLATFORM_ID "RISCos"
 
 #elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
-# define PLATFORM_ID "SINIX"
+#define PLATFORM_ID "SINIX"
 
 #elif defined(__UNIX_SV__)
-# define PLATFORM_ID "UNIX_SV"
+#define PLATFORM_ID "UNIX_SV"
 
 #elif defined(__bsdos__)
-# define PLATFORM_ID "BSDOS"
+#define PLATFORM_ID "BSDOS"
 
 #elif defined(_MPRAS) || defined(MPRAS)
-# define PLATFORM_ID "MP-RAS"
+#define PLATFORM_ID "MP-RAS"
 
 #elif defined(__osf) || defined(__osf__)
-# define PLATFORM_ID "OSF1"
+#define PLATFORM_ID "OSF1"
 
 #elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
-# define PLATFORM_ID "SCO_SV"
+#define PLATFORM_ID "SCO_SV"
 
 #elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
-# define PLATFORM_ID "ULTRIX"
+#define PLATFORM_ID "ULTRIX"
 
 #elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
-# define PLATFORM_ID "Xenix"
+#define PLATFORM_ID "Xenix"
 
 #elif defined(__WATCOMC__)
-# if defined(__LINUX__)
-#  define PLATFORM_ID "Linux"
-
-# elif defined(__DOS__)
-#  define PLATFORM_ID "DOS"
-
-# elif defined(__OS2__)
-#  define PLATFORM_ID "OS2"
-
-# elif defined(__WINDOWS__)
-#  define PLATFORM_ID "Windows3x"
-
-# elif defined(__VXWORKS__)
-#  define PLATFORM_ID "VxWorks"
-
-# else /* unknown platform */
-#  define PLATFORM_ID
-# endif
+#if defined(__LINUX__)
+#define PLATFORM_ID "Linux"
+
+#elif defined(__DOS__)
+#define PLATFORM_ID "DOS"
+
+#elif defined(__OS2__)
+#define PLATFORM_ID "OS2"
+
+#elif defined(__WINDOWS__)
+#define PLATFORM_ID "Windows3x"
+
+#elif defined(__VXWORKS__)
+#define PLATFORM_ID "VxWorks"
+
+#else /* unknown platform */
+#define PLATFORM_ID
+#endif
 
 #elif defined(__INTEGRITY)
-# if defined(INT_178B)
-#  define PLATFORM_ID "Integrity178"
-
-# else /* regular Integrity */
-#  define PLATFORM_ID "Integrity"
-# endif
-
-# elif defined(_ADI_COMPILER)
-#  define PLATFORM_ID "ADSP"
+#if defined(INT_178B)
+#define PLATFORM_ID "Integrity178"
+
+#else /* regular Integrity */
+#define PLATFORM_ID "Integrity"
+#endif
+
+#elif defined(_ADI_COMPILER)
+#define PLATFORM_ID "ADSP"
 
 #else /* unknown platform */
-# define PLATFORM_ID
+#define PLATFORM_ID
 
 #endif
 
@@ -587,246 +598,295 @@

    but rather depend on which compiler is being used
 */
 #if defined(_WIN32) && defined(_MSC_VER)
-# if defined(_M_IA64)
-#  define ARCHITECTURE_ID "IA64"
-
-# elif defined(_M_ARM64EC)
-#  define ARCHITECTURE_ID "ARM64EC"
-
-# elif defined(_M_X64) || defined(_M_AMD64)
-#  define ARCHITECTURE_ID "x64"
-
-# elif defined(_M_IX86)
-#  define ARCHITECTURE_ID "X86"
-
-# elif defined(_M_ARM64)
-#  define ARCHITECTURE_ID "ARM64"
-
-# elif defined(_M_ARM)
-#  if _M_ARM == 4
-#   define ARCHITECTURE_ID "ARMV4I"
-#  elif _M_ARM == 5
-#   define ARCHITECTURE_ID "ARMV5I"
-#  else
-#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
-#  endif
-
-# elif defined(_M_MIPS)
-#  define ARCHITECTURE_ID "MIPS"
-
-# elif defined(_M_SH)
-#  define ARCHITECTURE_ID "SHx"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(_M_IA64)
+#define ARCHITECTURE_ID "IA64"
+
+#elif defined(_M_ARM64EC)
+#define ARCHITECTURE_ID "ARM64EC"
+
+#elif defined(_M_X64) || defined(_M_AMD64)
+#define ARCHITECTURE_ID "x64"
+
+#elif defined(_M_IX86)
+#define ARCHITECTURE_ID "X86"
+
+#elif defined(_M_ARM64)
+#define ARCHITECTURE_ID "ARM64"
+
+#elif defined(_M_ARM)
+#if _M_ARM == 4
+#define ARCHITECTURE_ID "ARMV4I"
+#elif _M_ARM == 5
+#define ARCHITECTURE_ID "ARMV5I"
+#else
+#define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
+#endif
+
+#elif defined(_M_MIPS)
+#define ARCHITECTURE_ID "MIPS"
+
+#elif defined(_M_SH)
+#define ARCHITECTURE_ID "SHx"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__WATCOMC__)
-# if defined(_M_I86)
-#  define ARCHITECTURE_ID "I86"
-
-# elif defined(_M_IX86)
-#  define ARCHITECTURE_ID "X86"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(_M_I86)
+#define ARCHITECTURE_ID "I86"
+
+#elif defined(_M_IX86)
+#define ARCHITECTURE_ID "X86"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
-# if defined(__ICCARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__ICCRX__)
-#  define ARCHITECTURE_ID "RX"
-
-# elif defined(__ICCRH850__)
-#  define ARCHITECTURE_ID "RH850"
-
-# elif defined(__ICCRL78__)
-#  define ARCHITECTURE_ID "RL78"
-
-# elif defined(__ICCRISCV__)
-#  define ARCHITECTURE_ID "RISCV"
-
-# elif defined(__ICCAVR__)
-#  define ARCHITECTURE_ID "AVR"
-
-# elif defined(__ICC430__)
-#  define ARCHITECTURE_ID "MSP430"
-
-# elif defined(__ICCV850__)
-#  define ARCHITECTURE_ID "V850"
-
-# elif defined(__ICC8051__)
-#  define ARCHITECTURE_ID "8051"
-
-# elif defined(__ICCSTM8__)
-#  define ARCHITECTURE_ID "STM8"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(__ICCARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__ICCRX__)
+#define ARCHITECTURE_ID "RX"
+
+#elif defined(__ICCRH850__)
+#define ARCHITECTURE_ID "RH850"
+
+#elif defined(__ICCRL78__)
+#define ARCHITECTURE_ID "RL78"
+
+#elif defined(__ICCRISCV__)
+#define ARCHITECTURE_ID "RISCV"
+
+#elif defined(__ICCAVR__)
+#define ARCHITECTURE_ID "AVR"
+
+#elif defined(__ICC430__)
+#define ARCHITECTURE_ID "MSP430"
+
+#elif defined(__ICCV850__)
+#define ARCHITECTURE_ID "V850"
+
+#elif defined(__ICC8051__)
+#define ARCHITECTURE_ID "8051"
+
+#elif defined(__ICCSTM8__)
+#define ARCHITECTURE_ID "STM8"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__ghs__)
-# if defined(__PPC64__)
-#  define ARCHITECTURE_ID "PPC64"
-
-# elif defined(__ppc__)
-#  define ARCHITECTURE_ID "PPC"
-
-# elif defined(__ARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__x86_64__)
-#  define ARCHITECTURE_ID "x64"
-
-# elif defined(__i386__)
-#  define ARCHITECTURE_ID "X86"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(__PPC64__)
+#define ARCHITECTURE_ID "PPC64"
+
+#elif defined(__ppc__)
+#define ARCHITECTURE_ID "PPC"
+
+#elif defined(__ARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__x86_64__)
+#define ARCHITECTURE_ID "x64"
+
+#elif defined(__i386__)
+#define ARCHITECTURE_ID "X86"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__clang__) && defined(__ti__)
-# if defined(__ARM_ARCH)
-#  define ARCHITECTURE_ID "ARM"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(__ARM_ARCH)
+#define ARCHITECTURE_ID "ARM"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__TI_COMPILER_VERSION__)
-# if defined(__TI_ARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__MSP430__)
-#  define ARCHITECTURE_ID "MSP430"
-
-# elif defined(__TMS320C28XX__)
-#  define ARCHITECTURE_ID "TMS320C28x"
-
-# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
-#  define ARCHITECTURE_ID "TMS320C6x"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
-
-# elif defined(__ADSPSHARC__)
-#  define ARCHITECTURE_ID "SHARC"
-
-# elif defined(__ADSPBLACKFIN__)
-#  define ARCHITECTURE_ID "Blackfin"
+#if defined(__TI_ARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__MSP430__)
+#define ARCHITECTURE_ID "MSP430"
+
+#elif defined(__TMS320C28XX__)
+#define ARCHITECTURE_ID "TMS320C28x"
+
+#elif defined(__TMS320C6X__) || defined(_TMS320C6X)
+#define ARCHITECTURE_ID "TMS320C6x"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
+
+#elif defined(__ADSPSHARC__)
+#define ARCHITECTURE_ID "SHARC"
+
+#elif defined(__ADSPBLACKFIN__)
+#define ARCHITECTURE_ID "Blackfin"
 
 #elif defined(__TASKING__)
 
-# if defined(__CTC__) || defined(__CPTC__)
-#  define ARCHITECTURE_ID "TriCore"
-
-# elif defined(__CMCS__)
-#  define ARCHITECTURE_ID "MCS"
-
-# elif defined(__CARM__) || defined(__CPARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__CARC__)
-#  define ARCHITECTURE_ID "ARC"
-
-# elif defined(__C51__)
-#  define ARCHITECTURE_ID "8051"
-
-# elif defined(__CPCP__)
-#  define ARCHITECTURE_ID "PCP"
-
-# else
-#  define ARCHITECTURE_ID ""
-# endif
-
-#else
-#  define ARCHITECTURE_ID
+#if defined(__CTC__) || defined(__CPTC__)
+#define ARCHITECTURE_ID "TriCore"
+
+#elif defined(__CMCS__)
+#define ARCHITECTURE_ID "MCS"
+
+#elif defined(__CARM__) || defined(__CPARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__CARC__)
+#define ARCHITECTURE_ID "ARC"
+
+#elif defined(__C51__)
+#define ARCHITECTURE_ID "8051"
+
+#elif defined(__CPCP__)
+#define ARCHITECTURE_ID "PCP"
+
+#else
+#define ARCHITECTURE_ID ""
+#endif
+
+#else
+#define ARCHITECTURE_ID
 #endif
 
 /* Convert integer to decimal digit literals.  */
-#define DEC(n)                   \
-  ('0' + (((n) / 10000000)%10)), \
-  ('0' + (((n) / 1000000)%10)),  \
-  ('0' + (((n) / 100000)%10)),   \
-  ('0' + (((n) / 10000)%10)),    \
-  ('0' + (((n) / 1000)%10)),     \
-  ('0' + (((n) / 100)%10)),      \
-  ('0' + (((n) / 10)%10)),       \
-  ('0' +  ((n) % 10))
+#define DEC(n)                                                     \
+  ('0' + (((n) / 10000000) % 10)), ('0' + (((n) / 1000000) % 10)), \
+      ('0' + (((n) / 100000) % 10)), ('0' + (((n) / 10000) % 10)), \
+      ('0' + (((n) / 1000) % 10)), ('0' + (((n) / 100) % 10)),     \
+      ('0' + (((n) / 10) % 10)), ('0' + ((n) % 10))
 
 /* Convert integer to hex digit literals.  */
-#define HEX(n)             \
-  ('0' + ((n)>>28 & 0xF)), \
-  ('0' + ((n)>>24 & 0xF)), \
-  ('0' + ((n)>>20 & 0xF)), \
-  ('0' + ((n)>>16 & 0xF)), \
-  ('0' + ((n)>>12 & 0xF)), \
-  ('0' + ((n)>>8  & 0xF)), \
-  ('0' + ((n)>>4  & 0xF)), \
-  ('0' + ((n)     & 0xF))
+#define HEX(n)                                              \
+  ('0' + ((n) >> 28 & 0xF)), ('0' + ((n) >> 24 & 0xF)),     \
+      ('0' + ((n) >> 20 & 0xF)), ('0' + ((n) >> 16 & 0xF)), \
+      ('0' + ((n) >> 12 & 0xF)), ('0' + ((n) >> 8 & 0xF)),  \
+      ('0' + ((n) >> 4 & 0xF)), ('0' + ((n) & 0xF))
 
 /* Construct a string literal encoding the version number. */
 #ifdef COMPILER_VERSION
-char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";
+char const* info_version =
+    "INFO"
+    ":"
+    "compiler_version[" COMPILER_VERSION "]";
 
 /* Construct a string literal encoding the version number components. */
 #elif defined(COMPILER_VERSION_MAJOR)
-char const info_version[] = {
-  'I', 'N', 'F', 'O', ':',
-  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
-  COMPILER_VERSION_MAJOR,
-# ifdef COMPILER_VERSION_MINOR
-  '.', COMPILER_VERSION_MINOR,
-#  ifdef COMPILER_VERSION_PATCH
-   '.', COMPILER_VERSION_PATCH,
-#   ifdef COMPILER_VERSION_TWEAK
-    '.', COMPILER_VERSION_TWEAK,
-#   endif
-#  endif
-# endif
-  ']','\0'};
+char const info_version[] = {'I',
+                             'N',
+                             'F',
+                             'O',
+                             ':',
+                             'c',
+                             'o',
+                             'm',
+                             'p',
+                             'i',
+                             'l',
+                             'e',
+                             'r',
+                             '_',
+                             'v',
+                             'e',
+                             'r',
+                             's',
+                             'i',
+                             'o',
+                             'n',
+                             '[',
+                             COMPILER_VERSION_MAJOR,
+#ifdef COMPILER_VERSION_MINOR
+                             '.',
+                             COMPILER_VERSION_MINOR,
+#ifdef COMPILER_VERSION_PATCH
+                             '.',
+                             COMPILER_VERSION_PATCH,
+#ifdef COMPILER_VERSION_TWEAK
+                             '.',
+                             COMPILER_VERSION_TWEAK,
+#endif
+#endif
+#endif
+                             ']',
+                             '\0'};
 #endif
 
 /* Construct a string literal encoding the internal version number. */
 #ifdef COMPILER_VERSION_INTERNAL
 char const info_version_internal[] = {
-  'I', 'N', 'F', 'O', ':',
-  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
-  'i','n','t','e','r','n','a','l','[',
-  COMPILER_VERSION_INTERNAL,']','\0'};
+    'I', 'N', 'F', 'O', ':', 'c', 'o', 'm',
+    'p', 'i', 'l', 'e', 'r', '_', 'v', 'e',
+    'r', 's', 'i', 'o', 'n', '_', 'i', 'n',
+    't', 'e', 'r', 'n', 'a', 'l', '[', COMPILER_VERSION_INTERNAL,
+    ']', '\0'};
 #elif defined(COMPILER_VERSION_INTERNAL_STR)
-char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
+char const* info_version_internal =
+    "INFO"
+    ":"
+    "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
 #endif
 
 /* Construct a string literal encoding the version number components. */
 #ifdef SIMULATE_VERSION_MAJOR
-char const info_simulate_version[] = {
-  'I', 'N', 'F', 'O', ':',
-  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
-  SIMULATE_VERSION_MAJOR,
-# ifdef SIMULATE_VERSION_MINOR
-  '.', SIMULATE_VERSION_MINOR,
-#  ifdef SIMULATE_VERSION_PATCH
-   '.', SIMULATE_VERSION_PATCH,
-#   ifdef SIMULATE_VERSION_TWEAK
-    '.', SIMULATE_VERSION_TWEAK,
-#   endif
-#  endif
-# endif
-  ']','\0'};
+char const info_simulate_version[] = {'I',
+                                      'N',
+                                      'F',
+                                      'O',
+                                      ':',
+                                      's',
+                                      'i',
+                                      'm',
+                                      'u',
+                                      'l',
+                                      'a',
+                                      't',
+                                      'e',
+                                      '_',
+                                      'v',
+                                      'e',
+                                      'r',
+                                      's',
+                                      'i',
+                                      'o',
+                                      'n',
+                                      '[',
+                                      SIMULATE_VERSION_MAJOR,
+#ifdef SIMULATE_VERSION_MINOR
+                                      '.',
+                                      SIMULATE_VERSION_MINOR,
+#ifdef SIMULATE_VERSION_PATCH
+                                      '.',
+                                      SIMULATE_VERSION_PATCH,
+#ifdef SIMULATE_VERSION_TWEAK
+                                      '.',
+                                      SIMULATE_VERSION_TWEAK,
+#endif
+#endif
+#endif
+                                      ']',
+                                      '\0'};
 #endif
 
 /* Construct the string literal in pieces to prevent the source from
    getting matched.  Store it in a pointer rather than an array
    because some compilers will just produce instructions to fill the
    array rather than assigning a pointer to a static array.  */
-char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
-char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";
-
-
+char const* info_platform =
+    "INFO"
+    ":"
+    "platform[" PLATFORM_ID "]";
+char const* info_arch =
+    "INFO"
+    ":"
+    "arch[" ARCHITECTURE_ID "]";
 
 #define C_STD_99 199901L
 #define C_STD_11 201112L
@@ -834,49 +894,56 @@

 #define C_STD_23 202311L
 
 #ifdef __STDC_VERSION__
-#  define C_STD __STDC_VERSION__
+#define C_STD __STDC_VERSION__
 #endif
 
 #if !defined(__STDC__) && !defined(__clang__)
-# if defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)
-#  define C_VERSION "90"
-# else
-#  define C_VERSION
-# endif
+#if defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)
+#define C_VERSION "90"
+#else
+#define C_VERSION
+#endif
 #elif C_STD > C_STD_17
-# define C_VERSION "23"
+#define C_VERSION "23"
 #elif C_STD > C_STD_11
-# define C_VERSION "17"
+#define C_VERSION "17"
 #elif C_STD > C_STD_99
-# define C_VERSION "11"
+#define C_VERSION "11"
 #elif C_STD >= C_STD_99
-# define C_VERSION "99"
-#else
-# define C_VERSION "90"
+#define C_VERSION "99"
+#else
+#define C_VERSION "90"
 #endif
 const char* info_language_standard_default =
-  "INFO" ":" "standard_default[" C_VERSION "]";
-
-const char* info_language_extensions_default = "INFO" ":" "extensions_default["
-#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
-     defined(__TI_COMPILER_VERSION__)) &&                                     \
-  !defined(__STRICT_ANSI__)
-  "ON"
-#else
-  "OFF"
-#endif
-"]";
+    "INFO"
+    ":"
+    "standard_default[" C_VERSION "]";
+
+const char* info_language_extensions_default =
+    "INFO"
+    ":"
+    "extensions_default["
+#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) || \
+     defined(__TI_COMPILER_VERSION__)) &&                           \
+    !defined(__STRICT_ANSI__)
+    "ON"
+#else
+    "OFF"
+#endif
+    "]";
 
 /*--------------------------------------------------------------------------*/
 
 #ifdef ID_VOID_MAIN
 void main() {}
 #else
-# if defined(__CLASSIC_C__)
-int main(argc, argv) int argc; char *argv[];
-# else
+#if defined(__CLASSIC_C__)
+int main(argc, argv)
+int argc;
+char* argv[];
+#else
 int main(int argc, char* argv[])
-# endif
+#endif
 {
   int require = 0;
   require += info_compiler[argc];
tests/mechanical_layer/src/InputStatic.cpp
====================
--- original

+++ formatted

@@ -8,437 +8,516 @@

  * @return EXIT_FAILURE if issue in the XML file (missing or unreadable field)
  *         EXIT_SUCCESS otherwise
  */
-int readParameters(const string& file)
-{
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse Parameters file " << file << endl;
-        return EXIT_FAILURE;
-    }
-    /*  Read the Parameters block */
-    tinyxml2::XMLElement* parametersElement = document.FirstChildElement("Parameters");
-    if (!parametersElement) {
-        cerr << "Error: Parameters must be embedded in \"Parameters\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-    /*  Read times */
-    const tinyxml2::XMLElement* timesElement = parametersElement->FirstChildElement("Times");
-    if (!timesElement) {
-        cerr << "Error: no Times present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    if (timesElement->QueryDoubleAttribute("TimeStep", &dt) != tinyxml2::XML_SUCCESS) {
-        cerr << R"(Error: Could not read "TimeStep" attribute in )" << file << endl;
-        return EXIT_FAILURE;
-    }
-    if (timesElement->QueryDoubleAttribute("TimeStepMechanical", &dt_mech) != tinyxml2::XML_SUCCESS) {
-        cerr << R"(Error: Could not read "TimeStepMechanical" attribute in )" << file << endl;
-        return EXIT_FAILURE;
-    }
-    /// Process Id: UNUSED
-    const tinyxml2::XMLElement* processElement = parametersElement->FirstChildElement("Process");
-    if (!processElement) {
-        cerr << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))" << endl;
-        return EXIT_FAILURE;
-    }
-    if (processElement->QueryStringAttribute("Id", &processId) != tinyxml2::XML_SUCCESS) {
-        cerr << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))" << endl;
-        return EXIT_FAILURE;
-    }
-    /*  Input and Output directories: if not present, we leave the default as is    */
-    const char* staticDirectory, *dynamicDirectory;
-    if (const tinyxml2::XMLElement* directoriesElement = parametersElement->FirstChildElement("Directories")) {
-        if (directoriesElement->QueryStringAttribute("Static", &staticDirectory) == tinyxml2::XML_SUCCESS)
-            pathStatic = staticDirectory;
-        if (directoriesElement->QueryStringAttribute("Dynamic", &dynamicDirectory) == tinyxml2::XML_SUCCESS)
-            pathDynamic = dynamicDirectory;
-    }
-
-    return EXIT_SUCCESS;
+int readParameters(const string& file) {
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse Parameters file " << file << endl;
+    return EXIT_FAILURE;
+  }
+  /*  Read the Parameters block */
+  tinyxml2::XMLElement* parametersElement =
+      document.FirstChildElement("Parameters");
+  if (!parametersElement) {
+    cerr << "Error: Parameters must be embedded in \"Parameters\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+  /*  Read times */
+  const tinyxml2::XMLElement* timesElement =
+      parametersElement->FirstChildElement("Times");
+  if (!timesElement) {
+    cerr << "Error: no Times present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  if (timesElement->QueryDoubleAttribute("TimeStep", &dt) !=
+      tinyxml2::XML_SUCCESS) {
+    cerr << R"(Error: Could not read "TimeStep" attribute in )" << file << endl;
+    return EXIT_FAILURE;
+  }
+  if (timesElement->QueryDoubleAttribute("TimeStepMechanical", &dt_mech) !=
+      tinyxml2::XML_SUCCESS) {
+    cerr << R"(Error: Could not read "TimeStepMechanical" attribute in )"
+         << file << endl;
+    return EXIT_FAILURE;
+  }
+  /// Process Id: UNUSED
+  const tinyxml2::XMLElement* processElement =
+      parametersElement->FirstChildElement("Process");
+  if (!processElement) {
+    cerr
+        << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))"
+        << endl;
+    return EXIT_FAILURE;
+  }
+  if (processElement->QueryStringAttribute("Id", &processId) !=
+      tinyxml2::XML_SUCCESS) {
+    cerr
+        << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))"
+        << endl;
+    return EXIT_FAILURE;
+  }
+  /*  Input and Output directories: if not present, we leave the default as is
+   */
+  const char *staticDirectory, *dynamicDirectory;
+  if (const tinyxml2::XMLElement* directoriesElement =
+          parametersElement->FirstChildElement("Directories")) {
+    if (directoriesElement->QueryStringAttribute("Static", &staticDirectory) ==
+        tinyxml2::XML_SUCCESS)
+      pathStatic = staticDirectory;
+    if (directoriesElement->QueryStringAttribute(
+            "Dynamic", &dynamicDirectory) == tinyxml2::XML_SUCCESS)
+      pathDynamic = dynamicDirectory;
+  }
+
+  return EXIT_SUCCESS;
 }
 /**
  * @brief Reads the Materials XML file.
  * @param file The name of the file
- * @param materialMapping The mapping of user-provided material ids and our internal id
+ * @param materialMapping The mapping of user-provided material ids and our
+ * internal id
  * @return EXIT_FAILURE if issue in the XML file (missing or unreadable field)
  *         EXIT_SUCCESS otherwise
  */
-int readMaterials(const string& file, map<string, int32_t>& materialMapping)
-{
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << file << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Read the Materials block */
-    tinyxml2::XMLElement* materialsElement = document.FirstChildElement("Materials");
-    if (!materialsElement) {
-        cerr << "Error: Information about materials must be embedded in \"Materials\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Read intrinsic properties */
-    const tinyxml2::XMLElement* intrinsicElement = materialsElement->FirstChildElement("Intrinsic");
-    if (!intrinsicElement) {
-        cerr << "Error: no Intrinsic tag present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    /// Materials
-    vector<double2> elasticProperties;
-    const tinyxml2::XMLElement* materialElement  = intrinsicElement->FirstChildElement("Material");
-    if (!materialElement) {
-        cerr << "Error: no materials in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    nMaterials = 0;
-    while (materialElement) {
-        const char* id = nullptr;
-        if (materialElement->QueryStringAttribute("Id", &id) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: found material with no id in " << file << endl;
-        };
-        materialMapping[id] = static_cast<int32_t>(nDefaultMaterials + nMaterials);
-        double E, G;
-        if (materialElement->QueryDoubleAttribute("YoungModulus", &E) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material id " << id << ": Young's modulus (E) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        if (materialElement->QueryDoubleAttribute("ShearModulus", &G) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material id " << id << ": Shear modulus (G) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        elasticProperties.emplace_back(E, G);
-
-        materialElement = materialElement->NextSiblingElement("Material");
-        nMaterials++;
-    }
-    /*  Allocate global variables, now that we know the materials   */
-    intrinsicProperties = new double*[nIntrinsicProperties];
-    for (uint32_t i = 0; i < nIntrinsicProperties; i++) {
-        intrinsicProperties[i] = new double[nDefaultMaterials + nMaterials];
-    }
-    //  Populate intrinsic parameters
-    for (uint32_t i = 0; i < nMaterials; i++) {
-        intrinsicProperties[YOUNG_MODULUS][nDefaultMaterials + i]   = elasticProperties[i].first;
-        intrinsicProperties[SHEAR_MODULUS][nDefaultMaterials + i]   = elasticProperties[i].second;
-    }
-    //  Default materials
-    intrinsicProperties[YOUNG_MODULUS][PEDESTRIAN]   = E_pedestrian;
-    intrinsicProperties[SHEAR_MODULUS][PEDESTRIAN]   = G_pedestrian;
-    intrinsicProperties[YOUNG_MODULUS][WALL]   = E_wall;
-    intrinsicProperties[SHEAR_MODULUS][WALL]   = G_wall;
-
-
-    binaryProperties = new double**[nBinaryProperties];
-    for (uint32_t i = 0; i < nBinaryProperties; i++) {
-        binaryProperties[i] = new double*[nDefaultMaterials + nMaterials];
-        for (uint32_t j = 0; j <  nDefaultMaterials + nMaterials; j++) {
-            binaryProperties[i][j] = new double[nDefaultMaterials + nMaterials];
-        }
-    }
-    /// Find stiffness combinations from intrinsic properties
-    for (uint32_t i = 0; i < nDefaultMaterials + nMaterials; i++) {
-        for (uint32_t j = 0; j < nDefaultMaterials + nMaterials; j++) {
-            double stiffnessNormal      = computeStiffnessNormal(i, j);
-            binaryProperties[STIFFNESS_NORMAL][j][i]     = stiffnessNormal;
-            binaryProperties[STIFFNESS_NORMAL][i][j]     = stiffnessNormal;
-            double stiffnessTangential  = computeStiffnessTangential(i, j);
-            binaryProperties[STIFFNESS_TANGENTIAL][j][i] = stiffnessTangential;
-            binaryProperties[STIFFNESS_TANGENTIAL][i][j] = stiffnessTangential;
-        }
-    }
-
-    /// Populate binaryProperties for default materials
-    binaryProperties[DAMPING_NORMAL][PEDESTRIAN][PEDESTRIAN]        = gamma_n;
-    binaryProperties[DAMPING_NORMAL][PEDESTRIAN][WALL]              = gamma_n_wall;
-    binaryProperties[DAMPING_NORMAL][WALL][PEDESTRIAN]              = gamma_n_wall;
-    binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][PEDESTRIAN]    = gamma_t;
-    binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][WALL]          = gamma_t_wall;
-    binaryProperties[DAMPING_TANGENTIAL][WALL][PEDESTRIAN]          = gamma_t_wall;
-    binaryProperties[FRICTION_SLIDING][PEDESTRIAN][PEDESTRIAN]      = mu_dyn;
-    binaryProperties[FRICTION_SLIDING][PEDESTRIAN][WALL]            = mu_dyn_wall;
-    binaryProperties[FRICTION_SLIDING][WALL][PEDESTRIAN]            = mu_dyn_wall;
-    for (uint32_t i = nDefaultMaterials; i < nDefaultMaterials + nMaterials; i++) {
-        binaryProperties[DAMPING_NORMAL][PEDESTRIAN][i] = gamma_n;
-        binaryProperties[DAMPING_NORMAL][i][PEDESTRIAN] = gamma_n;
-        binaryProperties[DAMPING_NORMAL][WALL][i] = gamma_n_wall;
-        binaryProperties[DAMPING_NORMAL][i][WALL] = gamma_n_wall;
-        binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][i] = gamma_t;
-        binaryProperties[DAMPING_TANGENTIAL][i][PEDESTRIAN] = gamma_t;
-        binaryProperties[DAMPING_TANGENTIAL][WALL][i] = gamma_t_wall;
-        binaryProperties[DAMPING_TANGENTIAL][i][WALL] = gamma_t_wall;
-        binaryProperties[FRICTION_SLIDING][PEDESTRIAN][i] = mu_dyn;
-        binaryProperties[FRICTION_SLIDING][i][PEDESTRIAN] = mu_dyn;
-        binaryProperties[FRICTION_SLIDING][WALL][i] = mu_dyn_wall;
-        binaryProperties[FRICTION_SLIDING][i][WALL] = mu_dyn_wall;
-    }
-
-    /*  Read relationships for the rest of the binary properties    */
-    const tinyxml2::XMLElement* relationshipsElement = materialsElement->FirstChildElement("Binary");
-    if (!relationshipsElement) {
-        cerr << "Error: no Binary tag present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    const tinyxml2::XMLElement* relationshipElement = relationshipsElement->FirstChildElement("Contact");
-    if (!relationshipElement) {
-        cerr << "Error: no relationships in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    while (relationshipElement) {
-        const char* id1 = nullptr;
-        const char* id2 = nullptr;
-        relationshipElement->QueryStringAttribute("Id1", &id1);
-        relationshipElement->QueryStringAttribute("Id2", &id2);
-        if (!materialMapping.contains(id1) or !materialMapping.contains(id2)) {
-            cerr << "Error: relationships include unknown material ids " << id1 << "or " << id2 << "." << endl;
-            return EXIT_FAILURE;
-        }
-        double gamma_n, gamma_t, mu_d;
-        if (relationshipElement->QueryDoubleAttribute("GammaNormal", &gamma_n) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material ids " << id1 << "-" << id2 << ": normal damping (GammaNormal) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        if (relationshipElement->QueryDoubleAttribute("GammaTangential", &gamma_t) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material ids " << id1 << "-" << id2 << ": tangential damping (GammaTangential) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        if (relationshipElement->QueryDoubleAttribute("KineticFriction", &mu_d) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material ids " << id1 << "-" << id2 << ": kinetic friction (KineticFriction) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        //  Fill the remaining slots in the symmetric binaryProperties matrix
-        binaryProperties[DAMPING_NORMAL][materialMapping[id1]][materialMapping[id2]] = gamma_n;
-        binaryProperties[DAMPING_NORMAL][materialMapping[id2]][materialMapping[id1]] = gamma_n;
-        binaryProperties[DAMPING_TANGENTIAL][materialMapping[id1]][materialMapping[id2]] = gamma_t;
-        binaryProperties[DAMPING_TANGENTIAL][materialMapping[id2]][materialMapping[id1]] = gamma_t;
-        binaryProperties[FRICTION_SLIDING][materialMapping[id1]][materialMapping[id2]] = mu_d;
-        binaryProperties[FRICTION_SLIDING][materialMapping[id2]][materialMapping[id1]] = mu_d;
-        relationshipElement = relationshipElement->NextSiblingElement("Contact");
-    }
-
-    return EXIT_SUCCESS;
+int readMaterials(const string& file, map<string, int32_t>& materialMapping) {
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << file << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read the Materials block */
+  tinyxml2::XMLElement* materialsElement =
+      document.FirstChildElement("Materials");
+  if (!materialsElement) {
+    cerr << "Error: Information about materials must be embedded in "
+            "\"Materials\" tag!"
+         << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read intrinsic properties */
+  const tinyxml2::XMLElement* intrinsicElement =
+      materialsElement->FirstChildElement("Intrinsic");
+  if (!intrinsicElement) {
+    cerr << "Error: no Intrinsic tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  /// Materials
+  vector<double2> elasticProperties;
+  const tinyxml2::XMLElement* materialElement =
+      intrinsicElement->FirstChildElement("Material");
+  if (!materialElement) {
+    cerr << "Error: no materials in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  nMaterials = 0;
+  while (materialElement) {
+    const char* id = nullptr;
+    if (materialElement->QueryStringAttribute("Id", &id) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: found material with no id in " << file << endl;
+    };
+    materialMapping[id] = static_cast<int32_t>(nDefaultMaterials + nMaterials);
+    double E, G;
+    if (materialElement->QueryDoubleAttribute("YoungModulus", &E) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material id " << id
+           << ": Young's modulus (E) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    if (materialElement->QueryDoubleAttribute("ShearModulus", &G) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material id " << id
+           << ": Shear modulus (G) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    elasticProperties.emplace_back(E, G);
+
+    materialElement = materialElement->NextSiblingElement("Material");
+    nMaterials++;
+  }
+  /*  Allocate global variables, now that we know the materials   */
+  intrinsicProperties = new double*[nIntrinsicProperties];
+  for (uint32_t i = 0; i < nIntrinsicProperties; i++) {
+    intrinsicProperties[i] = new double[nDefaultMaterials + nMaterials];
+  }
+  //  Populate intrinsic parameters
+  for (uint32_t i = 0; i < nMaterials; i++) {
+    intrinsicProperties[YOUNG_MODULUS][nDefaultMaterials + i] =
+        elasticProperties[i].first;
+    intrinsicProperties[SHEAR_MODULUS][nDefaultMaterials + i] =
+        elasticProperties[i].second;
+  }
+  //  Default materials
+  intrinsicProperties[YOUNG_MODULUS][PEDESTRIAN] = E_pedestrian;
+  intrinsicProperties[SHEAR_MODULUS][PEDESTRIAN] = G_pedestrian;
+  intrinsicProperties[YOUNG_MODULUS][WALL] = E_wall;
+  intrinsicProperties[SHEAR_MODULUS][WALL] = G_wall;
+
+  binaryProperties = new double**[nBinaryProperties];
+  for (uint32_t i = 0; i < nBinaryProperties; i++) {
+    binaryProperties[i] = new double*[nDefaultMaterials + nMaterials];
+    for (uint32_t j = 0; j < nDefaultMaterials + nMaterials; j++) {
+      binaryProperties[i][j] = new double[nDefaultMaterials + nMaterials];
+    }
+  }
+  /// Find stiffness combinations from intrinsic properties
+  for (uint32_t i = 0; i < nDefaultMaterials + nMaterials; i++) {
+    for (uint32_t j = 0; j < nDefaultMaterials + nMaterials; j++) {
+      double stiffnessNormal = computeStiffnessNormal(i, j);
+      binaryProperties[STIFFNESS_NORMAL][j][i] = stiffnessNormal;
+      binaryProperties[STIFFNESS_NORMAL][i][j] = stiffnessNormal;
+      double stiffnessTangential = computeStiffnessTangential(i, j);
+      binaryProperties[STIFFNESS_TANGENTIAL][j][i] = stiffnessTangential;
+      binaryProperties[STIFFNESS_TANGENTIAL][i][j] = stiffnessTangential;
+    }
+  }
+
+  /// Populate binaryProperties for default materials
+  binaryProperties[DAMPING_NORMAL][PEDESTRIAN][PEDESTRIAN] = gamma_n;
+  binaryProperties[DAMPING_NORMAL][PEDESTRIAN][WALL] = gamma_n_wall;
+  binaryProperties[DAMPING_NORMAL][WALL][PEDESTRIAN] = gamma_n_wall;
+  binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][PEDESTRIAN] = gamma_t;
+  binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][WALL] = gamma_t_wall;
+  binaryProperties[DAMPING_TANGENTIAL][WALL][PEDESTRIAN] = gamma_t_wall;
+  binaryProperties[FRICTION_SLIDING][PEDESTRIAN][PEDESTRIAN] = mu_dyn;
+  binaryProperties[FRICTION_SLIDING][PEDESTRIAN][WALL] = mu_dyn_wall;
+  binaryProperties[FRICTION_SLIDING][WALL][PEDESTRIAN] = mu_dyn_wall;
+  for (uint32_t i = nDefaultMaterials; i < nDefaultMaterials + nMaterials;
+       i++) {
+    binaryProperties[DAMPING_NORMAL][PEDESTRIAN][i] = gamma_n;
+    binaryProperties[DAMPING_NORMAL][i][PEDESTRIAN] = gamma_n;
+    binaryProperties[DAMPING_NORMAL][WALL][i] = gamma_n_wall;
+    binaryProperties[DAMPING_NORMAL][i][WALL] = gamma_n_wall;
+    binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][i] = gamma_t;
+    binaryProperties[DAMPING_TANGENTIAL][i][PEDESTRIAN] = gamma_t;
+    binaryProperties[DAMPING_TANGENTIAL][WALL][i] = gamma_t_wall;
+    binaryProperties[DAMPING_TANGENTIAL][i][WALL] = gamma_t_wall;
+    binaryProperties[FRICTION_SLIDING][PEDESTRIAN][i] = mu_dyn;
+    binaryProperties[FRICTION_SLIDING][i][PEDESTRIAN] = mu_dyn;
+    binaryProperties[FRICTION_SLIDING][WALL][i] = mu_dyn_wall;
+    binaryProperties[FRICTION_SLIDING][i][WALL] = mu_dyn_wall;
+  }
+
+  /*  Read relationships for the rest of the binary properties    */
+  const tinyxml2::XMLElement* relationshipsElement =
+      materialsElement->FirstChildElement("Binary");
+  if (!relationshipsElement) {
+    cerr << "Error: no Binary tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  const tinyxml2::XMLElement* relationshipElement =
+      relationshipsElement->FirstChildElement("Contact");
+  if (!relationshipElement) {
+    cerr << "Error: no relationships in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  while (relationshipElement) {
+    const char* id1 = nullptr;
+    const char* id2 = nullptr;
+    relationshipElement->QueryStringAttribute("Id1", &id1);
+    relationshipElement->QueryStringAttribute("Id2", &id2);
+    if (!materialMapping.contains(id1) or !materialMapping.contains(id2)) {
+      cerr << "Error: relationships include unknown material ids " << id1
+           << "or " << id2 << "." << endl;
+      return EXIT_FAILURE;
+    }
+    double gamma_n, gamma_t, mu_d;
+    if (relationshipElement->QueryDoubleAttribute("GammaNormal", &gamma_n) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material ids " << id1 << "-" << id2
+           << ": normal damping (GammaNormal) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    if (relationshipElement->QueryDoubleAttribute(
+            "GammaTangential", &gamma_t) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material ids " << id1 << "-" << id2
+           << ": tangential damping (GammaTangential) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    if (relationshipElement->QueryDoubleAttribute("KineticFriction", &mu_d) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material ids " << id1 << "-" << id2
+           << ": kinetic friction (KineticFriction) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    //  Fill the remaining slots in the symmetric binaryProperties matrix
+    binaryProperties[DAMPING_NORMAL][materialMapping[id1]]
+                    [materialMapping[id2]] = gamma_n;
+    binaryProperties[DAMPING_NORMAL][materialMapping[id2]]
+                    [materialMapping[id1]] = gamma_n;
+    binaryProperties[DAMPING_TANGENTIAL][materialMapping[id1]]
+                    [materialMapping[id2]] = gamma_t;
+    binaryProperties[DAMPING_TANGENTIAL][materialMapping[id2]]
+                    [materialMapping[id1]] = gamma_t;
+    binaryProperties[FRICTION_SLIDING][materialMapping[id1]]
+                    [materialMapping[id2]] = mu_d;
+    binaryProperties[FRICTION_SLIDING][materialMapping[id2]]
+                    [materialMapping[id1]] = mu_d;
+    relationshipElement = relationshipElement->NextSiblingElement("Contact");
+  }
+
+  return EXIT_SUCCESS;
 }
 /**
  * @brief Reads the Geometry XML file.
  * @param file The name of the file
- * @param materialMapping The known mapping between user-provided material ids and our ids for them
+ * @param materialMapping The known mapping between user-provided material ids
+ * and our ids for them
  * @return EXIT_FAILURE if issue in the XML file (missing or unreadable field)
  *         EXIT_SUCCESS otherwise
  */
-int readGeometry(const string& file, map<string, int32_t>& materialMapping)
-{
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << file << endl;
+int readGeometry(const string& file, map<string, int32_t>& materialMapping) {
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << file << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read the Geometry block */
+  tinyxml2::XMLElement* geometryElement =
+      document.FirstChildElement("Geometry");
+  if (!geometryElement) {
+    cerr << "Error: Information about geometry must be embedded in "
+            "\"Geometry\" tag!"
+         << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read dimensions */
+  const tinyxml2::XMLElement* dimensionsElement =
+      geometryElement->FirstChildElement("Dimensions");
+  if (!dimensionsElement) {
+    cerr << "Error: no Dimensions tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  if (dimensionsElement->QueryDoubleAttribute("Lx", &Lx) !=
+      tinyxml2::XML_SUCCESS) {
+    cerr << "Error: Could not parse domain dimensions from XML file " << file
+         << endl;
+    return EXIT_FAILURE;
+  };
+  if (dimensionsElement->QueryDoubleAttribute("Ly", &Ly) !=
+      tinyxml2::XML_SUCCESS) {
+    cerr << "Error: Could not parse domain dimensions from XML file " << file
+         << endl;
+    return EXIT_FAILURE;
+  };
+
+  /*  Read Walls  */
+  const tinyxml2::XMLElement* wallElement =
+      geometryElement->FirstChildElement("Wall");
+  if (!wallElement) {
+    cerr << "Error: no wall present on geometry file " << file << endl;
+    return EXIT_FAILURE;
+  }
+  while (wallElement != nullptr) {
+    /// Fetch material
+    const char* materialId = nullptr;
+    wallElement->QueryStringAttribute("MaterialId", &materialId);
+    if (!materialId or !materialMapping.contains(materialId)) {
+      // cout << "Warning: unknown or absent material id " << materialId <<
+      // "given for one of the walls."; cout << "The default material will be
+      // used." << endl;
+      obstaclesMaterial.push_back(
+          WALL);  //  If unknown id, give the default WALL material
+    } else
+      obstaclesMaterial.push_back(materialMapping[materialId]);
+
+    vector<double2> wall;
+    const tinyxml2::XMLElement* cornerElement =
+        wallElement->FirstChildElement("Corner");
+    if (!cornerElement) {
+      cerr << "Error: no corners in wall!" << endl;
+      return EXIT_FAILURE;
+    }
+    while (cornerElement != nullptr) {
+      const char* buffer = nullptr;
+      if (cornerElement->QueryStringAttribute("Coordinates", &buffer) !=
+          tinyxml2::XML_SUCCESS) {
+        cerr << "Error: Could not parse corner coordinates from XML file "
+             << file << endl;
         return EXIT_FAILURE;
-    }
-
-    /*  Read the Geometry block */
-    tinyxml2::XMLElement* geometryElement = document.FirstChildElement("Geometry");
-    if (!geometryElement) {
-        cerr << "Error: Information about geometry must be embedded in \"Geometry\" tag!" << endl;
+      }
+      auto [rc, coordinates] = parse2DComponents(buffer);
+      if (rc != EXIT_SUCCESS) {
+        cerr << "Error: Could not parse corner coordinates from XML file "
+             << file << endl;
         return EXIT_FAILURE;
-    }
-
-    /*  Read dimensions */
-    const tinyxml2::XMLElement* dimensionsElement = geometryElement->FirstChildElement("Dimensions");
-    if (!dimensionsElement) {
-        cerr << "Error: no Dimensions tag present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    if (dimensionsElement->QueryDoubleAttribute("Lx", &Lx) != tinyxml2::XML_SUCCESS) {
-        cerr << "Error: Could not parse domain dimensions from XML file " << file << endl;
-        return EXIT_FAILURE;
-    };
-    if (dimensionsElement->QueryDoubleAttribute("Ly", &Ly) != tinyxml2::XML_SUCCESS) {
-        cerr << "Error: Could not parse domain dimensions from XML file " << file << endl;
-        return EXIT_FAILURE;
-    };
-
-    /*  Read Walls  */
-    const tinyxml2::XMLElement* wallElement = geometryElement->FirstChildElement("Wall");
-    if (!wallElement) {
-        cerr << "Error: no wall present on geometry file " << file << endl;
-        return EXIT_FAILURE;
-    }
-    while (wallElement != nullptr) {
-        /// Fetch material
-        const char * materialId = nullptr;
-        wallElement->QueryStringAttribute("MaterialId", &materialId);
-        if (!materialId or !materialMapping.contains(materialId)) {
-            // cout << "Warning: unknown or absent material id " << materialId << "given for one of the walls.";
-            // cout << "The default material will be used." << endl;
-            obstaclesMaterial.push_back(WALL);  //  If unknown id, give the default WALL material
-        }
-        else obstaclesMaterial.push_back(materialMapping[materialId]);
-
-        vector<double2> wall;
-        const tinyxml2::XMLElement* cornerElement   = wallElement->FirstChildElement("Corner");
-        if (!cornerElement) {
-            cerr << "Error: no corners in wall!" << endl;
-            return EXIT_FAILURE;
-        }
-        while (cornerElement != nullptr) {
-            const char* buffer = nullptr;
-            if (cornerElement->QueryStringAttribute("Coordinates", &buffer) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: Could not parse corner coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            auto [rc, coordinates] = parse2DComponents(buffer);
-            if (rc != EXIT_SUCCESS) {
-                cerr << "Error: Could not parse corner coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            wall.emplace_back(coordinates);
-            cornerElement = cornerElement->NextSiblingElement("Corner");
-        }
-        listObstacles.push_back(wall);
-
-        wallElement = wallElement->NextSiblingElement("Wall");
-    }
-
-     return EXIT_SUCCESS;
+      }
+      wall.emplace_back(coordinates);
+      cornerElement = cornerElement->NextSiblingElement("Corner");
+    }
+    listObstacles.push_back(wall);
+
+    wallElement = wallElement->NextSiblingElement("Wall");
+  }
+
+  return EXIT_SUCCESS;
 }
 /**
  * @brief Reads the Agents XML file.
  * @param file The name of the file
  * @param nShapesPerAgent The number of shapes by agent (size: number of agents)
- * @param shapeIDagent A correspondence between the shape ids (index) and the agent (value) (size: number of shapes)
- * @param edges The indices of the first shape for each agent (size:  number of agents + 1)
+ * @param shapeIDagent A correspondence between the shape ids (index) and the
+ * agent (value) (size: number of shapes)
+ * @param edges The indices of the first shape for each agent (size:  number of
+ * agents + 1)
  * @param radii The radii of all shapes (size: number of shapes)
  * @param masses The masses of the agents
  * @param mois The moment of inertia of the agents
- * @param delta_gtos The relative positions of the shapes with respect to the center of mass of each agent
- * @param materialMapping The known mapping between user-provided material ids and our ids for them
+ * @param delta_gtos The relative positions of the shapes with respect to the
+ * center of mass of each agent
+ * @param materialMapping The known mapping between user-provided material ids
+ * and our ids for them
  * @return EXIT_FAILURE if issue in the XML file (missing or unreadable field)
  *         EXIT_SUCCESS otherwise
  */
-int readAgents(
-    const string& file, vector<unsigned>& nShapesPerAgent,
-    vector<unsigned>& shapeIDagent, vector<int>& edges, vector<double>& radii, vector<double>& masses,
-    vector<double>& mois, vector<double2>& delta_gtos, map<string, int32_t>& materialMapping)
-{
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file" << file << endl;
+int readAgents(const string& file, vector<unsigned>& nShapesPerAgent,
+               vector<unsigned>& shapeIDagent, vector<int>& edges,
+               vector<double>& radii, vector<double>& masses,
+               vector<double>& mois, vector<double2>& delta_gtos,
+               map<string, int32_t>& materialMapping) {
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file" << file << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read the Agents block   */
+  tinyxml2::XMLElement* agentsElement = document.FirstChildElement("Agents");
+  if (!agentsElement) {
+    cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+  const tinyxml2::XMLElement* agentElement =
+      agentsElement->FirstChildElement("Agent");
+  if (!agentElement) {
+    cerr << "Error: no Agent tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  size_t sGlobal = 0;
+  uint32_t agentId = 0;
+  while (agentElement != nullptr) {
+    //  Id (ignored)
+    const char* externId;
+    if (agentElement->QueryStringAttribute("Id", &externId) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: please provide identifiers for your agents " << endl;
+      return EXIT_FAILURE;
+    };
+    agentMap[externId] = agentId;
+    agentMapInverse.emplace_back(externId);
+    //  Mass and Moment of Inertia
+    double mass, moi;
+    if (agentElement->QueryDoubleAttribute("Mass", &mass) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get mass from agent " << externId << endl;
+    }
+    if (agentElement->QueryDoubleAttribute("MomentOfInertia", &moi) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get moment of inertia from agent " << externId
+           << endl;
+    }
+    masses.push_back(mass);
+    mois.push_back(moi);
+    double dampingTranslational, dampingRotational;
+    if (agentElement->QueryDoubleAttribute(
+            "FloorDamping", &dampingTranslational) != tinyxml2::XML_SUCCESS) {
+      // cout << "Warning: for agent " << externId << ": translational damping
+      // (FloorDamping) not provided! "; cout << "Default value will be used."
+      // << endl;
+      dampingTranslational = 1 / tau_mech_translational;
+    };
+    if (agentElement->QueryDoubleAttribute(
+            "AngularDamping", &dampingRotational) != tinyxml2::XML_SUCCESS) {
+      // cout << "Warning: for agent " << externId << ": rotational damping
+      // (AngularDamping) not provided! "; cout << "Default value will be used."
+      // << endl;
+      dampingRotational = 1 / tau_mech_rotational;
+    };
+    agentProperties.emplace_back(dampingTranslational, dampingRotational);
+
+    /// Shapes
+    const tinyxml2::XMLElement* shapesElement =
+        agentElement->FirstChildElement("Shapes");
+    if (!shapesElement) {
+      cerr << "Error: shapes must be embedded in \"Shapes\" tag!" << endl;
+      return EXIT_FAILURE;
+    }
+    const tinyxml2::XMLElement* shapeElement =
+        shapesElement->FirstChildElement("Shape");
+    if (!shapeElement) {
+      cerr << "Error: an agent has no shapes in " << file << endl;
+      return EXIT_FAILURE;
+    }
+    size_t s = 0;
+    while (shapeElement != nullptr) {
+      /// Fill shapeIDagent - as many agentIds as there are shapes for it
+      shapeIDagent.push_back(agentId);
+      /// Fetch id
+      const char* shapeExternId = nullptr;
+      if (shapeElement->QueryStringAttribute("Id", &shapeExternId) !=
+          tinyxml2::XML_SUCCESS) {
+        cerr << "Error: please provide identifier for your shapes" << endl;
         return EXIT_FAILURE;
-    }
-
-    /*  Read the Agents block   */
-    tinyxml2::XMLElement* agentsElement         = document.FirstChildElement("Agents");
-    if (!agentsElement) {
-        cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
+      }
+      shapeMap[{externId, shapeExternId}] = sGlobal;
+      shapeMapInverse.emplace_back(shapeExternId);
+      /// Fetch material
+      const char* materialId = nullptr;
+      shapeElement->QueryStringAttribute("MaterialId", &materialId);
+      if (!materialId or !materialMapping.contains(materialId)) {
+        // cout << "Warning: unknown or absent material id " << materialId <<
+        // "given for one of the shapes."; cout << "The default material will be
+        // used." << endl;
+        shapesMaterial[sGlobal] =
+            PEDESTRIAN;  //  if unknown material, give the default
+      } else
+        shapesMaterial[sGlobal] = materialMapping[materialId];
+
+      double radius;
+      if (shapeElement->QueryDoubleAttribute("Radius", &radius) !=
+          tinyxml2::XML_SUCCESS) {
+        cerr << "Error: could not get radius from shape " << s + 1
+             << " in agent " << agentId << endl;
         return EXIT_FAILURE;
-    }
-    const tinyxml2::XMLElement* agentElement    = agentsElement->FirstChildElement("Agent");
-    if (!agentElement) {
-        cerr << "Error: no Agent tag present in " << file << endl;
+      };
+      radii.push_back(radius);
+      const char* buffer = nullptr;
+      if (shapeElement->QueryStringAttribute("Position", &buffer) !=
+          tinyxml2::XML_SUCCESS) {
+        cerr << "Error: Could not parse shape coordinates from XML file "
+             << file << endl;
         return EXIT_FAILURE;
-    }
-    size_t sGlobal = 0;
-    uint32_t agentId = 0;
-    while (agentElement != nullptr) {
-        //  Id (ignored)
-        const char* externId;
-        if (agentElement->QueryStringAttribute("Id", &externId) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: please provide identifiers for your agents " << endl;
-            return EXIT_FAILURE;
-        };
-        agentMap[externId] = agentId;
-        agentMapInverse.emplace_back(externId);
-        //  Mass and Moment of Inertia
-        double mass, moi;
-        if (agentElement->QueryDoubleAttribute("Mass", &mass) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get mass from agent " << externId << endl;
-        }
-        if (agentElement->QueryDoubleAttribute("MomentOfInertia" , &moi) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get moment of inertia from agent " << externId << endl;
-        }
-        masses.push_back(mass);
-        mois.push_back(moi);
-        double dampingTranslational, dampingRotational;
-        if (agentElement->QueryDoubleAttribute("FloorDamping", &dampingTranslational) != tinyxml2::XML_SUCCESS) {
-            // cout << "Warning: for agent " << externId << ": translational damping (FloorDamping) not provided! ";
-            // cout << "Default value will be used." << endl;
-            dampingTranslational = 1 / tau_mech_translational;
-        };
-        if (agentElement->QueryDoubleAttribute("AngularDamping", &dampingRotational) != tinyxml2::XML_SUCCESS) {
-            // cout << "Warning: for agent " << externId << ": rotational damping (AngularDamping) not provided! ";
-            // cout << "Default value will be used." << endl;
-            dampingRotational = 1 / tau_mech_rotational;
-        };
-        agentProperties.emplace_back(dampingTranslational, dampingRotational);
-
-        /// Shapes
-        const tinyxml2::XMLElement* shapesElement   = agentElement->FirstChildElement("Shapes");
-        if (!shapesElement) {
-            cerr << "Error: shapes must be embedded in \"Shapes\" tag!" << endl;
-            return EXIT_FAILURE;
-        }
-        const tinyxml2::XMLElement* shapeElement    = shapesElement->FirstChildElement("Shape");
-        if (!shapeElement) {
-            cerr << "Error: an agent has no shapes in " << file << endl;
-            return EXIT_FAILURE;
-        }
-        size_t s = 0;
-        while (shapeElement != nullptr) {
-            /// Fill shapeIDagent - as many agentIds as there are shapes for it
-            shapeIDagent.push_back(agentId);
-            /// Fetch id
-            const char* shapeExternId = nullptr;
-            if (shapeElement->QueryStringAttribute("Id", &shapeExternId) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: please provide identifier for your shapes" << endl;
-                return EXIT_FAILURE;
-            }
-            shapeMap[{externId, shapeExternId}] = sGlobal;
-            shapeMapInverse.emplace_back(shapeExternId);
-            /// Fetch material
-            const char * materialId = nullptr;
-            shapeElement->QueryStringAttribute("MaterialId", &materialId);
-            if (!materialId or !materialMapping.contains(materialId)) {
-                // cout << "Warning: unknown or absent material id " << materialId << "given for one of the shapes.";
-                // cout << "The default material will be used." << endl;
-                shapesMaterial[sGlobal] = PEDESTRIAN;    //  if unknown material, give the default
-            }
-            else shapesMaterial[sGlobal] = materialMapping[materialId];
-
-            double radius;
-            if (shapeElement->QueryDoubleAttribute("Radius", &radius) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: could not get radius from shape " << s+1 << " in agent " << agentId << endl;
-                return EXIT_FAILURE;
-            };
-            radii.push_back(radius);
-            const char* buffer = nullptr;
-            if (shapeElement->QueryStringAttribute("Position", &buffer) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: Could not parse shape coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            auto [rc, coordinates] = parse2DComponents(buffer);
-            if (rc != EXIT_SUCCESS) {
-                cerr << "Error: Could not parse shape coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            delta_gtos.emplace_back(coordinates);
-
-            shapeElement = shapeElement->NextSiblingElement("Shape");
-            s++;
-            sGlobal++;
-        }
-        nShapesPerAgent.push_back(s);
-        edges.push_back(static_cast<int>(sGlobal));
-
-        agentElement = agentElement->NextSiblingElement("Agent");
-        agentId++;
-    }
-
-    nAgents = masses.size();
-    edges.insert(edges.begin(), 0);
-
-    return EXIT_SUCCESS;
+      }
+      auto [rc, coordinates] = parse2DComponents(buffer);
+      if (rc != EXIT_SUCCESS) {
+        cerr << "Error: Could not parse shape coordinates from XML file "
+             << file << endl;
+        return EXIT_FAILURE;
+      }
+      delta_gtos.emplace_back(coordinates);
+
+      shapeElement = shapeElement->NextSiblingElement("Shape");
+      s++;
+      sGlobal++;
+    }
+    nShapesPerAgent.push_back(s);
+    edges.push_back(static_cast<int>(sGlobal));
+
+    agentElement = agentElement->NextSiblingElement("Agent");
+    agentId++;
+  }
+
+  nAgents = masses.size();
+  edges.insert(edges.begin(), 0);
+
+  return EXIT_SUCCESS;
 }
 
 /**
@@ -447,14 +526,14 @@

  * @param j Internal material id j
  * @return The value of k_n
  */
-double computeStiffnessNormal(const uint32_t i, const uint32_t j)
-{
-    const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
-    const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
-    const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
-    const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
-
-    return 1 / ((4 * Gi - Ei) / (4 * pow(Gi, 2)) + (4 * Gj - Ej) / (4 * pow(Gj, 2)));
+double computeStiffnessNormal(const uint32_t i, const uint32_t j) {
+  const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
+  const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
+  const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
+  const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
+
+  return 1 /
+         ((4 * Gi - Ei) / (4 * pow(Gi, 2)) + (4 * Gj - Ej) / (4 * pow(Gj, 2)));
 }
 /**
  * @brief Computes the tangential stiffness (k_t)
@@ -462,12 +541,12 @@

  * @param j Internal material id j
  * @return The value of k_t
  */
-double computeStiffnessTangential(const uint32_t i, const uint32_t j)
-{
-    const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
-    const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
-    const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
-    const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
-
-    return 1 / ((6 * Gi - Ei) / (8 * pow(Gi, 2)) + (6 * Gj - Ej) / (8 * pow(Gj, 2)));
+double computeStiffnessTangential(const uint32_t i, const uint32_t j) {
+  const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
+  const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
+  const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
+  const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
+
+  return 1 /
+         ((6 * Gi - Ei) / (8 * pow(Gi, 2)) + (6 * Gj - Ej) / (8 * pow(Gj, 2)));
 }
tests/mechanical_layer/include/Globals.h
====================
--- original

+++ formatted

@@ -1,18 +1,19 @@

 #ifndef PARAMETERS_H
 #define PARAMETERS_H
 
-#include <random>
-#include <map>
-#include <vector>
-#include <list>
-#include <iostream>
+#include <sys/stat.h>
+
 #include <algorithm>
 #include <filesystem>
 #include <fstream>
+#include <iostream>
+#include <iterator>
+#include <list>
+#include <map>
+#include <random>
 #include <sstream>
-#include <iterator>
 #include <string>
-#include <sys/stat.h>
+#include <vector>
 //  3rd party
 #include "tinyxml2.h"
 
@@ -42,46 +43,50 @@

 extern double Lx;
 extern double Ly;
 
-extern uint32_t nAgents;                         /// Number of agents
-extern std::map<std::string, uint32_t> agentMap; /// Correspondence between user-given ids and internal ids
-extern std::vector<std::string> agentMapInverse; /// Inverse version for output
-struct Agent;                                    ///	Defined in Agents.h
-extern Agent **agents;                           /// The array of pointers to the agent objects
+extern uint32_t nAgents;  /// Number of agents
+extern std::map<std::string, uint32_t>
+    agentMap;  /// Correspondence between user-given ids and internal ids
+extern std::vector<std::string> agentMapInverse;  /// Inverse version for output
+struct Agent;                                     ///	Defined in Agents.h
+extern Agent **agents;  /// The array of pointers to the agent objects
 
-extern std::map<std::pair<std::string, std::string>, uint32_t> shapeMap; /// Correspondence between user-given Shapeids and internal ids.
-extern std::vector<std::string> shapeMapInverse;                         /// We store the couple (Agent id, shape id) in shapeMap, but the
-                                                                         /// inverse map is only used for output, which is done by agent.
-extern const char *processId;                                            /// Id given by the user for the process (UNUSED for now)
+extern std::map<std::pair<std::string, std::string>, uint32_t>
+    shapeMap;  /// Correspondence between user-given Shapeids and internal ids.
+extern std::vector<std::string>
+    shapeMapInverse;  /// We store the couple (Agent id, shape id) in shapeMap,
+                      /// but the inverse map is only used for output, which is
+                      /// done by agent.
+extern const char
+    *processId;  /// Id given by the user for the process (UNUSED for now)
 
 /// Time variables
-extern double dt;      //  Time between two calls of the library
-extern double dt_mech; //  Time step of the mechanical layer
+extern double dt;       //  Time between two calls of the library
+extern double dt_mech;  //  Time step of the mechanical layer
 
 /// Mechanical layer
-extern std::vector<double2> agentProperties; //  1 / tau_mech: translational and rotational damping
-constexpr uint8_t nDefaultMaterials = 2;     //  We'll provide 2 default Materials (pedestrian and wall)
+extern std::vector<double2>
+    agentProperties;  //  1 / tau_mech: translational and rotational damping
+constexpr uint8_t nDefaultMaterials =
+    2;  //  We'll provide 2 default Materials (pedestrian and wall)
 extern uint32_t nMaterials;
-enum __attribute__((__packed__))
-{ //  For the two default values
-    PEDESTRIAN = 0,
-    WALL = 1,
+enum __attribute__((__packed__)) {  //  For the two default values
+  PEDESTRIAN = 0,
+  WALL = 1,
 };
 extern double **intrinsicProperties;
 constexpr int nIntrinsicProperties = 2;
-enum __attribute__((__packed__))
-{
-    YOUNG_MODULUS = 0,
-    SHEAR_MODULUS = 1,
+enum __attribute__((__packed__)) {
+  YOUNG_MODULUS = 0,
+  SHEAR_MODULUS = 1,
 };
 extern double ***binaryProperties;
 constexpr int nBinaryProperties = 5;
-enum __attribute__((__packed__))
-{
-    DAMPING_NORMAL = 0,
-    DAMPING_TANGENTIAL = 1,
-    STIFFNESS_NORMAL = 2,
-    STIFFNESS_TANGENTIAL = 3, //  = static friction
-    FRICTION_SLIDING = 4,     //  = kinetic friction
+enum __attribute__((__packed__)) {
+  DAMPING_NORMAL = 0,
+  DAMPING_TANGENTIAL = 1,
+  STIFFNESS_NORMAL = 2,
+  STIFFNESS_TANGENTIAL = 3,  //  = static friction
+  FRICTION_SLIDING = 4,      //  = kinetic friction
 };
 extern std::vector<int32_t> obstaclesMaterial;
 extern std::map<uint32_t, int32_t> shapesMaterial;
@@ -98,17 +103,26 @@

 constexpr double G_pedestrian = .1e+6;
 constexpr double E_wall = .24e+6;
 constexpr double G_wall = .1e+6;
-constexpr double tau_mech_translational = 0.5; // 3.87 0.2 the equation of motion reads (with m=1): acceleration= F_Hertzian + (v_des-v)/tau_mech
-constexpr double tau_mech_rotational = 0.5;    //  0.5 corresponds to a stopping distance of 2.5 m
-constexpr double gamma_n = 1.3e+04;            // normal damping betweens particles // dt_mech << 2/gamma_body
-constexpr double gamma_t = 1.3e+04;            // tangential damping betweens particles
-constexpr double mu_dyn = 0.5;                 // 10.5; 2.5 ; tangential force, coulomb interaction, dynamic coefficient
-constexpr double gamma_n_wall = 1.3e+04;       // normal damping betweens particle and wall
-constexpr double gamma_t_wall = 1.3e+04;       // tangential damping betweens particle and wall
-constexpr double mu_dyn_wall = 0.5;            // tangential force, coulomb interaction, dynamic coefficient
+constexpr double tau_mech_translational =
+    0.5;  // 3.87 0.2 the equation of motion reads (with m=1): acceleration=
+          // F_Hertzian + (v_des-v)/tau_mech
+constexpr double tau_mech_rotational =
+    0.5;  //  0.5 corresponds to a stopping distance of 2.5 m
+constexpr double gamma_n =
+    1.3e+04;  // normal damping betweens particles // dt_mech << 2/gamma_body
+constexpr double gamma_t = 1.3e+04;  // tangential damping betweens particles
+constexpr double mu_dyn = 0.5;       // 10.5; 2.5 ; tangential force, coulomb
+                                     // interaction, dynamic coefficient
+constexpr double gamma_n_wall =
+    1.3e+04;  // normal damping betweens particle and wall
+constexpr double gamma_t_wall =
+    1.3e+04;  // tangential damping betweens particle and wall
+constexpr double mu_dyn_wall =
+    0.5;  // tangential force, coulomb interaction, dynamic coefficient
 
 //  Preferential speed
-constexpr double pref_speed = 1.4; //  3.0 the floor field should be K_FF= 0.89*desired_free_walking_speed
+constexpr double pref_speed = 1.4;  //  3.0 the floor field should be K_FF=
+                                    //  0.89*desired_free_walking_speed
 constexpr double vMaxAgent = 7.;
 
 /*
@@ -117,7 +131,8 @@

 /// Utilities
 std::pair<int, double2> parse2DComponents(const char *line);
 //  Physics
-std::pair<double, double2> get_distance_to_wall_and_closest_point(double2 vertexA, double2 vertexB, const double2 &C);
+std::pair<double, double2> get_distance_to_wall_and_closest_point(
+    double2 vertexA, double2 vertexB, const double2 &C);
 inline double get_interval(double x, double length);
 double get_distance(const double2 &A, const double2 &B);
 
tests/mechanical_layer/src/Agent.cpp
====================
--- original

+++ formatted

@@ -1,40 +1,41 @@

 /*
-    Agent.cpp contains the constructor of the agent class, as well as functions related
-    to the agent's properties.
+    Agent.cpp contains the constructor of the agent class, as well as functions
+   related to the agent's properties.
 
  */
 #include "Agent.h"
+
 #include <utility>
 
 using namespace std;
 
 /**
  * @brief Calculates the size of the body of the agent.
- * The size is defined as the radius of the smallest circle containing all the shapes.
+ * The size is defined as the radius of the smallest circle containing all the
+ * shapes.
  *
- * @param delta_gtos The vector of delta_gtos representing the distances between the agent and its shapes.
- * @param radius_shapes The vector of radius_shapes representing the radii of the agent's shapes.
+ * @param delta_gtos The vector of delta_gtos representing the distances between
+ * the agent and its shapes.
+ * @param radius_shapes The vector of radius_shapes representing the radii of
+ * the agent's shapes.
  *
  * @return The size of the body of the agent.
  */
-static double size_body(const vector<double2>& delta_gtos, const vector<double>& radius_shapes)
-{
-    double max_delta_gtos = 0.0;
-    size_t cpt_max = 0;
-    for (size_t i = 0; i < delta_gtos.size(); ++i)
-    {
-        if (const double magnitude = !delta_gtos[i]; magnitude > max_delta_gtos)
-        {
-            max_delta_gtos = magnitude;
-            cpt_max = i;
-        }
+static double size_body(const vector<double2>& delta_gtos,
+                        const vector<double>& radius_shapes) {
+  double max_delta_gtos = 0.0;
+  size_t cpt_max = 0;
+  for (size_t i = 0; i < delta_gtos.size(); ++i) {
+    if (const double magnitude = !delta_gtos[i]; magnitude > max_delta_gtos) {
+      max_delta_gtos = magnitude;
+      cpt_max = i;
     }
-    double radius(radius_shapes[cpt_max]);
-    if (radius_shapes[cpt_max] < 0.0)
-    {
-        radius = -radius_shapes[cpt_max];
-    }
-    return radius + max_delta_gtos;
+  }
+  double radius(radius_shapes[cpt_max]);
+  if (radius_shapes[cpt_max] < 0.0) {
+    radius = -radius_shapes[cpt_max];
+  }
+  return radius + max_delta_gtos;
 }
 
 /**
@@ -57,55 +58,70 @@

  * @param mass
  * @param moi
  */
-Agent::Agent(unsigned ID, vector<unsigned> Ids_shapes, double x, double y, double vx, double vy, double omega, double2 Fp, double Mp,
-             unsigned nb_shapes, const vector<double2>& delta_gtos, const vector<double>& radius_shapes, double theta_body, double theta_body_init,
-             double mass, double moi)
-    : _id(ID), _mass(mass), _moi(moi), _ids_shapes(std::move(Ids_shapes)), _radius(size_body(delta_gtos, radius_shapes)),
-      _nb_shapes(nb_shapes), _delta_gtos(delta_gtos), _radius_shapes(radius_shapes), _theta_init(theta_body_init),
-      _x(x), _y(y), _theta(theta_body), _vx(vx), _vy(vy), _w(omega)
-{
-    const double inverseTauMechTranslation   = agentProperties[_id].first;
-    const double inverseTauMechRotation      = agentProperties[_id].second;
-    _vx_des = Fp.first  / inverseTauMechTranslation / _mass;    //  vx_des := Fpx/m * tau_mech
-    _vy_des = Fp.second / inverseTauMechTranslation / _mass;    //  vy_des := Fpy/m * tau_mech
-    _w_des  = Mp / inverseTauMechRotation / _moi;               //  w_des  := Mp/I  * tau_mech
+Agent::Agent(unsigned ID, vector<unsigned> Ids_shapes, double x, double y,
+             double vx, double vy, double omega, double2 Fp, double Mp,
+             unsigned nb_shapes, const vector<double2>& delta_gtos,
+             const vector<double>& radius_shapes, double theta_body,
+             double theta_body_init, double mass, double moi)
+    : _id(ID),
+      _mass(mass),
+      _moi(moi),
+      _ids_shapes(std::move(Ids_shapes)),
+      _radius(size_body(delta_gtos, radius_shapes)),
+      _nb_shapes(nb_shapes),
+      _delta_gtos(delta_gtos),
+      _radius_shapes(radius_shapes),
+      _theta_init(theta_body_init),
+      _x(x),
+      _y(y),
+      _theta(theta_body),
+      _vx(vx),
+      _vy(vy),
+      _w(omega) {
+  const double inverseTauMechTranslation = agentProperties[_id].first;
+  const double inverseTauMechRotation = agentProperties[_id].second;
+  _vx_des = Fp.first / inverseTauMechTranslation /
+            _mass;  //  vx_des := Fpx/m * tau_mech
+  _vy_des = Fp.second / inverseTauMechTranslation /
+            _mass;                              //  vy_des := Fpy/m * tau_mech
+  _w_des = Mp / inverseTauMechRotation / _moi;  //  w_des  := Mp/I  * tau_mech
 
-    if (not(_vx_des == 0. and _vy_des == 0.))
-        _theta_des = atan2(_vy_des, _vx_des);
-    else _theta_des = 0.;
-    _v_des = double2(_vx_des, _vy_des);
+  if (not(_vx_des == 0. and _vy_des == 0.))
+    _theta_des = atan2(_vy_des, _vx_des);
+  else
+    _theta_des = 0.;
+  _v_des = double2(_vx_des, _vy_des);
 }
 
 /**
  * @brief Destructor for the Agent class.
  *
- * This destructor is responsible for cleaning up any resources allocated by an Agent object.
- * It is automatically called when an Agent object goes out of scope or is explicitly deleted.
+ * This destructor is responsible for cleaning up any resources allocated by an
+ * Agent object. It is automatically called when an Agent object goes out of
+ * scope or is explicitly deleted.
  */
 Agent::~Agent() = default;
-
 
 /**
  * @brief Moves the agent based on its velocity and angular velocity.
  *
- * This function updates the position and orientation of the agent based on its current velocity (_vx, _vy) and angular velocity
+ * This function updates the position and orientation of the agent based on its
+ * current velocity (_vx, _vy) and angular velocity
  * (_w). The movement is performed over a small time interval (dt).
  */
-void Agent::move()
-{
-    _x      += _vx * dt;
-    _y      += _vy * dt;
-    _theta  += _w  * dt;
+void Agent::move() {
+  _x += _vx * dt;
+  _y += _vy * dt;
+  _theta += _w * dt;
 }
 
-vector<double2> Agent::get_delta_gtos()
-{
-    vector<double2> delta_gtos_abs;
-    for (auto [x, y] : _delta_gtos)
-    {
-        const double rotation_angle = _theta - _theta_init;
-        delta_gtos_abs.emplace_back(x * cos(rotation_angle) - y * sin(rotation_angle),
-                                         x * sin(rotation_angle) + y * cos(rotation_angle));
-    }
-    return delta_gtos_abs;
+vector<double2> Agent::get_delta_gtos() {
+  vector<double2> delta_gtos_abs;
+  for (auto [x, y] : _delta_gtos) {
+    const double rotation_angle = _theta - _theta_init;
+    delta_gtos_abs.emplace_back(
+        x * cos(rotation_angle) - y * sin(rotation_angle),
+        x * sin(rotation_angle) + y * cos(rotation_angle));
+  }
+  return delta_gtos_abs;
 }
tests/mechanical_layer/src/Globals.cpp
====================
--- original

+++ formatted

@@ -7,62 +7,83 @@

                                             */
 /// Define operations on type double2
 //  Addition of two double2 vectors
-double2 operator+(double2 const &a, double2 const &b) { return {a.first + b.first, a.second + b.second}; }
-double2 operator-(double2 const &a, double2 const &b) { return {a.first - b.first, a.second - b.second}; }
+double2 operator+(double2 const &a, double2 const &b) {
+  return {a.first + b.first, a.second + b.second};
+}
+double2 operator-(double2 const &a, double2 const &b) {
+  return {a.first - b.first, a.second - b.second};
+}
 //  Element-wise multiplication
-double2 operator*(double2 const &a, double2 const &b) { return {a.first * b.first, a.second * b.second}; }
+double2 operator*(double2 const &a, double2 const &b) {
+  return {a.first * b.first, a.second * b.second};
+}
 //  Scalar multiplication with a double2 vector
-double2 operator*(double const coef, double2 const &R) { return {coef * R.first, coef * R.second}; }
+double2 operator*(double const coef, double2 const &R) {
+  return {coef * R.first, coef * R.second};
+}
 //  Dot product
-double operator%(double2 const &a, double2 const &b) { return a.first * b.first + a.second * b.second; }
+double operator%(double2 const &a, double2 const &b) {
+  return a.first * b.first + a.second * b.second;
+}
 // Norm (magnitude) of a double2 vector
 double operator!(double2 const &a) { return sqrt(a % a); }
-// Cross product-like operation for 2D vectors (returns perpendicular vector scaled by scalar)
-double2 operator^(double const a, double2 const &b) { return {-a * b.second, a * b.first}; }
+// Cross product-like operation for 2D vectors (returns perpendicular vector
+// scaled by scalar)
+double2 operator^(double const a, double2 const &b) {
+  return {-a * b.second, a * b.first};
+}
 
 /// Define operations on type int2
 //  Addition of two int2 vectors
-int2 operator+(int2 const &a, int2 const &b) { return {a.first + b.first, a.second + b.second}; }
-int2 operator-(int2 const &a, int2 const &b) { return {a.first - b.first, a.second - b.second}; }
+int2 operator+(int2 const &a, int2 const &b) {
+  return {a.first + b.first, a.second + b.second};
+}
+int2 operator-(int2 const &a, int2 const &b) {
+  return {a.first - b.first, a.second - b.second};
+}
 //  Element-wise multiplication
-int2 operator*(int2 const &a, int2 const &b) { return {a.first * b.first, a.second * b.second}; }
+int2 operator*(int2 const &a, int2 const &b) {
+  return {a.first * b.first, a.second * b.second};
+}
 
 /*
     Global variables
                         */
 uint32_t nAgents;
-map<string, uint32_t> agentMap;                 /// Correspondence between user-given ids and internal ids
-vector<string> agentMapInverse;                 /// Inverse version for output
-Agent** agents;                                 /// The array of pointers to the agent objects
+map<string, uint32_t>
+    agentMap;  /// Correspondence between user-given ids and internal ids
+vector<string> agentMapInverse;  /// Inverse version for output
+Agent **agents;                  /// The array of pointers to the agent objects
 
-map<pair<string, string>, uint32_t> shapeMap;   /// Correspondence between user-given Shapeids and internal ids.
-vector<string> shapeMapInverse;                 /// We store the couple (Agent id, shape id) in shapeMap, but the
-                                                /// inverse map is only used for output, which is done by agent.
+map<pair<string, string>, uint32_t>
+    shapeMap;  /// Correspondence between user-given Shapeids and internal ids.
+vector<string> shapeMapInverse;  /// We store the couple (Agent id, shape id) in
+                                 /// shapeMap, but the inverse map is only used
+                                 /// for output, which is done by agent.
 
-const char* processId;                          /// UNUSED for now - process id provided by the user
+const char *processId;  /// UNUSED for now - process id provided by the user
 
 /// Geometry
 double Lx;
 double Ly;
 vector<vector<double2>> listObstacles;
 
-
 /// Basic parameters
-double dt;          /// Time step of the main loop.
-double dt_mech;     /// Time step of the mechanical layer.
+double dt;       /// Time step of the main loop.
+double dt_mech;  /// Time step of the mechanical layer.
 
 /// Mechanical layer
 ///     Materials
 vector<double2> agentProperties;
 uint32_t nMaterials;
-double** intrinsicProperties;
-double*** binaryProperties;
+double **intrinsicProperties;
+double ***binaryProperties;
 vector<int32_t> obstaclesMaterial;
 map<uint32_t, int32_t> shapesMaterial;
 
 ///  Paths
-string pathStatic;      //  Folder where the static  data should be saved
-string pathDynamic;     //  Folder where the dynamic data should be placed
+string pathStatic;   //  Folder where the static  data should be saved
+string pathDynamic;  //  Folder where the dynamic data should be placed
 
 /*
     Utilities functions
@@ -74,63 +95,68 @@

  * string.
  * @return A vector of doubles containing the parsed values.
  */
-pair<int, double2> parse2DComponents(const char* line)
-{
-    vector<double> result;
-    stringstream ss(line);
-    string token;
-    uint8_t counter = 0;
-    while (getline(ss, token, ','))
-    {
-        double value;
-        try {
-            value = stod(token);
-        }
-        catch (...) {
-            return {EXIT_FAILURE, {0., 0.}};
-        }
-        result.push_back(value);
-        counter++;
-        if (counter > 2)
-            return {EXIT_FAILURE, {0., 0.}};
+pair<int, double2> parse2DComponents(const char *line) {
+  vector<double> result;
+  stringstream ss(line);
+  string token;
+  uint8_t counter = 0;
+  while (getline(ss, token, ',')) {
+    double value;
+    try {
+      value = stod(token);
+    } catch (...) {
+      return {EXIT_FAILURE, {0., 0.}};
     }
-    return {EXIT_SUCCESS, {result[0], result[1]}};
+    result.push_back(value);
+    counter++;
+    if (counter > 2) return {EXIT_FAILURE, {0., 0.}};
+  }
+  return {EXIT_SUCCESS, {result[0], result[1]}};
 }
 
-
 /**
- * Calculates the distance to a wall and the closest point on the wall from a given point.
+ * Calculates the distance to a wall and the closest point on the wall from a
+ * given point.
  *
  * @param vertexA The first vertex of the wall segment.
  * @param vertexB The second vertex of the wall segment.
  * @param C The point for which the distance and closest point are calculated.
- * @return A pair containing the distance to the wall and the closest point on the wall.
+ * @return A pair containing the distance to the wall and the closest point on
+ * the wall.
  */
-pair<double, double2> get_distance_to_wall_and_closest_point(double2 vertexA, double2 vertexB, const double2 &C)
-{
-    const double2 AB = vertexB - vertexA;
-    const double2 AC = C - vertexA;
-    const double gamma = AB % AC / (AB % AB);   // coefficient such that the closest point P on (AB) satisfies AP= gamma AB
+pair<double, double2> get_distance_to_wall_and_closest_point(double2 vertexA,
+                                                             double2 vertexB,
+                                                             const double2 &C) {
+  const double2 AB = vertexB - vertexA;
+  const double2 AC = C - vertexA;
+  const double gamma =
+      AB % AC / (AB % AB);  // coefficient such that the closest point P on (AB)
+                            // satisfies AP= gamma AB
 
-    if (gamma <= 0.0)
-        return make_pair<double, double2>(!AC, double2(vertexA));   // closest point is vertexA
-    if (gamma >= 1.0)
-        return make_pair<double, double2>(!(C - vertexB), double2(vertexB));   // closest point is vertexB
+  if (gamma <= 0.0)
+    return make_pair<double, double2>(
+        !AC, double2(vertexA));  // closest point is vertexA
+  if (gamma >= 1.0)
+    return make_pair<double, double2>(
+        !(C - vertexB), double2(vertexB));  // closest point is vertexB
 
-    double2 P = vertexA + gamma * AB;   // closest point P on (AB) to C
-    return make_pair<double, double2>(!(C - P), double2(P));
+  double2 P = vertexA + gamma * AB;  // closest point P on (AB) to C
+  return make_pair<double, double2>(!(C - P), double2(P));
 }
 
 /**
  * Calculates the interval of a given value within a specified length.
  * The interval is calculated by adding half of the length to the value,
- * taking the modulo of the sum with the length, and subtracting half of the length.
+ * taking the modulo of the sum with the length, and subtracting half of the
+ * length.
  *
  * @param x The value for which the interval is calculated.
  * @param length The length of the interval.
  * @return The interval of the value within the specified length.
  */
-inline double get_interval(const double x, const double length) { return fmod(x + 0.5 * length, length) - 0.5 * length; }
+inline double get_interval(const double x, const double length) {
+  return fmod(x + 0.5 * length, length) - 0.5 * length;
+}
 
 /**
  * Calculates the Euclidean distance between two points in a 2D space lattice.
@@ -139,10 +165,9 @@

  * @param B The coordinates of the second point.
  * @return The Euclidean distance between the two points.
  */
-double get_distance(const double2 &A, const double2 &B)
-{
-    const double x_mod = get_interval(A.first - B.first, Lx);
-    const double y_mod = get_interval(A.second - B.second, Ly);
-    return sqrt(pow(x_mod, 2) + pow(y_mod, 2));
+double get_distance(const double2 &A, const double2 &B) {
+  const double x_mod = get_interval(A.first - B.first, Lx);
+  const double y_mod = get_interval(A.second - B.second, Ly);
+  return sqrt(pow(x_mod, 2) + pow(y_mod, 2));
 }
 
tests/mechanical_layer/include/Crowd.h
====================
--- original

+++ formatted

@@ -5,17 +5,19 @@

 #include "Globals.h"
 
 /// Global variable: Mechanically active agents
-extern std::list<Agent*> mech_active_agents;
+extern std::list<Agent *> mech_active_agents;
 
 /// Functions
 ///     Initialise scene
 int initialiseSetting(const std::string &dynamicsFile,
-                       std::vector<unsigned> &nb_shapes_allagents, std::vector<unsigned> &shapeIDagent,
-                       std::vector<int> &edges,
-                       std::vector<double> &radius_allshapes, std::vector<double> &masses, std::vector<double> &mois,
-                       std::vector<double2> &delta_gtos);
+                      std::vector<unsigned> &nb_shapes_allagents,
+                      std::vector<unsigned> &shapeIDagent,
+                      std::vector<int> &edges,
+                      std::vector<double> &radius_allshapes,
+                      std::vector<double> &masses, std::vector<double> &mois,
+                      std::vector<double2> &delta_gtos);
 ///     Prepare mechanical layer
-bool is_mechanically_active(const Agent* agent);
+bool is_mechanically_active(const Agent *agent);
 void determine_agents_neighbours();
 bool get_future_collision();
 ///     Handle mechanical layer
@@ -23,4 +25,4 @@

 ///     Output
 void generateDynamicsOutputFile(const std::string &dynamicsFile);
 
-#endif  /*  CROWD_H */
+#endif /*  CROWD_H */
tests/mechanical_layer/build/CMakeFiles/4.0.1/CompilerIdCXX/CMakeCXXCompilerId.cpp
====================
--- original

+++ formatted

@@ -2,447 +2,457 @@

    recognize the extension without flags.  Borland does not know .cxx for
    example.  */
 #ifndef __cplusplus
-# error "A C compiler has been selected for C++."
+#error "A C compiler has been selected for C++."
 #endif
 
 #if !defined(__has_include)
 /* If the compiler does not have __has_include, pretend the answer is
    always no.  */
-#  define __has_include(x) 0
-#endif
-
+#define __has_include(x) 0
+#endif
 
 /* Version number components: V=Version, R=Revision, P=Patch
    Version date components:   YYYY=Year, MM=Month,   DD=Day  */
 
 #if defined(__INTEL_COMPILER) || defined(__ICC)
-# define COMPILER_ID "Intel"
-# if defined(_MSC_VER)
-#  define SIMULATE_ID "MSVC"
-# endif
-# if defined(__GNUC__)
-#  define SIMULATE_ID "GNU"
-# endif
-  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
-     except that a few beta releases use the old format with V=2021.  */
-# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
-#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
-#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
-#  if defined(__INTEL_COMPILER_UPDATE)
-#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
-#  else
-#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
-#  endif
-# else
-#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
-#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
-   /* The third version component from --version is an update index,
-      but no macro is provided for it.  */
-#  define COMPILER_VERSION_PATCH DEC(0)
-# endif
-# if defined(__INTEL_COMPILER_BUILD_DATE)
-   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
-#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
-# endif
-# if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
-#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
-# endif
-# if defined(__GNUC__)
-#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
-# elif defined(__GNUG__)
-#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
-# endif
-# if defined(__GNUC_MINOR__)
-#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
-# endif
-# if defined(__GNUC_PATCHLEVEL__)
-#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
-# endif
-
-#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
-# define COMPILER_ID "IntelLLVM"
+#define COMPILER_ID "Intel"
 #if defined(_MSC_VER)
-# define SIMULATE_ID "MSVC"
+#define SIMULATE_ID "MSVC"
 #endif
 #if defined(__GNUC__)
-# define SIMULATE_ID "GNU"
+#define SIMULATE_ID "GNU"
+#endif
+/* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
+   except that a few beta releases use the old format with V=2021.  */
+#if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || \
+    __INTEL_COMPILER == 202111
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER / 100)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER / 10 % 10)
+#if defined(__INTEL_COMPILER_UPDATE)
+#define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
+#else
+#define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER % 10)
+#endif
+#else
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
+/* The third version component from --version is an update index,
+   but no macro is provided for it.  */
+#define COMPILER_VERSION_PATCH DEC(0)
+#endif
+#if defined(__INTEL_COMPILER_BUILD_DATE)
+/* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
+#define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
+#endif
+#if defined(_MSC_VER)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+#endif
+#if defined(__GNUC__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
+#elif defined(__GNUG__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
+#endif
+#if defined(__GNUC_MINOR__)
+#define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
+#endif
+#if defined(__GNUC_PATCHLEVEL__)
+#define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#endif
+
+#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || \
+    defined(__INTEL_LLVM_COMPILER)
+#define COMPILER_ID "IntelLLVM"
+#if defined(_MSC_VER)
+#define SIMULATE_ID "MSVC"
+#endif
+#if defined(__GNUC__)
+#define SIMULATE_ID "GNU"
 #endif
 /* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
  * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
  * VVVV is no smaller than the current year when a version is released.
  */
 #if __INTEL_LLVM_COMPILER < 1000000L
-# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
-# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
-#else
-# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
-# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
-# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER / 100)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER % 10)
+#else
+#define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER / 10000)
+#define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER / 100 % 100)
+#define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER % 100)
 #endif
 #if defined(_MSC_VER)
-  /* _MSC_VER = VVRR */
-# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 #endif
 #if defined(__GNUC__)
-# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
 #elif defined(__GNUG__)
-# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
+#define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
 #endif
 #if defined(__GNUC_MINOR__)
-# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
+#define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
 #endif
 #if defined(__GNUC_PATCHLEVEL__)
-# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
 #endif
 
 #elif defined(__PATHCC__)
-# define COMPILER_ID "PathScale"
-# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
-# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
-# if defined(__PATHCC_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "PathScale"
+#define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
+#define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
+#if defined(__PATHCC_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
+#endif
 
 #elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
-# define COMPILER_ID "Embarcadero"
-# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
-# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
-# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)
+#define COMPILER_ID "Embarcadero"
+#define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__ >> 24 & 0x00FF)
+#define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__ >> 16 & 0x00FF)
+#define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__ & 0xFFFF)
 
 #elif defined(__BORLANDC__)
-# define COMPILER_ID "Borland"
-  /* __BORLANDC__ = 0xVRR */
-# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
-# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
+#define COMPILER_ID "Borland"
+/* __BORLANDC__ = 0xVRR */
+#define COMPILER_VERSION_MAJOR HEX(__BORLANDC__ >> 8)
+#define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
 
 #elif defined(__WATCOMC__) && __WATCOMC__ < 1200
-# define COMPILER_ID "Watcom"
-   /* __WATCOMC__ = VVRR */
-# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
-# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
-# if (__WATCOMC__ % 10) > 0
-#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
-# endif
+#define COMPILER_ID "Watcom"
+/* __WATCOMC__ = VVRR */
+#define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
+#define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
+#if (__WATCOMC__ % 10) > 0
+#define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
+#endif
 
 #elif defined(__WATCOMC__)
-# define COMPILER_ID "OpenWatcom"
-   /* __WATCOMC__ = VVRP + 1100 */
-# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
-# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
-# if (__WATCOMC__ % 10) > 0
-#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
-# endif
+#define COMPILER_ID "OpenWatcom"
+/* __WATCOMC__ = VVRP + 1100 */
+#define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
+#define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
+#if (__WATCOMC__ % 10) > 0
+#define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
+#endif
 
 #elif defined(__SUNPRO_CC)
-# define COMPILER_ID "SunPro"
-# if __SUNPRO_CC >= 0x5100
-   /* __SUNPRO_CC = 0xVRRP */
-#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
-#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
-#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
-# else
-   /* __SUNPRO_CC = 0xVRP */
-#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
-#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
-#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
-# endif
+#define COMPILER_ID "SunPro"
+#if __SUNPRO_CC >= 0x5100
+/* __SUNPRO_CC = 0xVRRP */
+#define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC >> 12)
+#define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC >> 4 & 0xFF)
+#define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC & 0xF)
+#else
+/* __SUNPRO_CC = 0xVRP */
+#define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC >> 8)
+#define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC >> 4 & 0xF)
+#define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC & 0xF)
+#endif
 
 #elif defined(__HP_aCC)
-# define COMPILER_ID "HP"
-  /* __HP_aCC = VVRRPP */
-# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
-# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
-# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)
+#define COMPILER_ID "HP"
+/* __HP_aCC = VVRRPP */
+#define COMPILER_VERSION_MAJOR DEC(__HP_aCC / 10000)
+#define COMPILER_VERSION_MINOR DEC(__HP_aCC / 100 % 100)
+#define COMPILER_VERSION_PATCH DEC(__HP_aCC % 100)
 
 #elif defined(__DECCXX)
-# define COMPILER_ID "Compaq"
-  /* __DECCXX_VER = VVRRTPPPP */
-# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
-# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
-# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)
+#define COMPILER_ID "Compaq"
+/* __DECCXX_VER = VVRRTPPPP */
+#define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER / 10000000)
+#define COMPILER_VERSION_MINOR DEC(__DECCXX_VER / 100000 % 100)
+#define COMPILER_VERSION_PATCH DEC(__DECCXX_VER % 10000)
 
 #elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
-# define COMPILER_ID "zOS"
-  /* __IBMCPP__ = VRP */
-# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
-# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
+#define COMPILER_ID "zOS"
+/* __IBMCPP__ = VRP */
+#define COMPILER_VERSION_MAJOR DEC(__IBMCPP__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__IBMCPP__ / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10)
 
 #elif defined(__open_xl__) && defined(__clang__)
-# define COMPILER_ID "IBMClang"
-# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
-# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
-# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
-# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
-# define COMPILER_VERSION_INTERNAL_STR  __clang_version__
-
+#define COMPILER_ID "IBMClang"
+#define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
+#define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
+#define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
+#define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
+#define COMPILER_VERSION_INTERNAL_STR __clang_version__
 
 #elif defined(__ibmxl__) && defined(__clang__)
-# define COMPILER_ID "XLClang"
-# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
-# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
-# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
-# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)
-
+#define COMPILER_ID "XLClang"
+#define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
+#define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
+#define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
+#define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)
 
 #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
-# define COMPILER_ID "XL"
-  /* __IBMCPP__ = VRP */
-# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
-# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
+#define COMPILER_ID "XL"
+/* __IBMCPP__ = VRP */
+#define COMPILER_VERSION_MAJOR DEC(__IBMCPP__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__IBMCPP__ / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10)
 
 #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
-# define COMPILER_ID "VisualAge"
-  /* __IBMCPP__ = VRP */
-# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
-# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
+#define COMPILER_ID "VisualAge"
+/* __IBMCPP__ = VRP */
+#define COMPILER_VERSION_MAJOR DEC(__IBMCPP__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__IBMCPP__ / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__IBMCPP__ % 10)
 
 #elif defined(__NVCOMPILER)
-# define COMPILER_ID "NVHPC"
-# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
-# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
-# if defined(__NVCOMPILER_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "NVHPC"
+#define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
+#define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
+#if defined(__NVCOMPILER_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
+#endif
 
 #elif defined(__PGI)
-# define COMPILER_ID "PGI"
-# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
-# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
-# if defined(__PGIC_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "PGI"
+#define COMPILER_VERSION_MAJOR DEC(__PGIC__)
+#define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
+#if defined(__PGIC_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
+#endif
 
 #elif defined(__clang__) && defined(__cray__)
-# define COMPILER_ID "CrayClang"
-# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
-# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
-# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
-# define COMPILER_VERSION_INTERNAL_STR __clang_version__
-
+#define COMPILER_ID "CrayClang"
+#define COMPILER_VERSION_MAJOR DEC(__cray_major__)
+#define COMPILER_VERSION_MINOR DEC(__cray_minor__)
+#define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
+#define COMPILER_VERSION_INTERNAL_STR __clang_version__
 
 #elif defined(_CRAYC)
-# define COMPILER_ID "Cray"
-# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
-# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)
+#define COMPILER_ID "Cray"
+#define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
+#define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)
 
 #elif defined(__TI_COMPILER_VERSION__)
-# define COMPILER_ID "TI"
-  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
-# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
-# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
-# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)
+#define COMPILER_ID "TI"
+/* __TI_COMPILER_VERSION__ = VVVRRRPPP */
+#define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__ / 1000000)
+#define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__ / 1000 % 1000)
+#define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__ % 1000)
 
 #elif defined(__CLANG_FUJITSU)
-# define COMPILER_ID "FujitsuClang"
-# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
-# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
-# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
-# define COMPILER_VERSION_INTERNAL_STR __clang_version__
-
+#define COMPILER_ID "FujitsuClang"
+#define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
+#define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
+#define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
+#define COMPILER_VERSION_INTERNAL_STR __clang_version__
 
 #elif defined(__FUJITSU)
-# define COMPILER_ID "Fujitsu"
-# if defined(__FCC_version__)
-#   define COMPILER_VERSION __FCC_version__
-# elif defined(__FCC_major__)
-#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
-#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
-#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
-# endif
-# if defined(__fcc_version)
-#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
-# elif defined(__FCC_VERSION)
-#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
-# endif
-
+#define COMPILER_ID "Fujitsu"
+#if defined(__FCC_version__)
+#define COMPILER_VERSION __FCC_version__
+#elif defined(__FCC_major__)
+#define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
+#define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
+#define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
+#endif
+#if defined(__fcc_version)
+#define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
+#elif defined(__FCC_VERSION)
+#define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
+#endif
 
 #elif defined(__ghs__)
-# define COMPILER_ID "GHS"
+#define COMPILER_ID "GHS"
 /* __GHS_VERSION_NUMBER = VVVVRP */
-# ifdef __GHS_VERSION_NUMBER
-# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
-# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
-# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
-# endif
+#ifdef __GHS_VERSION_NUMBER
+#define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
+#define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
+#define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER % 10)
+#endif
 
 #elif defined(__TASKING__)
-# define COMPILER_ID "Tasking"
-  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
-  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
-# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)
+#define COMPILER_ID "Tasking"
+#define COMPILER_VERSION_MAJOR DEC(__VERSION__ / 1000)
+#define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
+#define COMPILER_VERSION_INTERNAL DEC(__VERSION__)
 
 #elif defined(__ORANGEC__)
-# define COMPILER_ID "OrangeC"
-# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
-# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
-# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)
+#define COMPILER_ID "OrangeC"
+#define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
+#define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
+#define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)
 
 #elif defined(__SCO_VERSION__)
-# define COMPILER_ID "SCO"
+#define COMPILER_ID "SCO"
 
 #elif defined(__ARMCC_VERSION) && !defined(__clang__)
-# define COMPILER_ID "ARMCC"
+#define COMPILER_ID "ARMCC"
 #if __ARMCC_VERSION >= 1000000
-  /* __ARMCC_VERSION = VRRPPPP */
-  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
-  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
-  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
-#else
-  /* __ARMCC_VERSION = VRPPPP */
-  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
-  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
-  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
-#endif
-
+/* __ARMCC_VERSION = VRRPPPP */
+#define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION / 1000000)
+#define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION / 10000 % 100)
+#define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000)
+#else
+/* __ARMCC_VERSION = VRPPPP */
+#define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION / 100000)
+#define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION / 10000 % 10)
+#define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION % 10000)
+#endif
 
 #elif defined(__clang__) && defined(__apple_build_version__)
-# define COMPILER_ID "AppleClang"
-# if defined(_MSC_VER)
-#  define SIMULATE_ID "MSVC"
-# endif
-# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
-# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
-# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
-# if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
-#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
-# endif
-# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)
+#define COMPILER_ID "AppleClang"
+#if defined(_MSC_VER)
+#define SIMULATE_ID "MSVC"
+#endif
+#define COMPILER_VERSION_MAJOR DEC(__clang_major__)
+#define COMPILER_VERSION_MINOR DEC(__clang_minor__)
+#define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
+#if defined(_MSC_VER)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+#endif
+#define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)
 
 #elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
-# define COMPILER_ID "ARMClang"
-  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
-  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
-  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
-# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)
+#define COMPILER_ID "ARMClang"
+#define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION / 1000000)
+#define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION / 10000 % 100)
+#define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION / 100 % 100)
+#define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)
 
 #elif defined(__clang__) && defined(__ti__)
-# define COMPILER_ID "TIClang"
-  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
-  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
-  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
-# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)
+#define COMPILER_ID "TIClang"
+#define COMPILER_VERSION_MAJOR DEC(__ti_major__)
+#define COMPILER_VERSION_MINOR DEC(__ti_minor__)
+#define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
+#define COMPILER_VERSION_INTERNAL DEC(__ti_version__)
 
 #elif defined(__clang__)
-# define COMPILER_ID "Clang"
-# if defined(_MSC_VER)
-#  define SIMULATE_ID "MSVC"
-# endif
-# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
-# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
-# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
-# if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
-#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
-#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
-# endif
-
-#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
-# define COMPILER_ID "LCC"
-# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
-# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
-# if defined(__LCC_MINOR__)
-#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
-# endif
-# if defined(__GNUC__) && defined(__GNUC_MINOR__)
-#  define SIMULATE_ID "GNU"
-#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
-#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
-#  endif
-# endif
+#define COMPILER_ID "Clang"
+#if defined(_MSC_VER)
+#define SIMULATE_ID "MSVC"
+#endif
+#define COMPILER_VERSION_MAJOR DEC(__clang_major__)
+#define COMPILER_VERSION_MINOR DEC(__clang_minor__)
+#define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
+#if defined(_MSC_VER)
+/* _MSC_VER = VVRR */
+#define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
+#endif
+
+#elif defined(__LCC__) && \
+    (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
+#define COMPILER_ID "LCC"
+#define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
+#define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
+#if defined(__LCC_MINOR__)
+#define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
+#endif
+#if defined(__GNUC__) && defined(__GNUC_MINOR__)
+#define SIMULATE_ID "GNU"
+#define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
+#define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
+#if defined(__GNUC_PATCHLEVEL__)
+#define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#endif
+#endif
 
 #elif defined(__GNUC__) || defined(__GNUG__)
-# define COMPILER_ID "GNU"
-# if defined(__GNUC__)
-#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
-# else
-#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
-# endif
-# if defined(__GNUC_MINOR__)
-#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
-# endif
-# if defined(__GNUC_PATCHLEVEL__)
-#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
-# endif
+#define COMPILER_ID "GNU"
+#if defined(__GNUC__)
+#define COMPILER_VERSION_MAJOR DEC(__GNUC__)
+#else
+#define COMPILER_VERSION_MAJOR DEC(__GNUG__)
+#endif
+#if defined(__GNUC_MINOR__)
+#define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
+#endif
+#if defined(__GNUC_PATCHLEVEL__)
+#define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
+#endif
 
 #elif defined(_MSC_VER)
-# define COMPILER_ID "MSVC"
-  /* _MSC_VER = VVRR */
-# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
-# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
-# if defined(_MSC_FULL_VER)
-#  if _MSC_VER >= 1400
-    /* _MSC_FULL_VER = VVRRPPPPP */
-#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
-#  else
-    /* _MSC_FULL_VER = VVRRPPPP */
-#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
-#  endif
-# endif
-# if defined(_MSC_BUILD)
-#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
-# endif
+#define COMPILER_ID "MSVC"
+/* _MSC_VER = VVRR */
+#define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
+#define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
+#if defined(_MSC_FULL_VER)
+#if _MSC_VER >= 1400
+/* _MSC_FULL_VER = VVRRPPPPP */
+#define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
+#else
+/* _MSC_FULL_VER = VVRRPPPP */
+#define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
+#endif
+#endif
+#if defined(_MSC_BUILD)
+#define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
+#endif
 
 #elif defined(_ADI_COMPILER)
-# define COMPILER_ID "ADSP"
+#define COMPILER_ID "ADSP"
 #if defined(__VERSIONNUM__)
-  /* __VERSIONNUM__ = 0xVVRRPPTT */
-#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
-#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
-#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
-#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
+/* __VERSIONNUM__ = 0xVVRRPPTT */
+#define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
+#define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
+#define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
+#define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
 #endif
 
 #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
-# define COMPILER_ID "IAR"
-# if defined(__VER__) && defined(__ICCARM__)
-#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
-#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
-#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
-#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
-# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
-#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
-#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
-#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
-#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
-# endif
-
+#define COMPILER_ID "IAR"
+#if defined(__VER__) && defined(__ICCARM__)
+#define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
+#define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
+#define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
+#define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
+#elif defined(__VER__) &&                                                    \
+    (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) ||   \
+     defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || \
+     defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
+#define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
+#define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100) * 100))
+#define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
+#define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
+#endif
 
 /* These compilers are either not known or too old to define an
   identification macro.  Try to identify the platform and guess that
   it is the native compiler.  */
 #elif defined(__hpux) || defined(__hpua)
-# define COMPILER_ID "HP"
+#define COMPILER_ID "HP"
 
 #else /* unknown compiler */
-# define COMPILER_ID ""
+#define COMPILER_ID ""
 #endif
 
 /* Construct the string literal in pieces to prevent the source from
    getting matched.  Store it in a pointer rather than an array
    because some compilers will just produce instructions to fill the
    array rather than assigning a pointer to a static array.  */
-char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
+char const* info_compiler =
+    "INFO"
+    ":"
+    "compiler[" COMPILER_ID "]";
 #ifdef SIMULATE_ID
-char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
+char const* info_simulate =
+    "INFO"
+    ":"
+    "simulate[" SIMULATE_ID "]";
 #endif
 
 #ifdef __QNXNTO__
-char const* qnxnto = "INFO" ":" "qnxnto[]";
+char const* qnxnto =
+    "INFO"
+    ":"
+    "qnxnto[]";
 #endif
 
 #if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
-char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
+char const* info_cray =
+    "INFO"
+    ":"
+    "compiler_wrapper[CrayPrgEnv]";
 #endif
 
 #define STRINGIFY_HELPER(X) #X
@@ -450,113 +460,114 @@

 
 /* Identify known platforms by name.  */
 #if defined(__linux) || defined(__linux__) || defined(linux)
-# define PLATFORM_ID "Linux"
+#define PLATFORM_ID "Linux"
 
 #elif defined(__MSYS__)
-# define PLATFORM_ID "MSYS"
+#define PLATFORM_ID "MSYS"
 
 #elif defined(__CYGWIN__)
-# define PLATFORM_ID "Cygwin"
+#define PLATFORM_ID "Cygwin"
 
 #elif defined(__MINGW32__)
-# define PLATFORM_ID "MinGW"
+#define PLATFORM_ID "MinGW"
 
 #elif defined(__APPLE__)
-# define PLATFORM_ID "Darwin"
+#define PLATFORM_ID "Darwin"
 
 #elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
-# define PLATFORM_ID "Windows"
+#define PLATFORM_ID "Windows"
 
 #elif defined(__FreeBSD__) || defined(__FreeBSD)
-# define PLATFORM_ID "FreeBSD"
+#define PLATFORM_ID "FreeBSD"
 
 #elif defined(__NetBSD__) || defined(__NetBSD)
-# define PLATFORM_ID "NetBSD"
+#define PLATFORM_ID "NetBSD"
 
 #elif defined(__OpenBSD__) || defined(__OPENBSD)
-# define PLATFORM_ID "OpenBSD"
+#define PLATFORM_ID "OpenBSD"
 
 #elif defined(__sun) || defined(sun)
-# define PLATFORM_ID "SunOS"
-
-#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
-# define PLATFORM_ID "AIX"
+#define PLATFORM_ID "SunOS"
+
+#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || \
+    defined(__aix__)
+#define PLATFORM_ID "AIX"
 
 #elif defined(__hpux) || defined(__hpux__)
-# define PLATFORM_ID "HP-UX"
+#define PLATFORM_ID "HP-UX"
 
 #elif defined(__HAIKU__)
-# define PLATFORM_ID "Haiku"
+#define PLATFORM_ID "Haiku"
 
 #elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
-# define PLATFORM_ID "BeOS"
+#define PLATFORM_ID "BeOS"
 
 #elif defined(__QNX__) || defined(__QNXNTO__)
-# define PLATFORM_ID "QNX"
+#define PLATFORM_ID "QNX"
 
 #elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
-# define PLATFORM_ID "Tru64"
+#define PLATFORM_ID "Tru64"
 
 #elif defined(__riscos) || defined(__riscos__)
-# define PLATFORM_ID "RISCos"
+#define PLATFORM_ID "RISCos"
 
 #elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
-# define PLATFORM_ID "SINIX"
+#define PLATFORM_ID "SINIX"
 
 #elif defined(__UNIX_SV__)
-# define PLATFORM_ID "UNIX_SV"
+#define PLATFORM_ID "UNIX_SV"
 
 #elif defined(__bsdos__)
-# define PLATFORM_ID "BSDOS"
+#define PLATFORM_ID "BSDOS"
 
 #elif defined(_MPRAS) || defined(MPRAS)
-# define PLATFORM_ID "MP-RAS"
+#define PLATFORM_ID "MP-RAS"
 
 #elif defined(__osf) || defined(__osf__)
-# define PLATFORM_ID "OSF1"
+#define PLATFORM_ID "OSF1"
 
 #elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
-# define PLATFORM_ID "SCO_SV"
+#define PLATFORM_ID "SCO_SV"
 
 #elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
-# define PLATFORM_ID "ULTRIX"
+#define PLATFORM_ID "ULTRIX"
 
 #elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
-# define PLATFORM_ID "Xenix"
+#define PLATFORM_ID "Xenix"
 
 #elif defined(__WATCOMC__)
-# if defined(__LINUX__)
-#  define PLATFORM_ID "Linux"
-
-# elif defined(__DOS__)
-#  define PLATFORM_ID "DOS"
-
-# elif defined(__OS2__)
-#  define PLATFORM_ID "OS2"
-
-# elif defined(__WINDOWS__)
-#  define PLATFORM_ID "Windows3x"
-
-# elif defined(__VXWORKS__)
-#  define PLATFORM_ID "VxWorks"
-
-# else /* unknown platform */
-#  define PLATFORM_ID
-# endif
+#if defined(__LINUX__)
+#define PLATFORM_ID "Linux"
+
+#elif defined(__DOS__)
+#define PLATFORM_ID "DOS"
+
+#elif defined(__OS2__)
+#define PLATFORM_ID "OS2"
+
+#elif defined(__WINDOWS__)
+#define PLATFORM_ID "Windows3x"
+
+#elif defined(__VXWORKS__)
+#define PLATFORM_ID "VxWorks"
+
+#else /* unknown platform */
+#define PLATFORM_ID
+#endif
 
 #elif defined(__INTEGRITY)
-# if defined(INT_178B)
-#  define PLATFORM_ID "Integrity178"
-
-# else /* regular Integrity */
-#  define PLATFORM_ID "Integrity"
-# endif
-
-# elif defined(_ADI_COMPILER)
-#  define PLATFORM_ID "ADSP"
+#if defined(INT_178B)
+#define PLATFORM_ID "Integrity178"
+
+#else /* regular Integrity */
+#define PLATFORM_ID "Integrity"
+#endif
+
+#elif defined(_ADI_COMPILER)
+#define PLATFORM_ID "ADSP"
 
 #else /* unknown platform */
-# define PLATFORM_ID
+#define PLATFORM_ID
 
 #endif
 
@@ -566,246 +577,295 @@

    but rather depend on which compiler is being used
 */
 #if defined(_WIN32) && defined(_MSC_VER)
-# if defined(_M_IA64)
-#  define ARCHITECTURE_ID "IA64"
-
-# elif defined(_M_ARM64EC)
-#  define ARCHITECTURE_ID "ARM64EC"
-
-# elif defined(_M_X64) || defined(_M_AMD64)
-#  define ARCHITECTURE_ID "x64"
-
-# elif defined(_M_IX86)
-#  define ARCHITECTURE_ID "X86"
-
-# elif defined(_M_ARM64)
-#  define ARCHITECTURE_ID "ARM64"
-
-# elif defined(_M_ARM)
-#  if _M_ARM == 4
-#   define ARCHITECTURE_ID "ARMV4I"
-#  elif _M_ARM == 5
-#   define ARCHITECTURE_ID "ARMV5I"
-#  else
-#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
-#  endif
-
-# elif defined(_M_MIPS)
-#  define ARCHITECTURE_ID "MIPS"
-
-# elif defined(_M_SH)
-#  define ARCHITECTURE_ID "SHx"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(_M_IA64)
+#define ARCHITECTURE_ID "IA64"
+
+#elif defined(_M_ARM64EC)
+#define ARCHITECTURE_ID "ARM64EC"
+
+#elif defined(_M_X64) || defined(_M_AMD64)
+#define ARCHITECTURE_ID "x64"
+
+#elif defined(_M_IX86)
+#define ARCHITECTURE_ID "X86"
+
+#elif defined(_M_ARM64)
+#define ARCHITECTURE_ID "ARM64"
+
+#elif defined(_M_ARM)
+#if _M_ARM == 4
+#define ARCHITECTURE_ID "ARMV4I"
+#elif _M_ARM == 5
+#define ARCHITECTURE_ID "ARMV5I"
+#else
+#define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
+#endif
+
+#elif defined(_M_MIPS)
+#define ARCHITECTURE_ID "MIPS"
+
+#elif defined(_M_SH)
+#define ARCHITECTURE_ID "SHx"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__WATCOMC__)
-# if defined(_M_I86)
-#  define ARCHITECTURE_ID "I86"
-
-# elif defined(_M_IX86)
-#  define ARCHITECTURE_ID "X86"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(_M_I86)
+#define ARCHITECTURE_ID "I86"
+
+#elif defined(_M_IX86)
+#define ARCHITECTURE_ID "X86"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
-# if defined(__ICCARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__ICCRX__)
-#  define ARCHITECTURE_ID "RX"
-
-# elif defined(__ICCRH850__)
-#  define ARCHITECTURE_ID "RH850"
-
-# elif defined(__ICCRL78__)
-#  define ARCHITECTURE_ID "RL78"
-
-# elif defined(__ICCRISCV__)
-#  define ARCHITECTURE_ID "RISCV"
-
-# elif defined(__ICCAVR__)
-#  define ARCHITECTURE_ID "AVR"
-
-# elif defined(__ICC430__)
-#  define ARCHITECTURE_ID "MSP430"
-
-# elif defined(__ICCV850__)
-#  define ARCHITECTURE_ID "V850"
-
-# elif defined(__ICC8051__)
-#  define ARCHITECTURE_ID "8051"
-
-# elif defined(__ICCSTM8__)
-#  define ARCHITECTURE_ID "STM8"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(__ICCARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__ICCRX__)
+#define ARCHITECTURE_ID "RX"
+
+#elif defined(__ICCRH850__)
+#define ARCHITECTURE_ID "RH850"
+
+#elif defined(__ICCRL78__)
+#define ARCHITECTURE_ID "RL78"
+
+#elif defined(__ICCRISCV__)
+#define ARCHITECTURE_ID "RISCV"
+
+#elif defined(__ICCAVR__)
+#define ARCHITECTURE_ID "AVR"
+
+#elif defined(__ICC430__)
+#define ARCHITECTURE_ID "MSP430"
+
+#elif defined(__ICCV850__)
+#define ARCHITECTURE_ID "V850"
+
+#elif defined(__ICC8051__)
+#define ARCHITECTURE_ID "8051"
+
+#elif defined(__ICCSTM8__)
+#define ARCHITECTURE_ID "STM8"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__ghs__)
-# if defined(__PPC64__)
-#  define ARCHITECTURE_ID "PPC64"
-
-# elif defined(__ppc__)
-#  define ARCHITECTURE_ID "PPC"
-
-# elif defined(__ARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__x86_64__)
-#  define ARCHITECTURE_ID "x64"
-
-# elif defined(__i386__)
-#  define ARCHITECTURE_ID "X86"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(__PPC64__)
+#define ARCHITECTURE_ID "PPC64"
+
+#elif defined(__ppc__)
+#define ARCHITECTURE_ID "PPC"
+
+#elif defined(__ARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__x86_64__)
+#define ARCHITECTURE_ID "x64"
+
+#elif defined(__i386__)
+#define ARCHITECTURE_ID "X86"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__clang__) && defined(__ti__)
-# if defined(__ARM_ARCH)
-#  define ARCHITECTURE_ID "ARM"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
+#if defined(__ARM_ARCH)
+#define ARCHITECTURE_ID "ARM"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
 
 #elif defined(__TI_COMPILER_VERSION__)
-# if defined(__TI_ARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__MSP430__)
-#  define ARCHITECTURE_ID "MSP430"
-
-# elif defined(__TMS320C28XX__)
-#  define ARCHITECTURE_ID "TMS320C28x"
-
-# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
-#  define ARCHITECTURE_ID "TMS320C6x"
-
-# else /* unknown architecture */
-#  define ARCHITECTURE_ID ""
-# endif
-
-# elif defined(__ADSPSHARC__)
-#  define ARCHITECTURE_ID "SHARC"
-
-# elif defined(__ADSPBLACKFIN__)
-#  define ARCHITECTURE_ID "Blackfin"
+#if defined(__TI_ARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__MSP430__)
+#define ARCHITECTURE_ID "MSP430"
+
+#elif defined(__TMS320C28XX__)
+#define ARCHITECTURE_ID "TMS320C28x"
+
+#elif defined(__TMS320C6X__) || defined(_TMS320C6X)
+#define ARCHITECTURE_ID "TMS320C6x"
+
+#else /* unknown architecture */
+#define ARCHITECTURE_ID ""
+#endif
+
+#elif defined(__ADSPSHARC__)
+#define ARCHITECTURE_ID "SHARC"
+
+#elif defined(__ADSPBLACKFIN__)
+#define ARCHITECTURE_ID "Blackfin"
 
 #elif defined(__TASKING__)
 
-# if defined(__CTC__) || defined(__CPTC__)
-#  define ARCHITECTURE_ID "TriCore"
-
-# elif defined(__CMCS__)
-#  define ARCHITECTURE_ID "MCS"
-
-# elif defined(__CARM__) || defined(__CPARM__)
-#  define ARCHITECTURE_ID "ARM"
-
-# elif defined(__CARC__)
-#  define ARCHITECTURE_ID "ARC"
-
-# elif defined(__C51__)
-#  define ARCHITECTURE_ID "8051"
-
-# elif defined(__CPCP__)
-#  define ARCHITECTURE_ID "PCP"
-
-# else
-#  define ARCHITECTURE_ID ""
-# endif
-
-#else
-#  define ARCHITECTURE_ID
+#if defined(__CTC__) || defined(__CPTC__)
+#define ARCHITECTURE_ID "TriCore"
+
+#elif defined(__CMCS__)
+#define ARCHITECTURE_ID "MCS"
+
+#elif defined(__CARM__) || defined(__CPARM__)
+#define ARCHITECTURE_ID "ARM"
+
+#elif defined(__CARC__)
+#define ARCHITECTURE_ID "ARC"
+
+#elif defined(__C51__)
+#define ARCHITECTURE_ID "8051"
+
+#elif defined(__CPCP__)
+#define ARCHITECTURE_ID "PCP"
+
+#else
+#define ARCHITECTURE_ID ""
+#endif
+
+#else
+#define ARCHITECTURE_ID
 #endif
 
 /* Convert integer to decimal digit literals.  */
-#define DEC(n)                   \
-  ('0' + (((n) / 10000000)%10)), \
-  ('0' + (((n) / 1000000)%10)),  \
-  ('0' + (((n) / 100000)%10)),   \
-  ('0' + (((n) / 10000)%10)),    \
-  ('0' + (((n) / 1000)%10)),     \
-  ('0' + (((n) / 100)%10)),      \
-  ('0' + (((n) / 10)%10)),       \
-  ('0' +  ((n) % 10))
+#define DEC(n)                                                     \
+  ('0' + (((n) / 10000000) % 10)), ('0' + (((n) / 1000000) % 10)), \
+      ('0' + (((n) / 100000) % 10)), ('0' + (((n) / 10000) % 10)), \
+      ('0' + (((n) / 1000) % 10)), ('0' + (((n) / 100) % 10)),     \
+      ('0' + (((n) / 10) % 10)), ('0' + ((n) % 10))
 
 /* Convert integer to hex digit literals.  */
-#define HEX(n)             \
-  ('0' + ((n)>>28 & 0xF)), \
-  ('0' + ((n)>>24 & 0xF)), \
-  ('0' + ((n)>>20 & 0xF)), \
-  ('0' + ((n)>>16 & 0xF)), \
-  ('0' + ((n)>>12 & 0xF)), \
-  ('0' + ((n)>>8  & 0xF)), \
-  ('0' + ((n)>>4  & 0xF)), \
-  ('0' + ((n)     & 0xF))
+#define HEX(n)                                              \
+  ('0' + ((n) >> 28 & 0xF)), ('0' + ((n) >> 24 & 0xF)),     \
+      ('0' + ((n) >> 20 & 0xF)), ('0' + ((n) >> 16 & 0xF)), \
+      ('0' + ((n) >> 12 & 0xF)), ('0' + ((n) >> 8 & 0xF)),  \
+      ('0' + ((n) >> 4 & 0xF)), ('0' + ((n) & 0xF))
 
 /* Construct a string literal encoding the version number. */
 #ifdef COMPILER_VERSION
-char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";
+char const* info_version =
+    "INFO"
+    ":"
+    "compiler_version[" COMPILER_VERSION "]";
 
 /* Construct a string literal encoding the version number components. */
 #elif defined(COMPILER_VERSION_MAJOR)
-char const info_version[] = {
-  'I', 'N', 'F', 'O', ':',
-  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
-  COMPILER_VERSION_MAJOR,
-# ifdef COMPILER_VERSION_MINOR
-  '.', COMPILER_VERSION_MINOR,
-#  ifdef COMPILER_VERSION_PATCH
-   '.', COMPILER_VERSION_PATCH,
-#   ifdef COMPILER_VERSION_TWEAK
-    '.', COMPILER_VERSION_TWEAK,
-#   endif
-#  endif
-# endif
-  ']','\0'};
+char const info_version[] = {'I',
+                             'N',
+                             'F',
+                             'O',
+                             ':',
+                             'c',
+                             'o',
+                             'm',
+                             'p',
+                             'i',
+                             'l',
+                             'e',
+                             'r',
+                             '_',
+                             'v',
+                             'e',
+                             'r',
+                             's',
+                             'i',
+                             'o',
+                             'n',
+                             '[',
+                             COMPILER_VERSION_MAJOR,
+#ifdef COMPILER_VERSION_MINOR
+                             '.',
+                             COMPILER_VERSION_MINOR,
+#ifdef COMPILER_VERSION_PATCH
+                             '.',
+                             COMPILER_VERSION_PATCH,
+#ifdef COMPILER_VERSION_TWEAK
+                             '.',
+                             COMPILER_VERSION_TWEAK,
+#endif
+#endif
+#endif
+                             ']',
+                             '\0'};
 #endif
 
 /* Construct a string literal encoding the internal version number. */
 #ifdef COMPILER_VERSION_INTERNAL
 char const info_version_internal[] = {
-  'I', 'N', 'F', 'O', ':',
-  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
-  'i','n','t','e','r','n','a','l','[',
-  COMPILER_VERSION_INTERNAL,']','\0'};
+    'I', 'N', 'F', 'O', ':', 'c', 'o', 'm',
+    'p', 'i', 'l', 'e', 'r', '_', 'v', 'e',
+    'r', 's', 'i', 'o', 'n', '_', 'i', 'n',
+    't', 'e', 'r', 'n', 'a', 'l', '[', COMPILER_VERSION_INTERNAL,
+    ']', '\0'};
 #elif defined(COMPILER_VERSION_INTERNAL_STR)
-char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
+char const* info_version_internal =
+    "INFO"
+    ":"
+    "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
 #endif
 
 /* Construct a string literal encoding the version number components. */
 #ifdef SIMULATE_VERSION_MAJOR
-char const info_simulate_version[] = {
-  'I', 'N', 'F', 'O', ':',
-  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
-  SIMULATE_VERSION_MAJOR,
-# ifdef SIMULATE_VERSION_MINOR
-  '.', SIMULATE_VERSION_MINOR,
-#  ifdef SIMULATE_VERSION_PATCH
-   '.', SIMULATE_VERSION_PATCH,
-#   ifdef SIMULATE_VERSION_TWEAK
-    '.', SIMULATE_VERSION_TWEAK,
-#   endif
-#  endif
-# endif
-  ']','\0'};
+char const info_simulate_version[] = {'I',
+                                      'N',
+                                      'F',
+                                      'O',
+                                      ':',
+                                      's',
+                                      'i',
+                                      'm',
+                                      'u',
+                                      'l',
+                                      'a',
+                                      't',
+                                      'e',
+                                      '_',
+                                      'v',
+                                      'e',
+                                      'r',
+                                      's',
+                                      'i',
+                                      'o',
+                                      'n',
+                                      '[',
+                                      SIMULATE_VERSION_MAJOR,
+#ifdef SIMULATE_VERSION_MINOR
+                                      '.',
+                                      SIMULATE_VERSION_MINOR,
+#ifdef SIMULATE_VERSION_PATCH
+                                      '.',
+                                      SIMULATE_VERSION_PATCH,
+#ifdef SIMULATE_VERSION_TWEAK
+                                      '.',
+                                      SIMULATE_VERSION_TWEAK,
+#endif
+#endif
+#endif
+                                      ']',
+                                      '\0'};
 #endif
 
 /* Construct the string literal in pieces to prevent the source from
    getting matched.  Store it in a pointer rather than an array
    because some compilers will just produce instructions to fill the
    array rather than assigning a pointer to a static array.  */
-char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
-char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";
-
-
+char const* info_platform =
+    "INFO"
+    ":"
+    "platform[" PLATFORM_ID "]";
+char const* info_arch =
+    "INFO"
+    ":"
+    "arch[" ARCHITECTURE_ID "]";
 
 #define CXX_STD_98 199711L
 #define CXX_STD_11 201103L
@@ -815,85 +875,90 @@

 #define CXX_STD_23 202302L
 
 #if defined(__INTEL_COMPILER) && defined(_MSVC_LANG)
-#  if _MSVC_LANG > CXX_STD_17
-#    define CXX_STD _MSVC_LANG
-#  elif _MSVC_LANG == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
-#    define CXX_STD CXX_STD_20
-#  elif _MSVC_LANG > CXX_STD_14 && __cplusplus > CXX_STD_17
-#    define CXX_STD CXX_STD_20
-#  elif _MSVC_LANG > CXX_STD_14
-#    define CXX_STD CXX_STD_17
-#  elif defined(__INTEL_CXX11_MODE__) && defined(__cpp_aggregate_nsdmi)
-#    define CXX_STD CXX_STD_14
-#  elif defined(__INTEL_CXX11_MODE__)
-#    define CXX_STD CXX_STD_11
-#  else
-#    define CXX_STD CXX_STD_98
-#  endif
+#if _MSVC_LANG > CXX_STD_17
+#define CXX_STD _MSVC_LANG
+#elif _MSVC_LANG == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
+#define CXX_STD CXX_STD_20
+#elif _MSVC_LANG > CXX_STD_14 && __cplusplus > CXX_STD_17
+#define CXX_STD CXX_STD_20
+#elif _MSVC_LANG > CXX_STD_14
+#define CXX_STD CXX_STD_17
+#elif defined(__INTEL_CXX11_MODE__) && defined(__cpp_aggregate_nsdmi)
+#define CXX_STD CXX_STD_14
+#elif defined(__INTEL_CXX11_MODE__)
+#define CXX_STD CXX_STD_11
+#else
+#define CXX_STD CXX_STD_98
+#endif
 #elif defined(_MSC_VER) && defined(_MSVC_LANG)
-#  if _MSVC_LANG > __cplusplus
-#    define CXX_STD _MSVC_LANG
-#  else
-#    define CXX_STD __cplusplus
-#  endif
+#if _MSVC_LANG > __cplusplus
+#define CXX_STD _MSVC_LANG
+#else
+#define CXX_STD __cplusplus
+#endif
 #elif defined(__NVCOMPILER)
-#  if __cplusplus == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
-#    define CXX_STD CXX_STD_20
-#  else
-#    define CXX_STD __cplusplus
-#  endif
+#if __cplusplus == CXX_STD_17 && defined(__cpp_aggregate_paren_init)
+#define CXX_STD CXX_STD_20
+#else
+#define CXX_STD __cplusplus
+#endif
 #elif defined(__INTEL_COMPILER) || defined(__PGI)
-#  if __cplusplus == CXX_STD_11 && defined(__cpp_namespace_attributes)
-#    define CXX_STD CXX_STD_17
-#  elif __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
-#    define CXX_STD CXX_STD_14
-#  else
-#    define CXX_STD __cplusplus
-#  endif
+#if __cplusplus == CXX_STD_11 && defined(__cpp_namespace_attributes)
+#define CXX_STD CXX_STD_17
+#elif __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
+#define CXX_STD CXX_STD_14
+#else
+#define CXX_STD __cplusplus
+#endif
 #elif (defined(__IBMCPP__) || defined(__ibmxl__)) && defined(__linux__)
-#  if __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
-#    define CXX_STD CXX_STD_14
-#  else
-#    define CXX_STD __cplusplus
-#  endif
+#if __cplusplus == CXX_STD_11 && defined(__cpp_aggregate_nsdmi)
+#define CXX_STD CXX_STD_14
+#else
+#define CXX_STD __cplusplus
+#endif
 #elif __cplusplus == 1 && defined(__GXX_EXPERIMENTAL_CXX0X__)
-#  define CXX_STD CXX_STD_11
-#else
-#  define CXX_STD __cplusplus
-#endif
-
-const char* info_language_standard_default = "INFO" ":" "standard_default["
+#define CXX_STD CXX_STD_11
+#else
+#define CXX_STD __cplusplus
+#endif
+
+const char* info_language_standard_default =
+    "INFO"
+    ":"
+    "standard_default["
 #if CXX_STD > CXX_STD_23
-  "26"
+    "26"
 #elif CXX_STD > CXX_STD_20
-  "23"
+    "23"
 #elif CXX_STD > CXX_STD_17
-  "20"
+    "20"
 #elif CXX_STD > CXX_STD_14
-  "17"
+    "17"
 #elif CXX_STD > CXX_STD_11
-  "14"
+    "14"
 #elif CXX_STD >= CXX_STD_11
-  "11"
-#else
-  "98"
-#endif
-"]";
-
-const char* info_language_extensions_default = "INFO" ":" "extensions_default["
-#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
-     defined(__TI_COMPILER_VERSION__)) &&                                     \
-  !defined(__STRICT_ANSI__)
-  "ON"
-#else
-  "OFF"
-#endif
-"]";
+    "11"
+#else
+    "98"
+#endif
+    "]";
+
+const char* info_language_extensions_default =
+    "INFO"
+    ":"
+    "extensions_default["
+#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) || \
+     defined(__TI_COMPILER_VERSION__)) &&                           \
+    !defined(__STRICT_ANSI__)
+    "ON"
+#else
+    "OFF"
+#endif
+    "]";
 
 /*--------------------------------------------------------------------------*/
 
-int main(int argc, char* argv[])
-{
+int main(int argc, char* argv[]) {
   int require = 0;
   require += info_compiler[argc];
   require += info_platform[argc];
tests/mechanical_layer/include/MechanicalLayer.h
====================
--- original

+++ formatted

@@ -1,89 +1,107 @@

 #ifndef MECHANICAL_LAYER_H
 #define MECHANICAL_LAYER_H
 
-#include "Globals.h"
-#include "Agent.h"
 #include <array>
 #include <set>
 #include <unordered_set>
 
+#include "Agent.h"
+#include "Globals.h"
+
 /// Helper list to make indices explicit
 enum __attribute__((__packed__)) interactionsOutput_e {
-  SLIP        = 0,
+  SLIP = 0,
   FORCE_ORTHO = 1,
-  FORCE_TAN   = 2,
+  FORCE_TAN = 2,
 };
 
 struct MechanicalLayer
 /**
- * @brief Class representing the mechanical behavior of a crowd of pedestrians with non-circular shapes.
+ * @brief Class representing the mechanical behavior of a crowd of pedestrians
+ * with non-circular shapes.
  *
- * This class handles the mechanical interactions between pedestrians in a crowd.
- * It keeps track of the positions, velocities, orientations, and forces acting on each pedestrian.
- * The class also provides methods for updating the positions and velocities of the pedestrians
- * and saving the configuration to a file.
+ * This class handles the mechanical interactions between pedestrians in a
+ * crowd. It keeps track of the positions, velocities, orientations, and forces
+ * acting on each pedestrian. The class also provides methods for updating the
+ * positions and velocities of the pedestrians and saving the configuration to a
+ * file.
  */
 {
-  private:
-    unsigned nb_active_agents;        // number of mechanically active agens
-    unsigned nb_active_shapes;        // number of pedestrians (each pedestrian is a collection of active agents)
-    std::vector<double2> vgn;         // velocity of the center of mass (CM) of each pedestrian at t
-    std::vector<double2> vgnp1;       // velocity of the CM of each pedestrian at t+dt
-    std::vector<double2> rgcomp;      // initial positions of all the components of the pedestrians
-    std::vector<double2> rgn;         // positions of the CM of each pedestrian at t
-    std::vector<double2> rgnp1;       // positions of the CM of each pedestrian at t+dt
-    std::vector<double2> delta;       // difference between position of the CM of each component and the CM of their associated pedestrian
-    std::vector<double> thetn;        // orientation wrt x-axis at t
-    std::vector<double> thetnp1;      // orientation wrt x-axis at t+dt
-    std::vector<double> wn;           // angular velocity at t
-    std::vector<double> wnp1;         // angular velocity at t+dt
-    std::vector<double> wdesired;     // desired orientation wrt x-axis (constant during the execution of the crowd_mech file)
-    std::vector<double2> Fp;          // propelling forces v_des/tau_mech
-    std::vector<double2> Forthon;     // orthogonal force (hertz) wrt contact surface at time t
-    std::vector<double2> Ftn;         // tangential force wrt contact surface at time t
-    std::vector<double> taun;         // torque at time t (moment projected on z-axis) expressed at the CM
-    std::vector<std::list<int>> neighbours;
-    std::vector<unsigned> active_shapeIDagent;        // pedestrian id of each shape (goes from 0 to nb_active_shapes - 1)
-    std::vector<unsigned> active_shapeIDshape_crowd;  // shape id of each pedestrian
-    std::vector<double> radius;                       // radius off all shapes of actives agents
-    std::vector<unsigned> size_agents;
-    std::map<unsigned, unsigned> agentIds;
-    std::vector<unsigned> agentActiveIds;
-    std::vector<std::vector<unsigned>> neighbours_shape;
-    std::vector<unsigned> agentIDshape;
-    std::vector<double> masses;
-    std::vector<double> mois;
-    std::vector<double2> damping;
+ private:
+  unsigned nb_active_agents;  // number of mechanically active agens
+  unsigned nb_active_shapes;  // number of pedestrians (each pedestrian is a
+                              // collection of active agents)
+  std::vector<double2>
+      vgn;  // velocity of the center of mass (CM) of each pedestrian at t
+  std::vector<double2> vgnp1;  // velocity of the CM of each pedestrian at t+dt
+  std::vector<double2>
+      rgcomp;  // initial positions of all the components of the pedestrians
+  std::vector<double2> rgn;    // positions of the CM of each pedestrian at t
+  std::vector<double2> rgnp1;  // positions of the CM of each pedestrian at t+dt
+  std::vector<double2>
+      delta;  // difference between position of the CM of each component and the
+              // CM of their associated pedestrian
+  std::vector<double> thetn;     // orientation wrt x-axis at t
+  std::vector<double> thetnp1;   // orientation wrt x-axis at t+dt
+  std::vector<double> wn;        // angular velocity at t
+  std::vector<double> wnp1;      // angular velocity at t+dt
+  std::vector<double> wdesired;  // desired orientation wrt x-axis (constant
+                                 // during the execution of the crowd_mech file)
+  std::vector<double2> Fp;       // propelling forces v_des/tau_mech
+  std::vector<double2>
+      Forthon;  // orthogonal force (hertz) wrt contact surface at time t
+  std::vector<double2> Ftn;  // tangential force wrt contact surface at time t
+  std::vector<double> taun;  // torque at time t (moment projected on z-axis)
+                             // expressed at the CM
+  std::vector<std::list<int>> neighbours;
+  std::vector<unsigned>
+      active_shapeIDagent;  // pedestrian id of each shape (goes from 0 to
+                            // nb_active_shapes - 1)
+  std::vector<unsigned>
+      active_shapeIDshape_crowd;  // shape id of each pedestrian
+  std::vector<double> radius;     // radius off all shapes of actives agents
+  std::vector<unsigned> size_agents;
+  std::map<unsigned, unsigned> agentIds;
+  std::vector<unsigned> agentActiveIds;
+  std::vector<std::vector<unsigned>> neighbours_shape;
+  std::vector<unsigned> agentIDshape;
+  std::vector<double> masses;
+  std::vector<double> mois;
+  std::vector<double2> damping;
 
-    /// Tangential relative displacement when in contact
-    std::map<std::pair<unsigned, unsigned>, double2> slip;
-    std::map<std::tuple<unsigned, int, int>, double2> slip_wall;
+  /// Tangential relative displacement when in contact
+  std::map<std::pair<unsigned, unsigned>, double2> slip;
+  std::map<std::tuple<unsigned, int, int>, double2> slip_wall;
 
-    //  For output purposes: the following variables will contain:
-    //    - a copy of slip
-    //    - fortho from shape to shape
-    //    - ft from shape to shape
-    std::map<std::pair<unsigned, unsigned>, std::array<double2,3>> interactionsOutput;
-    std::map<std::tuple<unsigned, int, int>, std::array<double2,3>> interactionsOutputWall;
+  //  For output purposes: the following variables will contain:
+  //    - a copy of slip
+  //    - fortho from shape to shape
+  //    - ft from shape to shape
+  std::map<std::pair<unsigned, unsigned>, std::array<double2, 3>>
+      interactionsOutput;
+  std::map<std::tuple<unsigned, int, int>, std::array<double2, 3>>
+      interactionsOutputWall;
 
-    std::tuple<double2, double2, double> get_interactions(unsigned cpt_shape, bool AtTimen);
-    void loop();
-    /// AgentInteractions is an input and output file (ie "dynamic") of this process
-    int readInteractionsInputFile(const std::string& interactionsFile);
-    std::pair<bool, bool> existsContacts();   /// Do contacts exist?
-    void generateInteractionsOutputFile(const std::string&, const std::pair<bool, bool> &);
+  std::tuple<double2, double2, double> get_interactions(unsigned cpt_shape,
+                                                        bool AtTimen);
+  void loop();
+  /// AgentInteractions is an input and output file (ie "dynamic") of this
+  /// process
+  int readInteractionsInputFile(const std::string& interactionsFile);
+  std::pair<bool, bool> existsContacts();  /// Do contacts exist?
+  void generateInteractionsOutputFile(const std::string&,
+                                      const std::pair<bool, bool>&);
 
-  public:
-    /**
-     * @brief Initializes a CrowdMech object.
-     *
-     * This constructor initializes a CrowdMech object with the given parameters.
-     *
-     * @param agents A std::list of Agent pointers representing the crowd agents.
-     */
-    explicit MechanicalLayer(std::list<Agent*>& agents);
-    ~MechanicalLayer();
+ public:
+  /**
+   * @brief Initializes a CrowdMech object.
+   *
+   * This constructor initializes a CrowdMech object with the given parameters.
+   *
+   * @param agents A std::list of Agent pointers representing the crowd agents.
+   */
+  explicit MechanicalLayer(std::list<Agent*>& agents);
+  ~MechanicalLayer();
 };
 
-
-#endif  /*  MECHANICAL_LAYER_H */
+#endif /*  MECHANICAL_LAYER_H */
tests/mechanical_layer/src/MechanicalLayer.cpp
====================
--- original

+++ formatted

@@ -8,116 +8,135 @@

  * @param mech_active_agents A list of active agents.
  */
 MechanicalLayer::MechanicalLayer(list<Agent*>& mech_active_agents)
-    : nb_active_agents(mech_active_agents.size()), nb_active_shapes(0), vgn(nb_active_agents), vgnp1(nb_active_agents), rgn(nb_active_agents),
-      rgnp1(nb_active_agents), delta(0), thetn(nb_active_agents), thetnp1(nb_active_agents), wn(nb_active_agents), wnp1(nb_active_agents),
-      wdesired(nb_active_agents), Fp(nb_active_agents), Forthon(nb_active_agents), Ftn(nb_active_agents), taun(nb_active_agents),
-      neighbours(nb_active_agents), active_shapeIDagent(0), active_shapeIDshape_crowd(0), radius(0), size_agents(nb_active_agents),
-      neighbours_shape(nb_active_agents), agentIDshape(nb_active_agents + 1, 0), masses(nb_active_agents),
-      mois(nb_active_agents), damping(nb_active_agents)
+    : nb_active_agents(mech_active_agents.size()),
+      nb_active_shapes(0),
+      vgn(nb_active_agents),
+      vgnp1(nb_active_agents),
+      rgn(nb_active_agents),
+      rgnp1(nb_active_agents),
+      delta(0),
+      thetn(nb_active_agents),
+      thetnp1(nb_active_agents),
+      wn(nb_active_agents),
+      wnp1(nb_active_agents),
+      wdesired(nb_active_agents),
+      Fp(nb_active_agents),
+      Forthon(nb_active_agents),
+      Ftn(nb_active_agents),
+      taun(nb_active_agents),
+      neighbours(nb_active_agents),
+      active_shapeIDagent(0),
+      active_shapeIDshape_crowd(0),
+      radius(0),
+      size_agents(nb_active_agents),
+      neighbours_shape(nb_active_agents),
+      agentIDshape(nb_active_agents + 1, 0),
+      masses(nb_active_agents),
+      mois(nb_active_agents),
+      damping(nb_active_agents)
 
 {
-    /*  Preliminary definitions and initialisation  */
-    //  Sort mechanically active agents
-    mech_active_agents.sort([](auto const& a, auto const& b) {return (a->_id) < (b->_id); });
-    unsigned cpt_agent = 0;
-    for (Agent* agent : mech_active_agents)
-    {
-        for (unsigned cpt_shape(0); cpt_shape < agent->_nb_shapes; cpt_shape++)
-        {
-            active_shapeIDagent.push_back(cpt_agent);
-            active_shapeIDshape_crowd.push_back(agent->_ids_shapes[cpt_shape]);
+  /*  Preliminary definitions and initialisation  */
+  //  Sort mechanically active agents
+  mech_active_agents.sort(
+      [](auto const& a, auto const& b) { return (a->_id) < (b->_id); });
+  unsigned cpt_agent = 0;
+  for (Agent* agent : mech_active_agents) {
+    for (unsigned cpt_shape(0); cpt_shape < agent->_nb_shapes; cpt_shape++) {
+      active_shapeIDagent.push_back(cpt_agent);
+      active_shapeIDshape_crowd.push_back(agent->_ids_shapes[cpt_shape]);
+    }
+    agentIds[agent->_id] = cpt_agent;
+    agentActiveIds.push_back(agent->_id);
+    vector<double2> delta_gtos_agent = agent->get_delta_gtos();
+    delta.insert(delta.end(), (delta_gtos_agent).begin(),
+                 (delta_gtos_agent).end());
+    radius.insert(radius.end(), (agent->_radius_shapes).begin(),
+                  (agent->_radius_shapes).end());
+    size_agents[cpt_agent] = agent->_nb_shapes;
+    nb_active_shapes += agent->_nb_shapes;
+    rgn[cpt_agent] = double2(agent->_x, agent->_y);
+    thetn[cpt_agent] = agent->_theta;
+    vgn[cpt_agent] = double2(agent->_vx, agent->_vy);
+    wn[cpt_agent] = agent->_w;
+    masses[cpt_agent] = agent->_mass;
+    mois[cpt_agent] = agent->_moi;
+    damping[cpt_agent] = agentProperties[agent->_id];
+
+    rgnp1[cpt_agent] = double2(agent->_x, agent->_y);
+    thetnp1[cpt_agent] = agent->_theta;
+    vgnp1[cpt_agent] = double2(agent->_vx, agent->_vy);
+    wnp1[cpt_agent] = agent->_w;
+    const double inverseTauMechTranslation = agentProperties[agent->_id].first;
+    //  The "F" here have the dimension of an acceleration
+    Fp[cpt_agent] = inverseTauMechTranslation *
+                    agent->_v_des;  //  We recompute Fp from v_des...
+    Forthon[cpt_agent] = double2(0., 0.);
+    Ftn[cpt_agent] = double2(0., 0.);
+    taun[cpt_agent] = 0.;
+    wdesired[cpt_agent] = agent->_w_des;
+
+    cpt_agent++;
+  }
+
+  // Get the correspondence between agent and shapes  (ie the edges)
+  unsigned length(0);
+  for (size_t a = 0; a < nb_active_agents; ++a) {
+    length += size_agents[a];
+    agentIDshape[a + 1] = length;
+  }
+
+  // Get neighbouring shapes id of each agent
+  cpt_agent = 0;
+  for (const Agent* agent : mech_active_agents) {
+    unsigned cpt_agent2 = 0;
+    for (const Agent* agent2 : mech_active_agents) {
+      if (cpt_agent2 > cpt_agent) {
+        //	include as neighbour if within 5*(r1+r2) where r1 and r2 are the
+        //size of 	the body (the radius of the smallest circle containing all the
+        //shapes)
+        if (const double distance = !(rgn[cpt_agent] - rgn[cpt_agent2]);
+            distance < 5.0 * (agent->_radius + agent2->_radius)) {
+          for (unsigned cpt_shape(agentIDshape[cpt_agent2]);
+               cpt_shape < agentIDshape[cpt_agent2] + size_agents[cpt_agent2];
+               ++cpt_shape)
+            neighbours_shape[cpt_agent].push_back(cpt_shape);
+          for (unsigned cpt_shape(agentIDshape[cpt_agent]);
+               cpt_shape < agentIDshape[cpt_agent] + size_agents[cpt_agent];
+               ++cpt_shape)
+            neighbours_shape[cpt_agent2].push_back(cpt_shape);
         }
-        agentIds[agent->_id] = cpt_agent;
-        agentActiveIds.push_back(agent->_id);
-        vector<double2> delta_gtos_agent = agent->get_delta_gtos();
-        delta.insert(delta.end(), (delta_gtos_agent).begin(), (delta_gtos_agent).end());
-        radius.insert(radius.end(), (agent->_radius_shapes).begin(), (agent->_radius_shapes).end());
-        size_agents[cpt_agent] = agent->_nb_shapes;
-        nb_active_shapes += agent->_nb_shapes;
-        rgn[cpt_agent] = double2(agent->_x, agent->_y);
-        thetn[cpt_agent] = agent->_theta;
-        vgn[cpt_agent] = double2(agent->_vx, agent->_vy);
-        wn[cpt_agent] = agent->_w;
-        masses[cpt_agent] = agent->_mass;
-        mois[cpt_agent] = agent->_moi;
-        damping[cpt_agent] = agentProperties[agent->_id];
-
-        rgnp1[cpt_agent] = double2(agent->_x, agent->_y);
-        thetnp1[cpt_agent] = agent->_theta;
-        vgnp1[cpt_agent] = double2(agent->_vx, agent->_vy);
-        wnp1[cpt_agent] = agent->_w;
-        const double inverseTauMechTranslation   = agentProperties[agent->_id].first;
-        //  The "F" here have the dimension of an acceleration
-        Fp[cpt_agent] = inverseTauMechTranslation * agent->_v_des;  //  We recompute Fp from v_des...
-        Forthon[cpt_agent] = double2(0., 0.);
-        Ftn[cpt_agent] = double2(0., 0.);
-        taun[cpt_agent] = 0.;
-        wdesired[cpt_agent] = agent->_w_des;
-
-        cpt_agent++;
-    }
-
-    // Get the correspondence between agent and shapes  (ie the edges)
-    unsigned length(0);
-    for (size_t a = 0; a < nb_active_agents; ++a)
-    {
-        length += size_agents[a];
-        agentIDshape[a + 1] = length;
-    }
-
-    // Get neighbouring shapes id of each agent
-    cpt_agent = 0;
-    for (const Agent* agent : mech_active_agents)
-    {
-        unsigned cpt_agent2 = 0;
-        for (const Agent* agent2 : mech_active_agents)
-        {
-            if (cpt_agent2 > cpt_agent)
-            {
-                //	include as neighbour if within 5*(r1+r2) where r1 and r2 are the size of
-                //	the body (the radius of the smallest circle containing all the shapes)
-                if (const double distance = !(rgn[cpt_agent] - rgn[cpt_agent2]);
-                    distance < 5.0 * (agent->_radius + agent2->_radius))
-                {
-                    for (unsigned cpt_shape(agentIDshape[cpt_agent2]); cpt_shape < agentIDshape[cpt_agent2] + size_agents[cpt_agent2]; ++cpt_shape)
-                        neighbours_shape[cpt_agent].push_back(cpt_shape);
-                    for (unsigned cpt_shape(agentIDshape[cpt_agent]); cpt_shape < agentIDshape[cpt_agent] + size_agents[cpt_agent]; ++cpt_shape)
-                        neighbours_shape[cpt_agent2].push_back(cpt_shape);
-                }
-            }
-            cpt_agent2++;
-        }
-        cpt_agent++;
-    }
-
-    /*  Check if an Interactions File already exists    */
-    const string interactionsFile = pathDynamic + "AgentInteractions.xml";
-    struct stat buffer{};
-    if (stat(interactionsFile.c_str(), &buffer) != -1)
-        readInteractionsInputFile(interactionsFile);
-
-
-    /*  MECHANICAL Loop */
-    for (unsigned t = 0; t < static_cast<unsigned>(dt / dt_mech); t++)
-    {
-        loop();
-    }
-
-    // Update the positions and velocities of mechanically active agents
-    cpt_agent = 0;
-    for (Agent* agent : mech_active_agents)
-    {
-        agent->_x = rgn[cpt_agent].first;
-        agent->_y = rgn[cpt_agent].second;
-        agent->_vx = vgn[cpt_agent].first;
-        agent->_vy = vgn[cpt_agent].second;
-        agent->_theta = thetn[cpt_agent];
-        agent->_w = wn[cpt_agent];
-        cpt_agent++;
-    }
-
-    //  Output the interactions file
-    generateInteractionsOutputFile(interactionsFile, existsContacts());
+      }
+      cpt_agent2++;
+    }
+    cpt_agent++;
+  }
+
+  /*  Check if an Interactions File already exists    */
+  const string interactionsFile = pathDynamic + "AgentInteractions.xml";
+  struct stat buffer{};
+  if (stat(interactionsFile.c_str(), &buffer) != -1)
+    readInteractionsInputFile(interactionsFile);
+
+  /*  MECHANICAL Loop */
+  for (unsigned t = 0; t < static_cast<unsigned>(dt / dt_mech); t++) {
+    loop();
+  }
+
+  // Update the positions and velocities of mechanically active agents
+  cpt_agent = 0;
+  for (Agent* agent : mech_active_agents) {
+    agent->_x = rgn[cpt_agent].first;
+    agent->_y = rgn[cpt_agent].second;
+    agent->_vx = vgn[cpt_agent].first;
+    agent->_vy = vgn[cpt_agent].second;
+    agent->_theta = thetn[cpt_agent];
+    agent->_w = wn[cpt_agent];
+    cpt_agent++;
+  }
+
+  //  Output the interactions file
+  generateInteractionsOutputFile(interactionsFile, existsContacts());
 }
 
 /**
@@ -125,424 +144,506 @@

  *
  * This destructor transfers computed data to the agents.
  */
-MechanicalLayer::~MechanicalLayer()   // destructor transfers computed data to the agents
-= default;
+MechanicalLayer::~MechanicalLayer()  // destructor transfers computed data to
+                                     // the agents
+    = default;
 
 /**
- * @brief This functions read the interactions file to store the possible already existing contacts.
- * 			slip and slip_wall are the ones who get filled
+ * @brief This functions read the interactions file to store the possible
+ *already existing contacts. slip and slip_wall are the ones who get filled
  * @param interactionsFile the name of the file
  * return EXIT_FAILURE if any problem occurs with the XML file
  *		  EXIT_SUCCESS otherwise
  */
-int MechanicalLayer::readInteractionsInputFile(const std::string& interactionsFile)
-{
-    tinyxml2::XMLDocument document;
-    document.LoadFile(interactionsFile.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << interactionsFile << endl;
+int MechanicalLayer::readInteractionsInputFile(
+    const std::string& interactionsFile) {
+  tinyxml2::XMLDocument document;
+  document.LoadFile(interactionsFile.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << interactionsFile
+         << endl;
+    return EXIT_FAILURE;
+  }
+
+  //  Read the Interactions block
+  const tinyxml2::XMLElement* interactionsElement =
+      document.FirstChildElement("Interactions");
+  if (!interactionsElement) {
+    cerr << "Error: interactions must be embedded in \"Interactions\" tag!"
+         << endl;
+    return EXIT_FAILURE;
+  }
+
+  const tinyxml2::XMLElement* agent1Element =
+      interactionsElement->FirstChildElement("Agent");
+  if (!agent1Element) {
+    cerr << "Error: no Agent tag present in " << interactionsFile << endl;
+    return EXIT_FAILURE;
+  }
+  while (agent1Element) {
+    const char* agent1ExternId = nullptr;
+    if (agent1Element->QueryStringAttribute("Id", &agent1ExternId) !=
+        tinyxml2::XML_SUCCESS) {
+      cerr << "Error: Agents must have an Id in file " << interactionsFile
+           << endl;
+      return EXIT_FAILURE;
+    }
+    //  Interactions with other agents
+    const tinyxml2::XMLElement* agent2Element =
+        interactionsElement->FirstChildElement("Agent");
+    if (!agent2Element) {
+      cerr << "Error: no Agent neighbour present in " << interactionsFile
+           << endl;
+      return EXIT_FAILURE;
+    }
+    while (agent2Element) {
+      const char* agent2ExternId = nullptr;
+      if (agent2Element->QueryStringAttribute("Id", &agent2ExternId) !=
+          tinyxml2::XML_SUCCESS) {
+        cerr << "Error: Agents must have an Id in file " << interactionsFile
+             << endl;
         return EXIT_FAILURE;
-    }
-
-    //  Read the Interactions block
-    const tinyxml2::XMLElement* interactionsElement = document.FirstChildElement("Interactions");
-    if (!interactionsElement) {
-        cerr << "Error: interactions must be embedded in \"Interactions\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-
-    const tinyxml2::XMLElement* agent1Element = interactionsElement->FirstChildElement("Agent");
-    if (!agent1Element) {
-        cerr << "Error: no Agent tag present in " << interactionsFile << endl;
-        return EXIT_FAILURE;
-    }
-    while (agent1Element) {
-        const char* agent1ExternId = nullptr;
-        if (agent1Element->QueryStringAttribute("Id", &agent1ExternId) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: Agents must have an Id in file " << interactionsFile << endl;
-            return EXIT_FAILURE;
+      }
+      //  Read interactions
+      const tinyxml2::XMLElement* interactionElement =
+          agent2Element->FirstChildElement("Interaction");
+      while (interactionElement) {
+        const char* shape1ExternId = nullptr;
+        const char* shape2ExternId = nullptr;
+        if (interactionElement->QueryStringAttribute(
+                "ParentShape", &shape1ExternId) != tinyxml2::XML_SUCCESS) {
+          cerr << "Error: no shape identifier in interaction between agents in "
+               << interactionsFile << endl;
+          return EXIT_FAILURE;
         }
-        //  Interactions with other agents
-        const tinyxml2::XMLElement* agent2Element = interactionsElement->FirstChildElement("Agent");
-        if (!agent2Element) {
-            cerr << "Error: no Agent neighbour present in " << interactionsFile << endl;
-            return EXIT_FAILURE;
+        if (interactionElement->QueryStringAttribute(
+                "ChildShape", &shape2ExternId) != tinyxml2::XML_SUCCESS) {
+          cerr << "Error: no shape identifier in interaction between agents in "
+               << interactionsFile << endl;
+          return EXIT_FAILURE;
         }
-        while (agent2Element) {
-            const char* agent2ExternId = nullptr;
-            if (agent2Element->QueryStringAttribute("Id", &agent2ExternId) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: Agents must have an Id in file " << interactionsFile << endl;
-                return EXIT_FAILURE;
-            }
-            //  Read interactions
-            const tinyxml2::XMLElement* interactionElement = agent2Element->FirstChildElement("Interaction");
-            while (interactionElement) {
-                const char* shape1ExternId = nullptr;
-                const char* shape2ExternId = nullptr;
-                if (interactionElement->QueryStringAttribute("ParentShape", &shape1ExternId) != tinyxml2::XML_SUCCESS) {
-                    cerr << "Error: no shape identifier in interaction between agents in " << interactionsFile << endl;
-                    return EXIT_FAILURE;
-                }
-                if (interactionElement->QueryStringAttribute("ChildShape", &shape2ExternId) != tinyxml2::XML_SUCCESS) {
-                    cerr << "Error: no shape identifier in interaction between agents in " << interactionsFile << endl;
-                    return EXIT_FAILURE;
-                }
-                const char* buffer = nullptr;
-                interactionElement->QueryStringAttribute("TangentialRelativeDisplacement", &buffer);
-                auto [rcSlip, inputSlip] = parse2DComponents(buffer);
-                uint32_t cpt_shape          = shapeMap[{agent1ExternId, shape1ExternId}];
-                uint32_t cpt_shape_neigh    = shapeMap[{agent2ExternId, shape2ExternId}];
-                slip[{cpt_shape, cpt_shape_neigh}] = inputSlip;
-                slip[{cpt_shape_neigh, cpt_shape}] = -1 * inputSlip;
-            }
-
-            agent2Element = agent2Element->NextSiblingElement("Agent");
-        }
-        //  Interactions with walls
-        const tinyxml2::XMLElement* wallElement = agent1Element->FirstChildElement("Wall");
-        while (wallElement) {
-          	const char* shapeExternId = nullptr;
-            wallElement->QueryStringAttribute("ShapeId", &shapeExternId);
-            int obstacleId, wallId;
-            wallElement->QueryIntAttribute("ObstacleId", &obstacleId);
-            wallElement->QueryIntAttribute("WallId", &wallId);
-            const char* buffer = nullptr;
-            wallElement->QueryStringAttribute("TangentialRelativeDisplacement", &buffer);
-            auto [rcSlipWall, inputSlipWall] = parse2DComponents(buffer);
-            uint32_t cpt_shape = shapeMap[{agent1ExternId, shapeExternId}];
-            slip_wall[{cpt_shape, obstacleId, wallId}] = inputSlipWall;
-
-            wallElement = wallElement->NextSiblingElement("Wall");
-        }
-        agent1Element = agent1Element->NextSiblingElement("Agent");
-    }
-
-    return EXIT_SUCCESS;
+        const char* buffer = nullptr;
+        interactionElement->QueryStringAttribute(
+            "TangentialRelativeDisplacement", &buffer);
+        auto [rcSlip, inputSlip] = parse2DComponents(buffer);
+        uint32_t cpt_shape = shapeMap[{agent1ExternId, shape1ExternId}];
+        uint32_t cpt_shape_neigh = shapeMap[{agent2ExternId, shape2ExternId}];
+        slip[{cpt_shape, cpt_shape_neigh}] = inputSlip;
+        slip[{cpt_shape_neigh, cpt_shape}] = -1 * inputSlip;
+      }
+
+      agent2Element = agent2Element->NextSiblingElement("Agent");
+    }
+    //  Interactions with walls
+    const tinyxml2::XMLElement* wallElement =
+        agent1Element->FirstChildElement("Wall");
+    while (wallElement) {
+      const char* shapeExternId = nullptr;
+      wallElement->QueryStringAttribute("ShapeId", &shapeExternId);
+      int obstacleId, wallId;
+      wallElement->QueryIntAttribute("ObstacleId", &obstacleId);
+      wallElement->QueryIntAttribute("WallId", &wallId);
+      const char* buffer = nullptr;
+      wallElement->QueryStringAttribute("TangentialRelativeDisplacement",
+                                        &buffer);
+      auto [rcSlipWall, inputSlipWall] = parse2DComponents(buffer);
+      uint32_t cpt_shape = shapeMap[{agent1ExternId, shapeExternId}];
+      slip_wall[{cpt_shape, obstacleId, wallId}] = inputSlipWall;
+
+      wallElement = wallElement->NextSiblingElement("Wall");
+    }
+    agent1Element = agent1Element->NextSiblingElement("Agent");
+  }
+
+  return EXIT_SUCCESS;
 }
 
-
 /**
- * Calculates the interactions between the crowd mechanics and returns the resulting forces and torque.
+ * Calculates the interactions between the crowd mechanics and returns the
+ * resulting forces and torque.
  *
  * @param cpt_shape The index of the shape.
- * @param AtTimen Flag indicating whether to calculate the forces at time n or n+1.
+ * @param AtTimen Flag indicating whether to calculate the forces at time n or
+ * n+1.
  * @return A tuple containing the tangential force, normal force, and torque.
  */
-tuple<double2, double2, double> MechanicalLayer::get_interactions(unsigned cpt_shape, bool AtTimen)
-{   // return    tangential force     + normal / m     , moment / I    if AtTimen=true
-    // otherwise force tangentielle_np1 + normale_np1 / m
-    unsigned cpt_agent = active_shapeIDagent[cpt_shape];
-    double UnmZetadt    = 1.0 - dt_mech * damping[cpt_agent].first;
-    double2 delta_GtoS = AtTimen ? delta[cpt_shape] : delta[cpt_shape] + ((thetnp1[cpt_agent] - thetn[cpt_agent]) ^ delta[cpt_shape]);
-    double2 posagent = AtTimen ? rgn[cpt_agent] : rgnp1[cpt_agent];   // center of mass of the agent
-    double2 posshape = posagent + delta_GtoS;                         // center of mass of the shape
-    double angvel =
-        AtTimen ? wn[cpt_agent]
-                : wn[cpt_agent] + dt_mech * taun[cpt_agent];   // angular velocity of the shape at time n and trial angular velocity for the time n+1
-    double2 velagent =
-        AtTimen ? vgn[cpt_agent]
-                : UnmZetadt * vgn[cpt_agent] + dt_mech * (Fp[cpt_agent] + Forthon[cpt_agent] +
-                                                          Ftn[cpt_agent]);   // velocity of the shape   // v_shape(t+dt) = v_CM(t+dt) transport
-    double2 velshape = velagent + (angvel ^ delta_GtoS);
-
-    double torq = 0.;
-    double2 fortho(0., 0.);
-    double2 ft(0., 0.);
-
-    // Hertzian interactions between agents
-    for (unsigned cpt_shape_neigh : neighbours_shape[cpt_agent])
+tuple<double2, double2, double> MechanicalLayer::get_interactions(
+    unsigned cpt_shape,
+    bool AtTimen) {  // return    tangential force     + normal / m     , moment
+                     // / I    if AtTimen=true
+  // otherwise force tangentielle_np1 + normale_np1 / m
+  unsigned cpt_agent = active_shapeIDagent[cpt_shape];
+  double UnmZetadt = 1.0 - dt_mech * damping[cpt_agent].first;
+  double2 delta_GtoS =
+      AtTimen ? delta[cpt_shape]
+              : delta[cpt_shape] + ((thetnp1[cpt_agent] - thetn[cpt_agent]) ^
+                                    delta[cpt_shape]);
+  double2 posagent = AtTimen ? rgn[cpt_agent]
+                             : rgnp1[cpt_agent];  // center of mass of the agent
+  double2 posshape = posagent + delta_GtoS;       // center of mass of the shape
+  double angvel =
+      AtTimen ? wn[cpt_agent]
+              : wn[cpt_agent] +
+                    dt_mech * taun[cpt_agent];  // angular velocity of the shape
+                                                // at time n and trial angular
+                                                // velocity for the time n+1
+  double2 velagent =
+      AtTimen
+          ? vgn[cpt_agent]
+          : UnmZetadt * vgn[cpt_agent] +
+                dt_mech *
+                    (Fp[cpt_agent] + Forthon[cpt_agent] +
+                     Ftn[cpt_agent]);  // velocity of the shape   //
+                                       // v_shape(t+dt) = v_CM(t+dt) transport
+  double2 velshape = velagent + (angvel ^ delta_GtoS);
+
+  double torq = 0.;
+  double2 fortho(0., 0.);
+  double2 ft(0., 0.);
+
+  // Hertzian interactions between agents
+  for (unsigned cpt_shape_neigh : neighbours_shape[cpt_agent]) {
+    unsigned cpt_neigh = active_shapeIDagent[cpt_shape_neigh];
+    double2 delta_GtoS_neigh =
+        AtTimen ? delta[cpt_shape_neigh]
+                : delta[cpt_shape_neigh] +
+                      ((thetnp1[cpt_neigh] - thetn[cpt_neigh]) ^
+                       delta[cpt_shape_neigh]);
+    double2 posagent_neigh = AtTimen ? rgn[cpt_neigh] : rgnp1[cpt_neigh];
+    double2 posshape_neigh = posagent_neigh + delta_GtoS_neigh;
+    double angvel_neigh =
+        AtTimen ? wn[cpt_neigh] : wn[cpt_neigh] + dt_mech * taun[cpt_neigh];
+    double2 velagent_neigh =
+        AtTimen
+            ? vgn[cpt_neigh]
+            : UnmZetadt * vgn[cpt_neigh] +
+                  dt_mech * (Fp[cpt_neigh] + Forthon[cpt_neigh] +
+                             Ftn[cpt_neigh]);  // velocity of the CM of the
+                                               // neighbouring pedestrian neigh
+    double2 velshape_neigh = velagent_neigh + (angvel_neigh ^ delta_GtoS_neigh);
+
+    double2 r_ij =
+        posshape - posshape_neigh;  // points towards i // i : current_shape //
+                                    // j : neigh_shape
+    double distance(!r_ij);
+    double2 n_ij;
+    if (distance == 0.)
+      n_ij = double2(0., 0.);
+    else
+      n_ij = (1. / distance) * r_ij;
+    double h(radius[cpt_shape] + radius[cpt_shape_neigh] -
+             distance);  // indentation
+    double2 dcGshape = -(radius[cpt_shape] - h / 2.) *
+                       n_ij;  // from the center of mass G of shape towards c
+                              // (the contact point)
+    double2 dcGshapeneigh = +(radius[cpt_shape_neigh] - h / 2.) * n_ij;
+    double2 dcG =
+        delta[cpt_shape] + dcGshape;  // vector distance from CM of the agent to
+                                      // c = vector distance from CM agent to CM
+                                      // shape + distance from CM shape to c
+
+    if (h > 0.)  // if the two shapes are in contact
     {
-        unsigned cpt_neigh = active_shapeIDagent[cpt_shape_neigh];
-        double2 delta_GtoS_neigh =
-            AtTimen ? delta[cpt_shape_neigh] : delta[cpt_shape_neigh] + ((thetnp1[cpt_neigh] - thetn[cpt_neigh]) ^ delta[cpt_shape_neigh]);
-        double2 posagent_neigh = AtTimen ? rgn[cpt_neigh] : rgnp1[cpt_neigh];
-        double2 posshape_neigh = posagent_neigh + delta_GtoS_neigh;
-        double angvel_neigh = AtTimen ? wn[cpt_neigh] : wn[cpt_neigh] + dt_mech * taun[cpt_neigh];
-        double2 velagent_neigh =
-            AtTimen ? vgn[cpt_neigh]
-                    : UnmZetadt * vgn[cpt_neigh] + dt_mech * (Fp[cpt_neigh] + Forthon[cpt_neigh] +
-                                                              Ftn[cpt_neigh]);   // velocity of the CM of the neighbouring pedestrian neigh
-        double2 velshape_neigh = velagent_neigh + (angvel_neigh ^ delta_GtoS_neigh);
-
-        double2 r_ij = posshape - posshape_neigh;   // points towards i // i : current_shape // j : neigh_shape
-        double distance(!r_ij);
-        double2 n_ij;
-        if (distance == 0.)
-            n_ij = double2(0., 0.);
+      double2 v_ci =
+          velshape + (angvel ^ dcGshape);  // velocity of i at the contact point
+      double2 v_cj =
+          velshape_neigh +
+          (angvel_neigh ^ dcGshapeneigh);  // velocity of j at the contact point
+      double2 vij = v_ci - v_cj;
+      double2 vortho_ij = (vij % n_ij) * n_ij;
+      double2 vt_ij = vij - vortho_ij;
+      double norm_vt_ij = !vt_ij;
+
+      // if the map does not contain this pair ie the slip is not initialized
+      // then we initialize it otherwise we increment it
+      if (!slip.contains({cpt_shape, cpt_shape_neigh}))
+        slip[{cpt_shape, cpt_shape_neigh}] = double2(0., 0.);
+      else
+        slip[{cpt_shape, cpt_shape_neigh}] =
+            slip[{cpt_shape, cpt_shape_neigh}] + dt_mech * vt_ij;
+      //  We will only put the N(N-1)/2 pairs, ie cpt_shape_neigh>cpt_shape in
+      //  interactionsOutput
+      if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
+        interactionsOutput[{cpt_shape, cpt_shape_neigh}][SLIP] =
+            slip[{cpt_shape, cpt_shape_neigh}];
+
+      double2 delta_tij = slip[{
+          cpt_shape, cpt_shape_neigh}];  // vector of tangential displacement
+      double norm_delta_tij = !delta_tij;
+
+      double2 t_vij;
+      if (norm_vt_ij > 0)
+        t_vij = (1. / norm_vt_ij) * vt_ij;
+      else if (norm_delta_tij > 0)
+        t_vij = (1. / norm_delta_tij) * delta_tij;
+      else
+        t_vij = double2(0., 0.);
+
+      uint32_t shapeMaterialId =
+          shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
+      uint32_t shapeNeighbourMaterialId =
+          shapesMaterial[active_shapeIDshape_crowd[cpt_shape_neigh]];
+      /*  Normal interactions */
+      double k_n = binaryProperties[STIFFNESS_NORMAL][shapeMaterialId]
+                                   [shapeNeighbourMaterialId];
+      double Gamma_n = binaryProperties[DAMPING_NORMAL][shapeMaterialId]
+                                       [shapeNeighbourMaterialId];
+      double2 fnij_elastic = k_n * h * n_ij;
+      double2 fnij_viscous = -Gamma_n * vortho_ij;
+      double2 fnij = fnij_elastic + fnij_viscous;
+      fortho = fortho + fnij;
+      if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
+        interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_ORTHO] = fnij;
+
+      /*  Tangential interactions */
+      double k_t = binaryProperties[STIFFNESS_TANGENTIAL][shapeMaterialId]
+                                   [shapeNeighbourMaterialId];
+      double Gamma_t = binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId]
+                                       [shapeNeighbourMaterialId];
+      double2 ftij_spring = -k_t * norm_delta_tij * t_vij;
+      double2 ftij_viscous = -Gamma_t * vt_ij;
+      double2 ftij_static = ftij_spring + ftij_viscous;
+      double mu_dyn = binaryProperties[FRICTION_SLIDING][shapeMaterialId]
+                                      [shapeNeighbourMaterialId];
+      double2 ftij_dynamic = -mu_dyn * !fnij * t_vij;
+      double2 ftij = -1. * min(!ftij_static, !ftij_dynamic) * t_vij;
+      ft = ft + ftij;
+      if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
+        interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_TAN] = ftij;
+
+      /*	Torque	*/
+      double torqnij = (1. ^ dcG) % fnij;
+      double torqtij = (1. ^ dcG) % ftij;
+      double torqij = torqnij + torqtij;
+      torq =
+          torq + torqij;  // cf circular permutation of the cross product // two
+                          // forces induce rotation the orthogonal force and the
+                          // tangential force (to the contact surface)
+    }
+  }
+
+  // Interactions with walls
+  int iobs = 0;
+  for (vector<double2> const& wall_it :
+       listObstacles)  // iterates over obstacles
+  {
+    int iwall = 0;
+    for (auto it = wall_it.begin(); next(it) != wall_it.end(); ++it) {
+      auto [dist, closestPoint] =
+          get_distance_to_wall_and_closest_point(*it, *(next(it)), posshape);
+      // first => distance between the CM of the shape and the closest point on
+      // the wall , second => closest point on the wall
+
+      double2 r_iw = posshape - closestPoint;  // vector starting on the wall
+                                               // and going towards the shape
+      double distance = dist;
+      double2 n_iw;
+      if (distance == 0.)
+        n_iw = double2(0., 0.);
+      else
+        n_iw = (1. / distance) * r_iw;
+      double h = radius[cpt_shape] - distance;
+      double2 dcGshape = -(radius[cpt_shape] - h / 2.) * n_iw;
+      double2 dcG = delta[cpt_shape] +
+                    dcGshape;  // distance from the CM G to the contact point c
+      if (h > 0.) {
+        double2 v_ci = velshape + (angvel ^ dcGshape);
+        double2 viw = v_ci - double2(0., 0.);  // because v_cw = double2(0.,0.)
+        double2 vortho_iw = (viw % n_iw) * n_iw;
+        double2 vt_iw = viw - vortho_iw;
+        double norm_vt_iw = !vt_iw;
+
+        // if the map does not contain this pair ie the slip is not initialized
+        // then we initialize it otherwise we increment it
+        if (!slip_wall.contains({cpt_shape, iobs, iwall}))
+          slip_wall[{cpt_shape, iobs, iwall}] = double2(0., 0.);
         else
-            n_ij = (1. / distance) * r_ij;
-        double h(radius[cpt_shape] + radius[cpt_shape_neigh] - distance);   // indentation
-        double2 dcGshape = -(radius[cpt_shape] - h / 2.) * n_ij;            // from the center of mass G of shape towards c (the contact point)
-        double2 dcGshapeneigh = +(radius[cpt_shape_neigh] - h / 2.) * n_ij;
-        double2 dcG = delta[cpt_shape] + dcGshape;   // vector distance from CM of the agent to c = vector distance from CM agent
-                                                     // to CM shape + distance from CM shape to c
-
-        if (h > 0.)   // if the two shapes are in contact
-        {
-            double2 v_ci = velshape + (angvel ^ dcGshape);                    // velocity of i at the contact point
-            double2 v_cj = velshape_neigh + (angvel_neigh ^ dcGshapeneigh);   // velocity of j at the contact point
-            double2 vij = v_ci - v_cj;
-            double2 vortho_ij = (vij % n_ij) * n_ij;
-            double2 vt_ij = vij - vortho_ij;
-            double norm_vt_ij = !vt_ij;
-
-            // if the map does not contain this pair ie the slip is not initialized then we initialize it otherwise we increment it
-            if (!slip.contains({cpt_shape, cpt_shape_neigh}))
-                slip[{cpt_shape, cpt_shape_neigh}] = double2(0., 0.);
-            else
-                slip[{cpt_shape, cpt_shape_neigh}] = slip[{cpt_shape, cpt_shape_neigh}] + dt_mech * vt_ij;
-            //  We will only put the N(N-1)/2 pairs, ie cpt_shape_neigh>cpt_shape in interactionsOutput
-            if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
-                interactionsOutput[{cpt_shape, cpt_shape_neigh}][SLIP]
-                    = slip[{cpt_shape, cpt_shape_neigh}];
-
-            double2 delta_tij = slip[{cpt_shape, cpt_shape_neigh}];   // vector of tangential displacement
-            double norm_delta_tij = !delta_tij;
-
-            double2 t_vij;
-            if (norm_vt_ij > 0)
-                t_vij = (1. / norm_vt_ij) * vt_ij;
-            else if (norm_delta_tij > 0)
-                t_vij = (1. / norm_delta_tij) * delta_tij;
-            else
-                t_vij = double2(0., 0.);
-
-            uint32_t shapeMaterialId 			= shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
-            uint32_t shapeNeighbourMaterialId 	= shapesMaterial[active_shapeIDshape_crowd[cpt_shape_neigh]];
-            /*  Normal interactions */
-            double k_n 		= binaryProperties[STIFFNESS_NORMAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double Gamma_n 	= binaryProperties[DAMPING_NORMAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double2 fnij_elastic = k_n * h * n_ij;
-            double2 fnij_viscous = -Gamma_n * vortho_ij;
-            double2 fnij = fnij_elastic + fnij_viscous;
-            fortho = fortho + fnij;
-            if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
-                interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_ORTHO] = fnij;
-
-            /*  Tangential interactions */
-            double k_t 		= binaryProperties[STIFFNESS_TANGENTIAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double Gamma_t 	= binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double2 ftij_spring  = -k_t * norm_delta_tij * t_vij;
-            double2 ftij_viscous = -Gamma_t * vt_ij;
-            double2 ftij_static  = ftij_spring + ftij_viscous;
-            double mu_dyn = binaryProperties[FRICTION_SLIDING][shapeMaterialId][shapeNeighbourMaterialId];
-            double2 ftij_dynamic = -mu_dyn * !fnij * t_vij;
-            double2 ftij = -1. * min(!ftij_static, !ftij_dynamic) * t_vij;
-            ft = ft + ftij;
-            if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
-                interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_TAN] = ftij;
-
-            /*	Torque	*/
-            double torqnij = (1. ^ dcG) % fnij;
-            double torqtij = (1. ^ dcG) % ftij;
-            double torqij = torqnij + torqtij;
-            torq = torq + torqij;   // cf circular permutation of the cross product // two forces induce rotation the orthogonal
-                                    // force and the tangential force (to the contact surface)
-
-        }
-    }
-
-    // Interactions with walls
-    int iobs = 0;
-    for (vector<double2> const& wall_it : listObstacles)   // iterates over obstacles
-    {
-        int iwall = 0;
-        for (auto it = wall_it.begin(); next(it) != wall_it.end(); ++it)
-        {
-            auto [dist, closestPoint] = get_distance_to_wall_and_closest_point(*it, *(next(it)), posshape);
-            // first => distance between the CM of the shape and the closest point on the wall , second => closest point on the
-            // wall
-
-            double2 r_iw = posshape - closestPoint;   // vector starting on the wall and going towards the shape
-            double distance = dist;
-            double2 n_iw;
-            if (distance == 0.)
-                n_iw = double2(0., 0.);
-            else
-                n_iw = (1. / distance) * r_iw;
-            double h = radius[cpt_shape] - distance;
-            double2 dcGshape = -(radius[cpt_shape] - h / 2.) * n_iw;
-            double2 dcG = delta[cpt_shape] + dcGshape;   // distance from the CM G to the contact point c
-            if (h > 0.)
-            {
-                double2 v_ci = velshape + (angvel ^ dcGshape);
-                double2 viw = v_ci - double2(0., 0.);   // because v_cw = double2(0.,0.)
-                double2 vortho_iw = (viw % n_iw) * n_iw;
-                double2 vt_iw = viw - vortho_iw;
-                double norm_vt_iw = !vt_iw;
-
-                // if the map does not contain this pair ie the slip is not initialized then we initialize it otherwise we
-                // increment it
-                if (!slip_wall.contains({cpt_shape, iobs, iwall}))
-                    slip_wall[{cpt_shape, iobs, iwall}] = double2(0., 0.);
-                else
-                    slip_wall[{cpt_shape, iobs, iwall}] = slip_wall[{cpt_shape, iobs, iwall}] + dt_mech * vt_iw;
-                interactionsOutputWall[{cpt_shape, iobs, iwall}][SLIP]
-                    = slip_wall[{cpt_shape, iobs, iwall}];
-
-                double2 delta_tiw = slip_wall[{cpt_shape, iobs, iwall}];
-                double norm_delta_tiw = !delta_tiw;
-
-                double2 t_viw;
-                if (norm_vt_iw > 0)
-                    t_viw = (1. / norm_vt_iw) * vt_iw;
-                else if (norm_delta_tiw > 0)
-                    t_viw = (1. / norm_delta_tiw) * delta_tiw;
-                else
-                    t_viw = double2(0., 0.);
-
-                uint32_t shapeMaterialId    = shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
-                uint32_t obstacleMaterialId = obstaclesMaterial[iobs];
-                /*  Normal interactions */
-                double k_n_wall 	= binaryProperties[STIFFNESS_NORMAL][shapeMaterialId][obstacleMaterialId];
-                double Gamma_n_wall = binaryProperties[DAMPING_NORMAL][shapeMaterialId][obstacleMaterialId];
-                double2 fniw_elastic = k_n_wall * h * n_iw;
-                double2 fniw_viscous = -Gamma_n_wall * vortho_iw;
-                double2 fniw = fniw_elastic + fniw_viscous;
-                fortho = fortho + fniw;
-                interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_ORTHO] = fniw;
-
-                /*  Tangential interactions */
-                double k_t_wall 	= binaryProperties[STIFFNESS_TANGENTIAL][shapeMaterialId][obstacleMaterialId];
-                double Gamma_t_wall = binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId][obstacleMaterialId];
-                double2 ftiw_spring = -k_t_wall * norm_delta_tiw * t_viw;
-                double2 ftiw_viscous = -Gamma_t_wall * vt_iw;
-                double2 ftiw_static = ftiw_spring + ftiw_viscous;
-                double mu_dyn_wall = binaryProperties[FRICTION_SLIDING][shapeMaterialId][obstacleMaterialId];
-                double2 ftiw_dynamic = -mu_dyn_wall * !fniw * t_viw;
-                double2 ftiw = -1. * min(!ftiw_static, !ftiw_dynamic) * t_viw;
-                ft = ft + ftiw;
-                interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_TAN] = ftiw;
-
-                /*	Torque	*/
-                double torqniw = (1. ^ dcG) % fniw;
-                double torqtiw = (1. ^ dcG) % ftiw;
-                double torqiw = torqniw + torqtiw;
-                torq = torq + torqiw;
-
-            }
-            iwall++;
-        }
-        iobs++;
-    }
-    return {fortho, ft, torq};
+          slip_wall[{cpt_shape, iobs, iwall}] =
+              slip_wall[{cpt_shape, iobs, iwall}] + dt_mech * vt_iw;
+        interactionsOutputWall[{cpt_shape, iobs, iwall}][SLIP] =
+            slip_wall[{cpt_shape, iobs, iwall}];
+
+        double2 delta_tiw = slip_wall[{cpt_shape, iobs, iwall}];
+        double norm_delta_tiw = !delta_tiw;
+
+        double2 t_viw;
+        if (norm_vt_iw > 0)
+          t_viw = (1. / norm_vt_iw) * vt_iw;
+        else if (norm_delta_tiw > 0)
+          t_viw = (1. / norm_delta_tiw) * delta_tiw;
+        else
+          t_viw = double2(0., 0.);
+
+        uint32_t shapeMaterialId =
+            shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
+        uint32_t obstacleMaterialId = obstaclesMaterial[iobs];
+        /*  Normal interactions */
+        double k_n_wall = binaryProperties[STIFFNESS_NORMAL][shapeMaterialId]
+                                          [obstacleMaterialId];
+        double Gamma_n_wall = binaryProperties[DAMPING_NORMAL][shapeMaterialId]
+                                              [obstacleMaterialId];
+        double2 fniw_elastic = k_n_wall * h * n_iw;
+        double2 fniw_viscous = -Gamma_n_wall * vortho_iw;
+        double2 fniw = fniw_elastic + fniw_viscous;
+        fortho = fortho + fniw;
+        interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_ORTHO] = fniw;
+
+        /*  Tangential interactions */
+        double k_t_wall = binaryProperties[STIFFNESS_TANGENTIAL]
+                                          [shapeMaterialId][obstacleMaterialId];
+        double Gamma_t_wall =
+            binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId]
+                            [obstacleMaterialId];
+        double2 ftiw_spring = -k_t_wall * norm_delta_tiw * t_viw;
+        double2 ftiw_viscous = -Gamma_t_wall * vt_iw;
+        double2 ftiw_static = ftiw_spring + ftiw_viscous;
+        double mu_dyn_wall = binaryProperties[FRICTION_SLIDING][shapeMaterialId]
+                                             [obstacleMaterialId];
+        double2 ftiw_dynamic = -mu_dyn_wall * !fniw * t_viw;
+        double2 ftiw = -1. * min(!ftiw_static, !ftiw_dynamic) * t_viw;
+        ft = ft + ftiw;
+        interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_TAN] = ftiw;
+
+        /*	Torque	*/
+        double torqniw = (1. ^ dcG) % fniw;
+        double torqtiw = (1. ^ dcG) % ftiw;
+        double torqiw = torqniw + torqtiw;
+        torq = torq + torqiw;
+      }
+      iwall++;
+    }
+    iobs++;
+  }
+  return {fortho, ft, torq};
 }
 
 /**
  * @brief Executes the main loop of the CrowdMech class.
  *
- * This function updates the forces, positions, velocities, orientations, and angular velocities of the agents in the crowd
- * simulation. It iterates over the active shapes to calculate the forces and momentum at time n, and updates the corresponding
- * agent variables. Then, it iterates over the active agents to update their positions using the velocity Verlet algorithm. Next,
- * it calculates the forces and momentum at time N+1 for each shape, and updates the corresponding agent variables. Finally, it
- * updates the velocities of the agents and their angular velocities, and updates the relative positions of the shapes.
+ * This function updates the forces, positions, velocities, orientations, and
+ * angular velocities of the agents in the crowd simulation. It iterates over
+ * the active shapes to calculate the forces and momentum at time n, and updates
+ * the corresponding agent variables. Then, it iterates over the active agents
+ * to update their positions using the velocity Verlet algorithm. Next, it
+ * calculates the forces and momentum at time N+1 for each shape, and updates
+ * the corresponding agent variables. Finally, it updates the velocities of the
+ * agents and their angular velocities, and updates the relative positions of
+ * the shapes.
  *
  */
-void MechanicalLayer::loop()
-{
-    // Reset the forces and torques
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
+void MechanicalLayer::loop() {
+  // Reset the forces and torques
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++) {
+    Forthon[cpt_agent] = double2(0., 0.);
+    Ftn[cpt_agent] = double2(0., 0.);
+    taun[cpt_agent] = 0.;
+  }
+
+  // Loop over shapes for forces and momentum
+  for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes;
+       cpt_shape++) {  // FORCE AT TIME n
+    auto Motion = get_interactions(cpt_shape, true);
+    const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
+    Forthon[cpt_agent] = Forthon[cpt_agent] +
+                         (1. / masses[cpt_agent]) *
+                             get<0>(Motion);  // resultant of normal forces
+                                              // (applied on the contact point)
+    Ftn[cpt_agent] =
+        Ftn[cpt_agent] + (1.0 / masses[cpt_agent]) *
+                             get<1>(Motion);  // resultant of tangential forces
+                                              // (applied on the contact point)
+    taun[cpt_agent] =
+        taun[cpt_agent] + (1.0 / mois[cpt_agent]) * get<2>(Motion);  // torque
+  }
+
+  // Loop over agents for positions
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++) {
+    double UnmZetadt2 = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
+    taun[cpt_agent] = taun[cpt_agent] + (wdesired[cpt_agent] - wn[cpt_agent]) *
+                                            damping[cpt_agent].second;
+    // update positions with velocity Verlet algorithm
+    rgnp1[cpt_agent] =
+        rgn[cpt_agent] + UnmZetadt2 * dt_mech * vgn[cpt_agent] +
+        0.5 * dt_mech * dt_mech *
+            (Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent]);
+    thetnp1[cpt_agent] = thetn[cpt_agent] + dt_mech * wn[cpt_agent] +
+                         0.5 * dt_mech * dt_mech * taun[cpt_agent];
+  }
+
+  // Loop over shapes for velocities
+  vector<double2> forthonp1(nb_active_agents, double2(0, 0));
+  vector<double2> ftnp1(nb_active_agents, double2(0, 0));
+  vector<double> taunp1(nb_active_agents, 0.);
+
+  for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes;
+       cpt_shape++) {  // FORCE AT TIME N+1
+    auto Motion = get_interactions(cpt_shape, false);
+    const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
+    forthonp1[cpt_agent] = forthonp1[cpt_agent] + get<0>(Motion);
+    ftnp1[cpt_agent] = ftnp1[cpt_agent] + get<1>(Motion);
+    taunp1[cpt_agent] = taunp1[cpt_agent] + get<2>(Motion);
+  }
+
+  // Loop over agents for velocities
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++) {
+    double UnmZetadt2 = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
+    double UnpZetadt2 = 1.0 + 0.5 * dt_mech * damping[cpt_agent].first;
+    taunp1[cpt_agent] =
+        taunp1[cpt_agent] +
+        (wdesired[cpt_agent] - wnp1[cpt_agent]) * damping[cpt_agent].second;
+    // update velocities
+    vgnp1[cpt_agent] =
+        1.0 / UnpZetadt2 *
+        (UnmZetadt2 * vgn[cpt_agent] +
+         0.5 * dt_mech *
+             (2. * Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent] +
+              forthonp1[cpt_agent] + ftnp1[cpt_agent]));
+    wnp1[cpt_agent] =
+        wn[cpt_agent] + 0.5 * dt_mech * (taun[cpt_agent] + taunp1[cpt_agent]);
+  }
+
+  // Update relative positions of the shapes
+  for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++) {
+    const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
+    const double delta_theta = thetnp1[cpt_agent] - thetn[cpt_agent];
+    delta[cpt_shape].first = delta[cpt_shape].first * cos(delta_theta) -
+                             delta[cpt_shape].second * sin(delta_theta);
+    delta[cpt_shape].second = delta[cpt_shape].first * sin(delta_theta) +
+                              delta[cpt_shape].second * cos(delta_theta);
+    // rotation of the delta by an angle delta_theta (the norm is conserved)
+  }
+
+  // update position, velocity, orientation, angular velocity of each agent
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++) {
     {
-        Forthon[cpt_agent] = double2(0., 0.);
-        Ftn[cpt_agent] = double2(0., 0.);
-        taun[cpt_agent] = 0.;
-    }
-
-    // Loop over shapes for forces and momentum
-    for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
-    {   // FORCE AT TIME n
-        auto Motion = get_interactions(cpt_shape, true);
-        const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
-        Forthon[cpt_agent] =
-            Forthon[cpt_agent] + (1. / masses[cpt_agent]) * get<0>(Motion);   // resultant of normal forces (applied on the contact point)
-        Ftn[cpt_agent] =
-            Ftn[cpt_agent] + (1.0 / masses[cpt_agent]) * get<1>(Motion);   // resultant of tangential forces (applied on the contact point)
-        taun[cpt_agent] = taun[cpt_agent] + (1.0 / mois[cpt_agent]) * get<2>(Motion);   // torque
-    }
-
-    // Loop over agents for positions
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
-    {
-        double UnmZetadt2   = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
-        taun[cpt_agent] = taun[cpt_agent] + (wdesired[cpt_agent] - wn[cpt_agent]) * damping[cpt_agent].second;
-        // update positions with velocity Verlet algorithm
-        rgnp1[cpt_agent] =
-            rgn[cpt_agent] + UnmZetadt2 * dt_mech * vgn[cpt_agent] + 0.5 * dt_mech * dt_mech * (Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent]);
-        thetnp1[cpt_agent] = thetn[cpt_agent] + dt_mech * wn[cpt_agent] + 0.5 * dt_mech * dt_mech * taun[cpt_agent];
-    }
-
-    // Loop over shapes for velocities
-    vector<double2> forthonp1(nb_active_agents, double2(0, 0));
-    vector<double2> ftnp1(nb_active_agents, double2(0, 0));
-    vector<double> taunp1(nb_active_agents, 0.);
-
-    for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
-    {   // FORCE AT TIME N+1
-        auto Motion = get_interactions(cpt_shape, false);
-        const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
-        forthonp1[cpt_agent] = forthonp1[cpt_agent] + get<0>(Motion);
-        ftnp1[cpt_agent] = ftnp1[cpt_agent] + get<1>(Motion);
-        taunp1[cpt_agent] = taunp1[cpt_agent] + get<2>(Motion);
-    }
-
-    // Loop over agents for velocities
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
-    {
-        double UnmZetadt2   = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
-        double UnpZetadt2   = 1.0 + 0.5 * dt_mech * damping[cpt_agent].first;
-        taunp1[cpt_agent] = taunp1[cpt_agent] + (wdesired[cpt_agent] - wnp1[cpt_agent]) * damping[cpt_agent].second;
-        // update velocities
-        vgnp1[cpt_agent] = 1.0 / UnpZetadt2 *
-                           (UnmZetadt2 * vgn[cpt_agent] +
-                            0.5 * dt_mech * (2. * Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent] + forthonp1[cpt_agent] + ftnp1[cpt_agent]));
-        wnp1[cpt_agent] = wn[cpt_agent] + 0.5 * dt_mech * (taun[cpt_agent] + taunp1[cpt_agent]);
-    }
-
-    // Update relative positions of the shapes
-    for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
-    {
-        const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
-        const double delta_theta = thetnp1[cpt_agent] - thetn[cpt_agent];
-        delta[cpt_shape].first = delta[cpt_shape].first * cos(delta_theta) - delta[cpt_shape].second * sin(delta_theta);
-        delta[cpt_shape].second = delta[cpt_shape].first * sin(delta_theta) + delta[cpt_shape].second * cos(delta_theta);
-        // rotation of the delta by an angle delta_theta (the norm is conserved)
-    }
-
-    // update position, velocity, orientation, angular velocity of each agent
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
-    {
-        {
-            rgn[cpt_agent] = rgnp1[cpt_agent];
-            vgn[cpt_agent] = vgnp1[cpt_agent];
-            thetn[cpt_agent] = thetnp1[cpt_agent];
-            wn[cpt_agent] = wnp1[cpt_agent];
-        }
-    }
+      rgn[cpt_agent] = rgnp1[cpt_agent];
+      vgn[cpt_agent] = vgnp1[cpt_agent];
+      thetn[cpt_agent] = thetnp1[cpt_agent];
+      wn[cpt_agent] = wnp1[cpt_agent];
+    }
+  }
 }
 /**
  * @brief For output: do contacts exist?
  * @return true if so (with agents/with walls
  */
 pair<bool, bool> MechanicalLayer::existsContacts() {
-
-    bool agentContact = false;
-    bool wallContact  = false;
-
-    for (auto const& [key, value] : slip)
-    {
-        if (value != double2(0., 0.)) {
-            agentContact = true;
-            break;
-        }
-    }
-    for (auto const& [key, value] : slip_wall)
-    {
-        if (value != double2(0., 0.)) {
-            wallContact = true;
-            break;
-        }
-    }
-    return {agentContact, wallContact};
+  bool agentContact = false;
+  bool wallContact = false;
+
+  for (auto const& [key, value] : slip) {
+    if (value != double2(0., 0.)) {
+      agentContact = true;
+      break;
+    }
+  }
+  for (auto const& [key, value] : slip_wall) {
+    if (value != double2(0., 0.)) {
+      wallContact = true;
+      break;
+    }
+  }
+  return {agentContact, wallContact};
 }
 
 /**
@@ -550,108 +651,122 @@

  *
  * @param interactionsFile The name of the file to be written.
  * @param mech_active_agents The list of mechanically active agents
- * @param exists A boolean saying if there exists agent-agent or agent-wall contacts
+ * @param exists A boolean saying if there exists agent-agent or agent-wall
+ * contacts
  *
  */
-void MechanicalLayer::generateInteractionsOutputFile(const string& interactionsFile, const pair<bool, bool> &exists)
-{
-    ofstream outputDoc;
-    outputDoc.open(interactionsFile);
-
-    outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
-    outputDoc << "<Interactions>" << endl;
-    if (!exists.first && !exists.second) {
-      	outputDoc << "</Interactions>";
-        return;
-    }
-
-    /*  Loop over active agents */
-    set<unsigned> parent;                       //  Variable to remember if we have opening tags for parents
-    set<pair<unsigned, unsigned>> parentChild;  //  Variable to remember if we have an opening child tag
-    for (uint32_t a = 0; a < nb_active_agents; a++) {
-        //  First, collisions with agents
-        if (exists.first && !interactionsOutput.empty()) {
-            for (auto iterator = interactionsOutput.begin(); iterator != interactionsOutput.end(); ) {
-                auto shape = iterator->first.first;
-                const uint32_t agent = active_shapeIDagent[shape];
-                if (agent > a)
-                    break;
-                //  If we're here, agent = a
-                auto output = iterator->second;
-                if (output[SLIP]        == double2(0., 0.)
-                 && output[FORCE_ORTHO] == double2(0., 0.)
-                 && output[FORCE_TAN]   == double2(0., 0.))
-                    continue;
-                if (!parent.contains(a)) {
-                    if (!parent.empty())
-                        outputDoc << "    </Agent>" << endl;
-                    outputDoc << "    <Agent Id=\"" << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
-                    parent.insert(a);
-                }
-                auto shapeNeighbour = iterator->first.second;
-                const uint32_t neighbour = active_shapeIDagent[shapeNeighbour];
-                if (!parentChild.contains({agent, neighbour})) {
-                    if (!parentChild.empty() && parentChild.rbegin()->first == agent)
-                        //  We have switched to another child within the same agent -> insert child closing tag
-                            outputDoc << "        </Agent>" << endl;
-                    outputDoc << "        <Agent Id=\"" << agentMapInverse[agentActiveIds[neighbour]] << "\">" << endl;
-                    parentChild.insert({agent, neighbour});
-                }
-                outputDoc << "            <Interaction ParentShape=\"" << shapeMapInverse[shape] << "\" "
-                          << "ChildShape=\"" << shapeMapInverse[shapeNeighbour] << "\" ";
-                if (output[SLIP] != double2(0., 0.))
-                    outputDoc << "TangentialRelativeDisplacement=\""
-                              << output[SLIP].first << "," << output[SLIP].second << "\" ";
-                if (output[FORCE_ORTHO] != double2(0., 0.))
-                    outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << "," << output[FORCE_ORTHO].second << "\" ";
-                if (output[FORCE_TAN] != double2(0., 0.))
-                    outputDoc << "Ft=\"" << output[FORCE_TAN].first << "," << output[FORCE_TAN].second << "\" ";
-                outputDoc << "/>" << endl;
-                interactionsOutput.erase(iterator++);
-            }
-            if (!parentChild.empty() && parentChild.rbegin()->first == a)
-                //  If there were entries for the current agent, we need to close the last Agent child
-                    outputDoc << "        </Agent>" << endl;
+void MechanicalLayer::generateInteractionsOutputFile(
+    const string& interactionsFile, const pair<bool, bool>& exists) {
+  ofstream outputDoc;
+  outputDoc.open(interactionsFile);
+
+  outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
+  outputDoc << "<Interactions>" << endl;
+  if (!exists.first && !exists.second) {
+    outputDoc << "</Interactions>";
+    return;
+  }
+
+  /*  Loop over active agents */
+  set<unsigned>
+      parent;  //  Variable to remember if we have opening tags for parents
+  set<pair<unsigned, unsigned>>
+      parentChild;  //  Variable to remember if we have an opening child tag
+  for (uint32_t a = 0; a < nb_active_agents; a++) {
+    //  First, collisions with agents
+    if (exists.first && !interactionsOutput.empty()) {
+      for (auto iterator = interactionsOutput.begin();
+           iterator != interactionsOutput.end();) {
+        auto shape = iterator->first.first;
+        const uint32_t agent = active_shapeIDagent[shape];
+        if (agent > a) break;
+        //  If we're here, agent = a
+        auto output = iterator->second;
+        if (output[SLIP] == double2(0., 0.) &&
+            output[FORCE_ORTHO] == double2(0., 0.) &&
+            output[FORCE_TAN] == double2(0., 0.))
+          continue;
+        if (!parent.contains(a)) {
+          if (!parent.empty()) outputDoc << "    </Agent>" << endl;
+          outputDoc << "    <Agent Id=\""
+                    << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
+          parent.insert(a);
         }
-        //  Second, collision with walls
-        if (exists.second && !interactionsOutputWall.empty()) {
-            for (auto iterator = interactionsOutputWall.begin(); iterator != interactionsOutputWall.end(); ) {
-                auto key = iterator->first;
-                const uint32_t shape          = get<0>(key);
-                const uint32_t agent = active_shapeIDagent[shape];
-                //  If the current element of interactionsOutputWall is not the same as the last parent, end
-                if (agent > a)
-                    break;
-                auto output = iterator->second;
-                if (output[0] == double2(0., 0.) &&
-                    output[1] == double2(0., 0.) &&
-                    output[2] == double2(0., 0.))
-                    continue;
-                if (!parent.contains(a)) {
-                    if (!parent.empty())
-                        outputDoc << "    </Agent>" << endl;
-                    outputDoc << "    <Agent Id=\"" << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
-                    parent.insert(a);
-                }
-                outputDoc << "        <Wall ShapeId=\"" << shapeMapInverse[shape] << "\" "
-                    << "WallId=\"" << get<1>(key) << "\" CornerId=\"" << get<2>(key) << "\" ";
-                if (output[SLIP] != double2(0., 0.))
-                    outputDoc << "TangentialRelativeDisplacement=\"" << output[SLIP].first << ","
-                              << output[SLIP].second << "\" ";
-                if (output[FORCE_TAN] != double2(0., 0.))
-                    outputDoc << "Ft=\"" << output[FORCE_TAN].first << ","
-                              << output[FORCE_TAN].second << "\" ";
-                if (output[FORCE_ORTHO] != double2(0., 0.))
-                    outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << ","
-                              << output[FORCE_ORTHO].second << "\" ";
-                outputDoc << "/>" << endl;
-                //  Erase the entry in slip_wall to make the next sequential search "easier"
-                interactionsOutputWall.erase(iterator++);
-            }
+        auto shapeNeighbour = iterator->first.second;
+        const uint32_t neighbour = active_shapeIDagent[shapeNeighbour];
+        if (!parentChild.contains({agent, neighbour})) {
+          if (!parentChild.empty() && parentChild.rbegin()->first == agent)
+            //  We have switched to another child within the same agent ->
+            //  insert child closing tag
+            outputDoc << "        </Agent>" << endl;
+          outputDoc << "        <Agent Id=\""
+                    << agentMapInverse[agentActiveIds[neighbour]] << "\">"
+                    << endl;
+          parentChild.insert({agent, neighbour});
         }
-    }
-    outputDoc << "    </Agent>" << endl;
-    outputDoc << "</Interactions>";
-
-    outputDoc.close();
+        outputDoc << "            <Interaction ParentShape=\""
+                  << shapeMapInverse[shape] << "\" "
+                  << "ChildShape=\"" << shapeMapInverse[shapeNeighbour]
+                  << "\" ";
+        if (output[SLIP] != double2(0., 0.))
+          outputDoc << "TangentialRelativeDisplacement=\"" << output[SLIP].first
+                    << "," << output[SLIP].second << "\" ";
+        if (output[FORCE_ORTHO] != double2(0., 0.))
+          outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << ","
+                    << output[FORCE_ORTHO].second << "\" ";
+        if (output[FORCE_TAN] != double2(0., 0.))
+          outputDoc << "Ft=\"" << output[FORCE_TAN].first << ","
+                    << output[FORCE_TAN].second << "\" ";
+        outputDoc << "/>" << endl;
+        interactionsOutput.erase(iterator++);
+      }
+      if (!parentChild.empty() && parentChild.rbegin()->first == a)
+        //  If there were entries for the current agent, we need to close the
+        //  last Agent child
+        outputDoc << "        </Agent>" << endl;
+    }
+    //  Second, collision with walls
+    if (exists.second && !interactionsOutputWall.empty()) {
+      for (auto iterator = interactionsOutputWall.begin();
+           iterator != interactionsOutputWall.end();) {
+        auto key = iterator->first;
+        const uint32_t shape = get<0>(key);
+        const uint32_t agent = active_shapeIDagent[shape];
+        //  If the current element of interactionsOutputWall is not the same as
+        //  the last parent, end
+        if (agent > a) break;
+        auto output = iterator->second;
+        if (output[0] == double2(0., 0.) && output[1] == double2(0., 0.) &&
+            output[2] == double2(0., 0.))
+          continue;
+        if (!parent.contains(a)) {
+          if (!parent.empty()) outputDoc << "    </Agent>" << endl;
+          outputDoc << "    <Agent Id=\""
+                    << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
+          parent.insert(a);
+        }
+        outputDoc << "        <Wall ShapeId=\"" << shapeMapInverse[shape]
+                  << "\" "
+                  << "WallId=\"" << get<1>(key) << "\" CornerId=\""
+                  << get<2>(key) << "\" ";
+        if (output[SLIP] != double2(0., 0.))
+          outputDoc << "TangentialRelativeDisplacement=\"" << output[SLIP].first
+                    << "," << output[SLIP].second << "\" ";
+        if (output[FORCE_TAN] != double2(0., 0.))
+          outputDoc << "Ft=\"" << output[FORCE_TAN].first << ","
+                    << output[FORCE_TAN].second << "\" ";
+        if (output[FORCE_ORTHO] != double2(0., 0.))
+          outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << ","
+                    << output[FORCE_ORTHO].second << "\" ";
+        outputDoc << "/>" << endl;
+        //  Erase the entry in slip_wall to make the next sequential search
+        //  "easier"
+        interactionsOutputWall.erase(iterator++);
+      }
+    }
+  }
+  outputDoc << "    </Agent>" << endl;
+  outputDoc << "</Interactions>";
+
+  outputDoc.close();
 }

clang-tidy...............................................................Failed
- hook id: clang-tidy
- exit code: 1

/Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/src/Main.cpp:13:10: error: 'CrowdMechanics.h' file not found [clang-diagnostic-error]
   13 | #include "CrowdMechanics.h"
      |          ^~~~~~~~~~~~~~~~~~
Error while trying to load a compilation database:
Could not auto-detect compilation database for file "tests/mechanical_layer/src/Main.cpp"
No compilation database found in /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/src or any parent directory
fixed-compilation-database: Error while opening fixed database: No such file or directory
json-compilation-database: Error while opening JSON database: No such file or directory
Running without flags.
1 error generated.
Error while processing /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/src/Main.cpp.
Found compiler error(s).
/Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/include/Globals.h:4:10: error: 'random' file not found [clang-diagnostic-error]
    4 | #include <random>
      |          ^~~~~~~~
Error while trying to load a compilation database:
Could not auto-detect compilation database for file "tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp"
No compilation database found in /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/3rdparty/tinyxml or any parent directory
fixed-compilation-database: Error while opening fixed database: No such file or directory
json-compilation-database: Error while opening JSON database: No such file or directory
Running without flags.
Error while trying to load a compilation database:
Could not auto-detect compilation database for file "tests/mechanical_layer/include/InputStatic.h"
No compilation database found in /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/include or any parent directory
fixed-compilation-database: Error while opening fixed database: No such file or directory
json-compilation-database: Error while opening JSON database: No such file or directory
Running without flags.
1 error generated.
Error while processing /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/include/InputStatic.h.
Found compiler error(s).
/Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/src/InputStatic.cpp:1:10: error: 'InputStatic.h' file not found [clang-diagnostic-error]
    1 | #include "InputStatic.h"
      |          ^~~~~~~~~~~~~~~
Error while trying to load a compilation database:
Could not auto-detect compilation database for file "tests/mechanical_layer/src/InputStatic.cpp"
No compilation database found in /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/src or any parent directory
fixed-compilation-database: Error while opening fixed database: No such file or directory
json-compilation-database: Error while opening JSON database: No such file or directory
Running without flags.
1 error generated.
Error while processing /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/src/InputStatic.cpp.
Found compiler error(s).
/Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/include/Globals.h:4:10: error: 'random' file not found [clang-diagnostic-error]
    4 | #include <random>
      |          ^~~~~~~~
Error while trying to load a compilation database:
Could not auto-detect compilation database for file "tests/mechanical_layer/include/Crowd.h"
No compilation database found in /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/include or any parent directory
fixed-compilation-database: Error while opening fixed database: No such file or directory
json-compilation-database: Error while opening JSON database: No such file or directory
Running without flags.
1 error generated.
Error while processing /Volumes/desk_oscar/main/cours/phd_first_year/shape_project/code/tests/mechanical_layer/include/Crowd.h.
Found compiler error(s).

oclint...................................................................Failed
- hook id: oclint
- exit code: 1

Problem with oclint: getting version
The version format for this command has changed.
Create an issue at github.com/pocc/pre-commit-hooks.
Problem with oclint: getting version
The version format for this command has changed.
Create an issue at github.com/pocc/pre-commit-hooks.
Problem with oclint: getting version
The version format for this command has changed.
Create an issue at github.com/pocc/pre-commit-hooks.
Problem with oclint: getting version
The version format for this command has changed.
Create an issue at github.com/pocc/pre-commit-hooks.

uncrustify...............................................................Failed
- hook id: uncrustify
- exit code: 1

tests/mechanical_layer/src/Main.cpp
====================
--- original

+++ formatted

@@ -16,65 +16,65 @@

 
 //  extern C is a trick for Python ctypes to work
 extern "C" {
-    /**
-     * @brief The main function of CrowdMechanics, and the only one to be called when used as a library.
-     *
-     * It reads static and dynamic XML files,
-     * stores everything and simulates the dynamics of the agents.
-     *
-     * @param files An array of file names. They should be given in a precise order:
-     *      - Parameters (directories, time step...)
-     *      - Materials (with Young's modulus and the shear modulus
-     *      - Geometry (obstacles)
-     *      - Agents
-     *      - Agent dynamics (current kinematics, and driving forces and torques)
-     *      - (optional) Agent interactions (the information about agent-to-agent and agent-to-obstacle contacts,
-     *                   if any, will be used.
-     *
-     * @return  EXIT_SUCCESS if the program executed successfully.
-     *          EXIT_FAILURE in case of issue(s) with any of the XML files' contents
-     */
-    int CrowdMechanics(char** files)
-    {
-        /*  Read general PARAMETERS */
-        if (const string parametersFile = files[0];
-            readParameters(parametersFile) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+/**
+ * @brief The main function of CrowdMechanics, and the only one to be called when used as a library.
+ *
+ * It reads static and dynamic XML files,
+ * stores everything and simulates the dynamics of the agents.
+ *
+ * @param files An array of file names. They should be given in a precise order:
+ *      - Parameters (directories, time step...)
+ *      - Materials (with Young's modulus and the shear modulus
+ *      - Geometry (obstacles)
+ *      - Agents
+ *      - Agent dynamics (current kinematics, and driving forces and torques)
+ *      - (optional) Agent interactions (the information about agent-to-agent and agent-to-obstacle contacts,
+ *                   if any, will be used.
+ *
+ * @return  EXIT_SUCCESS if the program executed successfully.
+ *          EXIT_FAILURE in case of issue(s) with any of the XML files' contents
+ */
+int CrowdMechanics(char** files)
+{
+  /*  Read general PARAMETERS */
+  if (const string parametersFile = files[0];
+      readParameters(parametersFile) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
-        /*  Read MATERIALS  */
-        //  Mapping between user-given id's and indexes in the program
-        map<string, int32_t> materialMapping;
-        if (const string materialsFile = pathStatic + files[1];
-            readMaterials(materialsFile, materialMapping) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Read MATERIALS  */
+  //  Mapping between user-given id's and indexes in the program
+  map<string, int32_t> materialMapping;
+  if (const string materialsFile = pathStatic + files[1];
+      readMaterials(materialsFile, materialMapping) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
-        /*  Read GEOMETRY   */
-        if (const string geometryFile = pathStatic + files[2];
-            readGeometry(geometryFile, materialMapping) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Read GEOMETRY   */
+  if (const string geometryFile = pathStatic + files[2];
+      readGeometry(geometryFile, materialMapping) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
-        /*  Read AGENTS */
-        vector<unsigned> nb_shapes_allagents, shapeIDagent;
-        vector<int> edges;
-        vector<double> radius_allshapes, masses, mois;
-        vector<double2> delta_gtos;
-        if (const string agentsFile = pathStatic + files[3];
-            readAgents(agentsFile, nb_shapes_allagents,
-                    shapeIDagent, edges, radius_allshapes, masses, mois,
-                    delta_gtos, materialMapping) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Read AGENTS */
+  vector<unsigned> nb_shapes_allagents, shapeIDagent;
+  vector<int> edges;
+  vector<double> radius_allshapes, masses, mois;
+  vector<double2> delta_gtos;
+  if (const string agentsFile = pathStatic + files[3];
+      readAgents(agentsFile, nb_shapes_allagents,
+                 shapeIDagent, edges, radius_allshapes, masses, mois,
+                 delta_gtos, materialMapping) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
 
-        /*  Initialise simulation  */
-        const string dynamicsFile = pathDynamic + files[4];
-        if (initialiseSetting(dynamicsFile, nb_shapes_allagents, shapeIDagent, edges,
-            radius_allshapes, masses, mois, delta_gtos) == EXIT_FAILURE)
-            return EXIT_FAILURE;
+  /*  Initialise simulation  */
+  const string dynamicsFile = pathDynamic + files[4];
+  if (initialiseSetting(dynamicsFile, nb_shapes_allagents, shapeIDagent, edges,
+                        radius_allshapes, masses, mois, delta_gtos) == EXIT_FAILURE)
+    return EXIT_FAILURE;
 
 
-        /*  Main program procedure  */
-        handleMechanicalLayer(dynamicsFile);
+  /*  Main program procedure  */
+  handleMechanicalLayer(dynamicsFile);
 
-        return EXIT_SUCCESS;
-    }
+  return EXIT_SUCCESS;
 }
+}
tests/mechanical_layer/include/CrowdMechanics.h
====================
--- original

+++ formatted

@@ -7,10 +7,10 @@

 
 /*
     Functions
-                */
+ */
 //  Main
 extern "C" {            //  extern C is a trick for Python ctypes to work
-    int CrowdMechanics(char** files);
+int CrowdMechanics(char** files);
 }
 
 #endif  /*  MAIN_H  */
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h
====================
--- original

+++ formatted

@@ -1,25 +1,25 @@

 /*
-Original code by Lee Thomason (www.grinninglizard.com)
-
-This software is provided 'as-is', without any express or implied
-warranty. In no event will the authors be held liable for any
-damages arising from the use of this software.
-
-Permission is granted to anyone to use this software for any
-purpose, including commercial applications, and to alter it and
-redistribute it freely, subject to the following restrictions:
-
-1. The origin of this software must not be misrepresented; you must
-not claim that you wrote the original software. If you use this
-software in a product, an acknowledgment in the product documentation
-would be appreciated but is not required.
-
-2. Altered source versions must be plainly marked as such, and
-must not be misrepresented as being the original software.
-
-3. This notice may not be removed or altered from any source
-distribution.
-*/
+   Original code by Lee Thomason (www.grinninglizard.com)
+
+   This software is provided 'as-is', without any express or implied
+   warranty. In no event will the authors be held liable for any
+   damages arising from the use of this software.
+
+   Permission is granted to anyone to use this software for any
+   purpose, including commercial applications, and to alter it and
+   redistribute it freely, subject to the following restrictions:
+
+   1. The origin of this software must not be misrepresented; you must
+   not claim that you wrote the original software. If you use this
+   software in a product, an acknowledgment in the product documentation
+   would be appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and
+   must not be misrepresented as being the original software.
+
+   3. This notice may not be removed or altered from any source
+   distribution.
+ */
 
 #ifndef TINYXML2_INCLUDED
 #define TINYXML2_INCLUDED
@@ -30,9 +30,9 @@

 #   include <stdio.h>
 #   include <stdlib.h>
 #   include <string.h>
-#	if defined(__PS3__)
-#		include <stddef.h>
-#	endif
+#       if defined(__PS3__)
+#               include <stddef.h>
+#       endif
 #else
 #   include <cctype>
 #   include <climits>
@@ -43,12 +43,12 @@

 #include <stdint.h>
 
 /*
-	gcc:
+        gcc:
         g++ -Wall -DTINYXML2_DEBUG tinyxml2.cpp xmltest.cpp -o gccxmltest.exe
 
     Formatting, Artistic Style:
         AStyle.exe --style=1tbs --indent-switches --break-closing-brackets --indent-preprocessor tinyxml2.cpp tinyxml2.h
-*/
+ */
 
 #if defined( _DEBUG ) || defined (__DEBUG__)
 #   ifndef TINYXML2_DEBUG
@@ -94,8 +94,8 @@

 #endif
 
 /* Versioning, past 1.0.14:
-	http://semver.org/
-*/
+        http://semver.org/
+ */
 static const int TIXML2_MAJOR_VERSION = 11;
 static const int TIXML2_MINOR_VERSION = 0;
 static const int TIXML2_PATCH_VERSION = 0;
@@ -123,2254 +123,2276 @@

 class XMLPrinter;
 
 /*
-	A class that wraps strings. Normally stores the start and end
-	pointers into the XML file itself, and will apply normalization
-	and entity translation if actually read. Can also store (and memory
-	manage) a traditional char[]
+        A class that wraps strings. Normally stores the start and end
+        pointers into the XML file itself, and will apply normalization
+        and entity translation if actually read. Can also store (and memory
+        manage) a traditional char[]
 
     Isn't clear why TINYXML2_LIB is needed; but seems to fix #719
-*/
+ */
 class TINYXML2_LIB StrPair
 {
 public:
-    enum Mode {
-        NEEDS_ENTITY_PROCESSING			= 0x01,
-        NEEDS_NEWLINE_NORMALIZATION		= 0x02,
-        NEEDS_WHITESPACE_COLLAPSING     = 0x04,
-
-        TEXT_ELEMENT		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
-        TEXT_ELEMENT_LEAVE_ENTITIES		= NEEDS_NEWLINE_NORMALIZATION,
-        ATTRIBUTE_NAME		            = 0,
-        ATTRIBUTE_VALUE		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
-        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,
-        COMMENT							= NEEDS_NEWLINE_NORMALIZATION
-    };
-
-    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}
-    ~StrPair();
-
-    void Set( char* start, char* end, int flags ) {
-        TIXMLASSERT( start );
-        TIXMLASSERT( end );
-        Reset();
-        _start  = start;
-        _end    = end;
-        _flags  = flags | NEEDS_FLUSH;
-    }
-
-    const char* GetStr();
-
-    bool Empty() const {
-        return _start == _end;
-    }
-
-    void SetInternedStr( const char* str ) {
-        Reset();
-        _start = const_cast<char*>(str);
-    }
-
-    void SetStr( const char* str, int flags=0 );
-
-    char* ParseText( char* in, const char* endTag, int strFlags, int* curLineNumPtr );
-    char* ParseName( char* in );
-
-    void TransferTo( StrPair* other );
-	void Reset();
+enum Mode {
+  NEEDS_ENTITY_PROCESSING                 = 0x01,
+  NEEDS_NEWLINE_NORMALIZATION             = 0x02,
+  NEEDS_WHITESPACE_COLLAPSING     = 0x04,
+
+  TEXT_ELEMENT                        = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
+  TEXT_ELEMENT_LEAVE_ENTITIES             = NEEDS_NEWLINE_NORMALIZATION,
+  ATTRIBUTE_NAME                      = 0,
+  ATTRIBUTE_VALUE                     = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
+  ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,
+  COMMENT                                                 = NEEDS_NEWLINE_NORMALIZATION
+};
+
+StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {
+}
+~StrPair();
+
+void Set( char* start, char* end, int flags ) {
+  TIXMLASSERT( start );
+  TIXMLASSERT( end );
+  Reset();
+  _start  = start;
+  _end    = end;
+  _flags  = flags | NEEDS_FLUSH;
+}
+
+const char* GetStr();
+
+bool Empty() const {
+  return _start == _end;
+}
+
+void SetInternedStr( const char* str ) {
+  Reset();
+  _start = const_cast<char*>(str);
+}
+
+void SetStr( const char* str, int flags=0 );
+
+char* ParseText( char* in, const char* endTag, int strFlags, int* curLineNumPtr );
+char* ParseName( char* in );
+
+void TransferTo( StrPair* other );
+void Reset();
 
 private:
-    void CollapseWhitespace();
-
-    enum {
-        NEEDS_FLUSH = 0x100,
-        NEEDS_DELETE = 0x200
-    };
-
-    int     _flags;
-    char*   _start;
-    char*   _end;
-
-    StrPair( const StrPair& other );	// not supported
-    void operator=( const StrPair& other );	// not supported, use TransferTo()
+void CollapseWhitespace();
+
+enum {
+  NEEDS_FLUSH = 0x100,
+  NEEDS_DELETE = 0x200
+};
+
+int _flags;
+char*   _start;
+char*   _end;
+
+StrPair( const StrPair& other );        // not supported
+void operator=( const StrPair& other );         // not supported, use TransferTo()
 };
 
 
 /*
-	A dynamic array of Plain Old Data. Doesn't support constructors, etc.
-	Has a small initial memory pool, so that low or no usage will not
-	cause a call to new/delete
-*/
+        A dynamic array of Plain Old Data. Doesn't support constructors, etc.
+        Has a small initial memory pool, so that low or no usage will not
+        cause a call to new/delete
+ */
 template <class T, size_t INITIAL_SIZE>
 class DynArray
 {
 public:
-    DynArray() :
-        _mem( _pool ),
-        _allocated( INITIAL_SIZE ),
-        _size( 0 )
-    {
+DynArray() :
+  _mem( _pool ),
+  _allocated( INITIAL_SIZE ),
+  _size( 0 )
+{
+}
+
+~DynArray() {
+  if ( _mem != _pool ) {
+    delete [] _mem;
+  }
+}
+
+void Clear() {
+  _size = 0;
+}
+
+void Push( T t ) {
+  TIXMLASSERT( _size < INT_MAX );
+  EnsureCapacity( _size+1 );
+  _mem[_size] = t;
+  ++_size;
+}
+
+T* PushArr( size_t count ) {
+  TIXMLASSERT( _size <= SIZE_MAX - count );
+  EnsureCapacity( _size+count );
+  T* ret = &_mem[_size];
+  _size += count;
+  return ret;
+}
+
+T Pop() {
+  TIXMLASSERT( _size > 0 );
+  --_size;
+  return _mem[_size];
+}
+
+void PopArr( size_t count ) {
+  TIXMLASSERT( _size >= count );
+  _size -= count;
+}
+
+bool Empty() const {
+  return _size == 0;
+}
+
+T& operator[](size_t i) {
+  TIXMLASSERT( i < _size );
+  return _mem[i];
+}
+
+const T& operator[](size_t i) const {
+  TIXMLASSERT( i < _size );
+  return _mem[i];
+}
+
+const T& PeekTop() const {
+  TIXMLASSERT( _size > 0 );
+  return _mem[ _size - 1];
+}
+
+size_t Size() const {
+  TIXMLASSERT( _size >= 0 );
+  return _size;
+}
+
+size_t Capacity() const {
+  TIXMLASSERT( _allocated >= INITIAL_SIZE );
+  return _allocated;
+}
+
+void SwapRemove(size_t i) {
+  TIXMLASSERT(i < _size);
+  TIXMLASSERT(_size > 0);
+  _mem[i] = _mem[_size - 1];
+  --_size;
+}
+
+const T* Mem() const {
+  TIXMLASSERT( _mem );
+  return _mem;
+}
+
+T* Mem() {
+  TIXMLASSERT( _mem );
+  return _mem;
+}
+
+private:
+DynArray( const DynArray& );     // not supported
+void operator=( const DynArray& );     // not supported
+
+void EnsureCapacity( size_t cap ) {
+  TIXMLASSERT( cap > 0 );
+  if ( cap > _allocated ) {
+    TIXMLASSERT( cap <= SIZE_MAX / 2 / sizeof(T));
+    const size_t newAllocated = cap * 2;
+    T* newMem = new T[newAllocated];
+    TIXMLASSERT( newAllocated >= _size );
+    memcpy( newMem, _mem, sizeof(T) * _size );          // warning: not using constructors, only works for PODs
+    if ( _mem != _pool ) {
+      delete [] _mem;
     }
-
-    ~DynArray() {
-        if ( _mem != _pool ) {
-            delete [] _mem;
-        }
-    }
-
-    void Clear() {
-        _size = 0;
-    }
-
-    void Push( T t ) {
-        TIXMLASSERT( _size < INT_MAX );
-        EnsureCapacity( _size+1 );
-        _mem[_size] = t;
-        ++_size;
-    }
-
-    T* PushArr( size_t count ) {
-        TIXMLASSERT( _size <= SIZE_MAX - count );
-        EnsureCapacity( _size+count );
-        T* ret = &_mem[_size];
-        _size += count;
-        return ret;
-    }
-
-    T Pop() {
-        TIXMLASSERT( _size > 0 );
-        --_size;
-        return _mem[_size];
-    }
-
-    void PopArr( size_t count ) {
-        TIXMLASSERT( _size >= count );
-        _size -= count;
-    }
-
-    bool Empty() const					{
-        return _size == 0;
-    }
-
-    T& operator[](size_t i) {
-        TIXMLASSERT( i < _size );
-        return _mem[i];
-    }
-
-    const T& operator[](size_t i) const {
-        TIXMLASSERT( i < _size );
-        return _mem[i];
-    }
-
-    const T& PeekTop() const            {
-        TIXMLASSERT( _size > 0 );
-        return _mem[ _size - 1];
-    }
-
-    size_t Size() const {
-        TIXMLASSERT( _size >= 0 );
-        return _size;
-    }
-
-    size_t Capacity() const {
-        TIXMLASSERT( _allocated >= INITIAL_SIZE );
-        return _allocated;
-    }
-
-	void SwapRemove(size_t i) {
-		TIXMLASSERT(i < _size);
-		TIXMLASSERT(_size > 0);
-		_mem[i] = _mem[_size - 1];
-		--_size;
-	}
-
-    const T* Mem() const				{
-        TIXMLASSERT( _mem );
-        return _mem;
-    }
-
-    T* Mem() {
-        TIXMLASSERT( _mem );
-        return _mem;
-    }
-
-private:
-    DynArray( const DynArray& ); // not supported
-    void operator=( const DynArray& ); // not supported
-
-    void EnsureCapacity( size_t cap ) {
-        TIXMLASSERT( cap > 0 );
-        if ( cap > _allocated ) {
-            TIXMLASSERT( cap <= SIZE_MAX / 2 / sizeof(T));
-            const size_t newAllocated = cap * 2;
-            T* newMem = new T[newAllocated];
-            TIXMLASSERT( newAllocated >= _size );
-            memcpy( newMem, _mem, sizeof(T) * _size );	// warning: not using constructors, only works for PODs
-            if ( _mem != _pool ) {
-                delete [] _mem;
-            }
-            _mem = newMem;
-            _allocated = newAllocated;
-        }
-    }
-
-    T*  _mem;
-    T   _pool[INITIAL_SIZE];
-    size_t _allocated;		// objects allocated
-    size_t _size;			// number objects in use
+    _mem = newMem;
+    _allocated = newAllocated;
+  }
+}
+
+T*  _mem;
+T _pool[INITIAL_SIZE];
+size_t _allocated;              // objects allocated
+size_t _size;                           // number objects in use
 };
 
 
 /*
-	Parent virtual class of a pool for fast allocation
-	and deallocation of objects.
-*/
+        Parent virtual class of a pool for fast allocation
+        and deallocation of objects.
+ */
 class MemPool
 {
 public:
-    MemPool() {}
-    virtual ~MemPool() {}
-
-    virtual size_t ItemSize() const = 0;
-    virtual void* Alloc() = 0;
-    virtual void Free( void* ) = 0;
-    virtual void SetTracked() = 0;
+MemPool() {
+}
+virtual ~MemPool() {
+}
+
+virtual size_t ItemSize() const = 0;
+virtual void* Alloc() = 0;
+virtual void Free( void* ) = 0;
+virtual void SetTracked() = 0;
 };
 
 
 /*
-	Template child class to create pools of the correct type.
-*/
+        Template child class to create pools of the correct type.
+ */
 template< size_t ITEM_SIZE >
 class MemPoolT : public MemPool
 {
 public:
-    MemPoolT() : _blockPtrs(), _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)	{}
-    ~MemPoolT() {
-        MemPoolT< ITEM_SIZE >::Clear();
+MemPoolT() : _blockPtrs(), _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)  {
+}
+~MemPoolT() {
+  MemPoolT< ITEM_SIZE >::Clear();
+}
+
+void Clear() {
+  // Delete the blocks.
+  while( !_blockPtrs.Empty()) {
+    Block* lastBlock = _blockPtrs.Pop();
+    delete lastBlock;
+  }
+  _root = 0;
+  _currentAllocs = 0;
+  _nAllocs = 0;
+  _maxAllocs = 0;
+  _nUntracked = 0;
+}
+
+virtual size_t ItemSize() const override {
+  return ITEM_SIZE;
+}
+size_t CurrentAllocs() const {
+  return _currentAllocs;
+}
+
+virtual void* Alloc() override {
+  if ( !_root ) {
+    // Need a new block.
+    Block* block = new Block;
+    _blockPtrs.Push( block );
+
+    Item* blockItems = block->items;
+    for( size_t i = 0; i < ITEMS_PER_BLOCK - 1; ++i ) {
+      blockItems[i].next = &(blockItems[i + 1]);
     }
-
-    void Clear() {
-        // Delete the blocks.
-        while( !_blockPtrs.Empty()) {
-            Block* lastBlock = _blockPtrs.Pop();
-            delete lastBlock;
-        }
-        _root = 0;
-        _currentAllocs = 0;
-        _nAllocs = 0;
-        _maxAllocs = 0;
-        _nUntracked = 0;
-    }
-
-    virtual size_t ItemSize() const override {
-        return ITEM_SIZE;
-    }
-    size_t CurrentAllocs() const {
-        return _currentAllocs;
-    }
-
-    virtual void* Alloc() override{
-        if ( !_root ) {
-            // Need a new block.
-            Block* block = new Block;
-            _blockPtrs.Push( block );
-
-            Item* blockItems = block->items;
-            for( size_t i = 0; i < ITEMS_PER_BLOCK - 1; ++i ) {
-                blockItems[i].next = &(blockItems[i + 1]);
-            }
-            blockItems[ITEMS_PER_BLOCK - 1].next = 0;
-            _root = blockItems;
-        }
-        Item* const result = _root;
-        TIXMLASSERT( result != 0 );
-        _root = _root->next;
-
-        ++_currentAllocs;
-        if ( _currentAllocs > _maxAllocs ) {
-            _maxAllocs = _currentAllocs;
-        }
-        ++_nAllocs;
-        ++_nUntracked;
-        return result;
-    }
-
-    virtual void Free( void* mem ) override {
-        if ( !mem ) {
-            return;
-        }
-        --_currentAllocs;
-        Item* item = static_cast<Item*>( mem );
+    blockItems[ITEMS_PER_BLOCK - 1].next = 0;
+    _root = blockItems;
+  }
+  Item* const result = _root;
+  TIXMLASSERT( result != 0 );
+  _root = _root->next;
+
+  ++_currentAllocs;
+  if ( _currentAllocs > _maxAllocs ) {
+    _maxAllocs = _currentAllocs;
+  }
+  ++_nAllocs;
+  ++_nUntracked;
+  return result;
+}
+
+virtual void Free( void* mem ) override {
+  if ( !mem ) {
+    return;
+  }
+  --_currentAllocs;
+  Item* item = static_cast<Item*>( mem );
 #ifdef TINYXML2_DEBUG
-        memset( item, 0xfe, sizeof( *item ) );
+  memset( item, 0xfe, sizeof( *item ) );
 #endif
-        item->next = _root;
-        _root = item;
-    }
-    void Trace( const char* name ) {
-        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
-                name, _maxAllocs, _maxAllocs * ITEM_SIZE / 1024, _currentAllocs,
-                ITEM_SIZE, _nAllocs, _blockPtrs.Size() );
-    }
-
-    void SetTracked() override {
-        --_nUntracked;
-    }
-
-    size_t Untracked() const {
-        return _nUntracked;
-    }
-
-	// This number is perf sensitive. 4k seems like a good tradeoff on my machine.
-	// The test file is large, 170k.
-	// Release:		VS2010 gcc(no opt)
-	//		1k:		4000
-	//		2k:		4000
-	//		4k:		3900	21000
-	//		16k:	5200
-	//		32k:	4300
-	//		64k:	4000	21000
-    // Declared public because some compilers do not accept to use ITEMS_PER_BLOCK
-    // in private part if ITEMS_PER_BLOCK is private
-    enum { ITEMS_PER_BLOCK = (4 * 1024) / ITEM_SIZE };
+  item->next = _root;
+  _root = item;
+}
+void Trace( const char* name ) {
+  printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
+          name, _maxAllocs, _maxAllocs * ITEM_SIZE / 1024, _currentAllocs,
+          ITEM_SIZE, _nAllocs, _blockPtrs.Size() );
+}
+
+void SetTracked() override {
+  --_nUntracked;
+}
+
+size_t Untracked() const {
+  return _nUntracked;
+}
+
+// This number is perf sensitive. 4k seems like a good tradeoff on my machine.
+// The test file is large, 170k.
+// Release:		VS2010 gcc(no opt)
+//		1k:		4000
+//		2k:		4000
+//		4k:		3900	21000
+//		16k:	5200
+//		32k:	4300
+//		64k:	4000	21000
+// Declared public because some compilers do not accept to use ITEMS_PER_BLOCK
+// in private part if ITEMS_PER_BLOCK is private
+enum { ITEMS_PER_BLOCK = (4 * 1024) / ITEM_SIZE };
 
 private:
-    MemPoolT( const MemPoolT& ); // not supported
-    void operator=( const MemPoolT& ); // not supported
-
-    union Item {
-        Item*   next;
-        char    itemData[static_cast<size_t>(ITEM_SIZE)];
-    };
-    struct Block {
-        Item items[ITEMS_PER_BLOCK];
-    };
-    DynArray< Block*, 10 > _blockPtrs;
-    Item* _root;
-
-    size_t _currentAllocs;
-    size_t _nAllocs;
-    size_t _maxAllocs;
-    size_t _nUntracked;
-};
-
-
-
-/**
-	Implements the interface to the "Visitor pattern" (see the Accept() method.)
-	If you call the Accept() method, it requires being passed a XMLVisitor
-	class to handle callbacks. For nodes that contain other nodes (Document, Element)
-	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
-	are simply called with Visit().
-
-	If you return 'true' from a Visit method, recursive parsing will continue. If you return
-	false, <b>no children of this node or its siblings</b> will be visited.
-
-	All flavors of Visit methods have a default implementation that returns 'true' (continue
-	visiting). You need to only override methods that are interesting to you.
-
-	Generally Accept() is called on the XMLDocument, although all nodes support visiting.
-
-	You should never change the document from a callback.
-
-	@sa XMLNode::Accept()
-*/
+MemPoolT( const MemPoolT& );     // not supported
+void operator=( const MemPoolT& );     // not supported
+
+union Item {
+  Item*   next;
+  char itemData[static_cast<size_t>(ITEM_SIZE)];
+};
+struct Block {
+  Item items[ITEMS_PER_BLOCK];
+};
+DynArray< Block*, 10 > _blockPtrs;
+Item* _root;
+
+size_t _currentAllocs;
+size_t _nAllocs;
+size_t _maxAllocs;
+size_t _nUntracked;
+};
+
+
+
+/**
+        Implements the interface to the "Visitor pattern" (see the Accept() method.)
+        If you call the Accept() method, it requires being passed a XMLVisitor
+        class to handle callbacks. For nodes that contain other nodes (Document, Element)
+        you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
+        are simply called with Visit().
+
+        If you return 'true' from a Visit method, recursive parsing will continue. If you return
+        false, <b>no children of this node or its siblings</b> will be visited.
+
+        All flavors of Visit methods have a default implementation that returns 'true' (continue
+        visiting). You need to only override methods that are interesting to you.
+
+        Generally Accept() is called on the XMLDocument, although all nodes support visiting.
+
+        You should never change the document from a callback.
+
+        @sa XMLNode::Accept()
+ */
 class TINYXML2_LIB XMLVisitor
 {
 public:
-    virtual ~XMLVisitor() {}
-
-    /// Visit a document.
-    virtual bool VisitEnter( const XMLDocument& /*doc*/ )			{
-        return true;
-    }
-    /// Visit a document.
-    virtual bool VisitExit( const XMLDocument& /*doc*/ )			{
-        return true;
-    }
-
-    /// Visit an element.
-    virtual bool VisitEnter( const XMLElement& /*element*/, const XMLAttribute* /*firstAttribute*/ )	{
-        return true;
-    }
-    /// Visit an element.
-    virtual bool VisitExit( const XMLElement& /*element*/ )			{
-        return true;
-    }
-
-    /// Visit a declaration.
-    virtual bool Visit( const XMLDeclaration& /*declaration*/ )		{
-        return true;
-    }
-    /// Visit a text node.
-    virtual bool Visit( const XMLText& /*text*/ )					{
-        return true;
-    }
-    /// Visit a comment node.
-    virtual bool Visit( const XMLComment& /*comment*/ )				{
-        return true;
-    }
-    /// Visit an unknown node.
-    virtual bool Visit( const XMLUnknown& /*unknown*/ )				{
-        return true;
-    }
+virtual ~XMLVisitor() {
+}
+
+/// Visit a document.
+virtual bool VisitEnter( const XMLDocument& /*doc*/ )                       {
+  return true;
+}
+/// Visit a document.
+virtual bool VisitExit( const XMLDocument& /*doc*/ )                        {
+  return true;
+}
+
+/// Visit an element.
+virtual bool VisitEnter( const XMLElement& /*element*/, const XMLAttribute* /*firstAttribute*/ )    {
+  return true;
+}
+/// Visit an element.
+virtual bool VisitExit( const XMLElement& /*element*/ )                     {
+  return true;
+}
+
+/// Visit a declaration.
+virtual bool Visit( const XMLDeclaration& /*declaration*/ )         {
+  return true;
+}
+/// Visit a text node.
+virtual bool Visit( const XMLText& /*text*/ )                                       {
+  return true;
+}
+/// Visit a comment node.
+virtual bool Visit( const XMLComment& /*comment*/ )                         {
+  return true;
+}
+/// Visit an unknown node.
+virtual bool Visit( const XMLUnknown& /*unknown*/ )                         {
+  return true;
+}
 };
 
 // WARNING: must match XMLDocument::_errorNames[]
 enum XMLError {
-    XML_SUCCESS = 0,
-    XML_NO_ATTRIBUTE,
-    XML_WRONG_ATTRIBUTE_TYPE,
-    XML_ERROR_FILE_NOT_FOUND,
-    XML_ERROR_FILE_COULD_NOT_BE_OPENED,
-    XML_ERROR_FILE_READ_ERROR,
-    XML_ERROR_PARSING_ELEMENT,
-    XML_ERROR_PARSING_ATTRIBUTE,
-    XML_ERROR_PARSING_TEXT,
-    XML_ERROR_PARSING_CDATA,
-    XML_ERROR_PARSING_COMMENT,
-    XML_ERROR_PARSING_DECLARATION,
-    XML_ERROR_PARSING_UNKNOWN,
-    XML_ERROR_EMPTY_DOCUMENT,
-    XML_ERROR_MISMATCHED_ELEMENT,
-    XML_ERROR_PARSING,
-    XML_CAN_NOT_CONVERT_TEXT,
-    XML_NO_TEXT_NODE,
-	XML_ELEMENT_DEPTH_EXCEEDED,
-
-	XML_ERROR_COUNT
+  XML_SUCCESS = 0,
+  XML_NO_ATTRIBUTE,
+  XML_WRONG_ATTRIBUTE_TYPE,
+  XML_ERROR_FILE_NOT_FOUND,
+  XML_ERROR_FILE_COULD_NOT_BE_OPENED,
+  XML_ERROR_FILE_READ_ERROR,
+  XML_ERROR_PARSING_ELEMENT,
+  XML_ERROR_PARSING_ATTRIBUTE,
+  XML_ERROR_PARSING_TEXT,
+  XML_ERROR_PARSING_CDATA,
+  XML_ERROR_PARSING_COMMENT,
+  XML_ERROR_PARSING_DECLARATION,
+  XML_ERROR_PARSING_UNKNOWN,
+  XML_ERROR_EMPTY_DOCUMENT,
+  XML_ERROR_MISMATCHED_ELEMENT,
+  XML_ERROR_PARSING,
+  XML_CAN_NOT_CONVERT_TEXT,
+  XML_NO_TEXT_NODE,
+  XML_ELEMENT_DEPTH_EXCEEDED,
+
+  XML_ERROR_COUNT
 };
 
 
 /*
-	Utility functionality.
-*/
+        Utility functionality.
+ */
 class TINYXML2_LIB XMLUtil
 {
 public:
-    static const char* SkipWhiteSpace( const char* p, int* curLineNumPtr )	{
-        TIXMLASSERT( p );
-
-        while( IsWhiteSpace(*p) ) {
-            if (curLineNumPtr && *p == '\n') {
-                ++(*curLineNumPtr);
-            }
-            ++p;
-        }
-        TIXMLASSERT( p );
-        return p;
+static const char* SkipWhiteSpace( const char* p, int* curLineNumPtr )      {
+  TIXMLASSERT( p );
+
+  while( IsWhiteSpace(*p) ) {
+    if (curLineNumPtr && *p == '\n') {
+      ++(*curLineNumPtr);
     }
-    static char* SkipWhiteSpace( char* const p, int* curLineNumPtr ) {
-        return const_cast<char*>( SkipWhiteSpace( const_cast<const char*>(p), curLineNumPtr ) );
-    }
-
-    // Anything in the high order range of UTF-8 is assumed to not be whitespace. This isn't
-    // correct, but simple, and usually works.
-    static bool IsWhiteSpace( char p )					{
-        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );
-    }
-
-    inline static bool IsNameStartChar( unsigned char ch ) {
-        if ( ch >= 128 ) {
-            // This is a heuristic guess in attempt to not implement Unicode-aware isalpha()
-            return true;
-        }
-        if ( isalpha( ch ) ) {
-            return true;
-        }
-        return ch == ':' || ch == '_';
-    }
-
-    inline static bool IsNameChar( unsigned char ch ) {
-        return IsNameStartChar( ch )
-               || isdigit( ch )
-               || ch == '.'
-               || ch == '-';
-    }
-
-    inline static bool IsPrefixHex( const char* p) {
-        p = SkipWhiteSpace(p, 0);
-        return p && *p == '0' && ( *(p + 1) == 'x' || *(p + 1) == 'X');
-    }
-
-    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {
-        if ( p == q ) {
-            return true;
-        }
-        TIXMLASSERT( p );
-        TIXMLASSERT( q );
-        TIXMLASSERT( nChar >= 0 );
-        return strncmp( p, q, static_cast<size_t>(nChar) ) == 0;
-    }
-
-    inline static bool IsUTF8Continuation( const char p ) {
-        return ( p & 0x80 ) != 0;
-    }
-
-    static const char* ReadBOM( const char* p, bool* hasBOM );
-    // p is the starting location,
-    // the UTF-8 value of the entity will be placed in value, and length filled in.
-    static const char* GetCharacterRef( const char* p, char* value, int* length );
-    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
-
-    // converts primitive types to strings
-    static void ToStr( int v, char* buffer, int bufferSize );
-    static void ToStr( unsigned v, char* buffer, int bufferSize );
-    static void ToStr( bool v, char* buffer, int bufferSize );
-    static void ToStr( float v, char* buffer, int bufferSize );
-    static void ToStr( double v, char* buffer, int bufferSize );
-	static void ToStr(int64_t v, char* buffer, int bufferSize);
-    static void ToStr(uint64_t v, char* buffer, int bufferSize);
-
-    // converts strings to primitive types
-    static bool	ToInt( const char* str, int* value );
-    static bool ToUnsigned( const char* str, unsigned* value );
-    static bool	ToBool( const char* str, bool* value );
-    static bool	ToFloat( const char* str, float* value );
-    static bool ToDouble( const char* str, double* value );
-	static bool ToInt64(const char* str, int64_t* value);
-    static bool ToUnsigned64(const char* str, uint64_t* value);
-	// Changes what is serialized for a boolean value.
-	// Default to "true" and "false". Shouldn't be changed
-	// unless you have a special testing or compatibility need.
-	// Be careful: static, global, & not thread safe.
-	// Be sure to set static const memory as parameters.
-	static void SetBoolSerialization(const char* writeTrue, const char* writeFalse);
+    ++p;
+  }
+  TIXMLASSERT( p );
+  return p;
+}
+static char* SkipWhiteSpace( char* const p, int* curLineNumPtr ) {
+  return const_cast<char*>( SkipWhiteSpace( const_cast<const char*>(p), curLineNumPtr ) );
+}
+
+// Anything in the high order range of UTF-8 is assumed to not be whitespace. This isn't
+// correct, but simple, and usually works.
+static bool IsWhiteSpace( char p )                                  {
+  return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );
+}
+
+inline static bool IsNameStartChar( unsigned char ch ) {
+  if ( ch >= 128 ) {
+    // This is a heuristic guess in attempt to not implement Unicode-aware isalpha()
+    return true;
+  }
+  if ( isalpha( ch ) ) {
+    return true;
+  }
+  return ch == ':' || ch == '_';
+}
+
+inline static bool IsNameChar( unsigned char ch ) {
+  return IsNameStartChar( ch )
+         || isdigit( ch )
+         || ch == '.'
+         || ch == '-';
+}
+
+inline static bool IsPrefixHex( const char* p) {
+  p = SkipWhiteSpace(p, 0);
+  return p && *p == '0' && ( *(p + 1) == 'x' || *(p + 1) == 'X');
+}
+
+inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {
+  if ( p == q ) {
+    return true;
+  }
+  TIXMLASSERT( p );
+  TIXMLASSERT( q );
+  TIXMLASSERT( nChar >= 0 );
+  return strncmp( p, q, static_cast<size_t>(nChar) ) == 0;
+}
+
+inline static bool IsUTF8Continuation( const char p ) {
+  return ( p & 0x80 ) != 0;
+}
+
+static const char* ReadBOM( const char* p, bool* hasBOM );
+// p is the starting location,
+// the UTF-8 value of the entity will be placed in value, and length filled in.
+static const char* GetCharacterRef( const char* p, char* value, int* length );
+static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+// converts primitive types to strings
+static void ToStr( int v, char* buffer, int bufferSize );
+static void ToStr( unsigned v, char* buffer, int bufferSize );
+static void ToStr( bool v, char* buffer, int bufferSize );
+static void ToStr( float v, char* buffer, int bufferSize );
+static void ToStr( double v, char* buffer, int bufferSize );
+static void ToStr(int64_t v, char* buffer, int bufferSize);
+static void ToStr(uint64_t v, char* buffer, int bufferSize);
+
+// converts strings to primitive types
+static bool ToInt( const char* str, int* value );
+static bool ToUnsigned( const char* str, unsigned* value );
+static bool ToBool( const char* str, bool* value );
+static bool ToFloat( const char* str, float* value );
+static bool ToDouble( const char* str, double* value );
+static bool ToInt64(const char* str, int64_t* value);
+static bool ToUnsigned64(const char* str, uint64_t* value);
+// Changes what is serialized for a boolean value.
+// Default to "true" and "false". Shouldn't be changed
+// unless you have a special testing or compatibility need.
+// Be careful: static, global, & not thread safe.
+// Be sure to set static const memory as parameters.
+static void SetBoolSerialization(const char* writeTrue, const char* writeFalse);
 
 private:
-	static const char* writeBoolTrue;
-	static const char* writeBoolFalse;
+static const char* writeBoolTrue;
+static const char* writeBoolFalse;
 };
 
 
 /** XMLNode is a base class for every object that is in the
-	XML Document Object Model (DOM), except XMLAttributes.
-	Nodes have siblings, a parent, and children which can
-	be navigated. A node is always in a XMLDocument.
-	The type of a XMLNode can be queried, and it can
-	be cast to its more defined type.
-
-	A XMLDocument allocates memory for all its Nodes.
-	When the XMLDocument gets deleted, all its Nodes
-	will also be deleted.
-
-	@verbatim
-	A Document can contain:	Element	(container or leaf)
-							Comment (leaf)
-							Unknown (leaf)
-							Declaration( leaf )
-
-	An Element can contain:	Element (container or leaf)
-							Text	(leaf)
-							Attributes (not on tree)
-							Comment (leaf)
-							Unknown (leaf)
-
-	@endverbatim
-*/
+        XML Document Object Model (DOM), except XMLAttributes.
+        Nodes have siblings, a parent, and children which can
+        be navigated. A node is always in a XMLDocument.
+        The type of a XMLNode can be queried, and it can
+        be cast to its more defined type.
+
+        A XMLDocument allocates memory for all its Nodes.
+        When the XMLDocument gets deleted, all its Nodes
+        will also be deleted.
+
+        @verbatim
+        A Document can contain:	Element	(container or leaf)
+                                                        Comment (leaf)
+                                                        Unknown (leaf)
+                                                        Declaration( leaf )
+
+        An Element can contain:	Element (container or leaf)
+                                                        Text	(leaf)
+                                                        Attributes (not on tree)
+                                                        Comment (leaf)
+                                                        Unknown (leaf)
+
+        @endverbatim
+ */
 class TINYXML2_LIB XMLNode
 {
-    friend class XMLDocument;
-    friend class XMLElement;
+friend class XMLDocument;
+friend class XMLElement;
 public:
 
-    /// Get the XMLDocument that owns this XMLNode.
-    const XMLDocument* GetDocument() const	{
-        TIXMLASSERT( _document );
-        return _document;
-    }
-    /// Get the XMLDocument that owns this XMLNode.
-    XMLDocument* GetDocument()				{
-        TIXMLASSERT( _document );
-        return _document;
-    }
-
-    /// Safely cast to an Element, or null.
-    virtual XMLElement*		ToElement()		{
-        return 0;
-    }
-    /// Safely cast to Text, or null.
-    virtual XMLText*		ToText()		{
-        return 0;
-    }
-    /// Safely cast to a Comment, or null.
-    virtual XMLComment*		ToComment()		{
-        return 0;
-    }
-    /// Safely cast to a Document, or null.
-    virtual XMLDocument*	ToDocument()	{
-        return 0;
-    }
-    /// Safely cast to a Declaration, or null.
-    virtual XMLDeclaration*	ToDeclaration()	{
-        return 0;
-    }
-    /// Safely cast to an Unknown, or null.
-    virtual XMLUnknown*		ToUnknown()		{
-        return 0;
-    }
-
-    virtual const XMLElement*		ToElement() const		{
-        return 0;
-    }
-    virtual const XMLText*			ToText() const			{
-        return 0;
-    }
-    virtual const XMLComment*		ToComment() const		{
-        return 0;
-    }
-    virtual const XMLDocument*		ToDocument() const		{
-        return 0;
-    }
-    virtual const XMLDeclaration*	ToDeclaration() const	{
-        return 0;
-    }
-    virtual const XMLUnknown*		ToUnknown() const		{
-        return 0;
-    }
-
-    // ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.
-
-    int ChildElementCount(const char *value) const;
-
-    int ChildElementCount() const;
-
-    /** The meaning of 'value' changes for the specific type.
-    	@verbatim
-    	Document:	empty (NULL is returned, not an empty string)
-    	Element:	name of the element
-    	Comment:	the comment text
-    	Unknown:	the tag contents
-    	Text:		the text string
-    	@endverbatim
-    */
-    const char* Value() const;
-
-    /** Set the Value of an XML node.
-    	@sa Value()
-    */
-    void SetValue( const char* val, bool staticMem=false );
-
-    /// Gets the line number the node is in, if the document was parsed from a file.
-    int GetLineNum() const { return _parseLineNum; }
-
-    /// Get the parent of this node on the DOM.
-    const XMLNode*	Parent() const			{
-        return _parent;
-    }
-
-    XMLNode* Parent()						{
-        return _parent;
-    }
-
-    /// Returns true if this node has no children.
-    bool NoChildren() const					{
-        return !_firstChild;
-    }
-
-    /// Get the first child node, or null if none exists.
-    const XMLNode*  FirstChild() const		{
-        return _firstChild;
-    }
-
-    XMLNode*		FirstChild()			{
-        return _firstChild;
-    }
-
-    /** Get the first child element, or optionally the first child
-        element with the specified name.
-    */
-    const XMLElement* FirstChildElement( const char* name = 0 ) const;
-
-    XMLElement* FirstChildElement( const char* name = 0 )	{
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( name ));
-    }
-
-    /// Get the last child node, or null if none exists.
-    const XMLNode*	LastChild() const						{
-        return _lastChild;
-    }
-
-    XMLNode*		LastChild()								{
-        return _lastChild;
-    }
-
-    /** Get the last child element or optionally the last child
-        element with the specified name.
-    */
-    const XMLElement* LastChildElement( const char* name = 0 ) const;
-
-    XMLElement* LastChildElement( const char* name = 0 )	{
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(name) );
-    }
-
-    /// Get the previous (left) sibling node of this node.
-    const XMLNode*	PreviousSibling() const					{
-        return _prev;
-    }
-
-    XMLNode*	PreviousSibling()							{
-        return _prev;
-    }
-
-    /// Get the previous (left) sibling element of this node, with an optionally supplied name.
-    const XMLElement*	PreviousSiblingElement( const char* name = 0 ) const ;
-
-    XMLElement*	PreviousSiblingElement( const char* name = 0 ) {
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( name ) );
-    }
-
-    /// Get the next (right) sibling node of this node.
-    const XMLNode*	NextSibling() const						{
-        return _next;
-    }
-
-    XMLNode*	NextSibling()								{
-        return _next;
-    }
-
-    /// Get the next (right) sibling element of this node, with an optionally supplied name.
-    const XMLElement*	NextSiblingElement( const char* name = 0 ) const;
-
-    XMLElement*	NextSiblingElement( const char* name = 0 )	{
-        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( name ) );
-    }
-
-    /**
-    	Add a child node as the last (right) child.
-		If the child node is already part of the document,
-		it is moved from its old location to the new location.
-		Returns the addThis argument or 0 if the node does not
-		belong to the same document.
-    */
-    XMLNode* InsertEndChild( XMLNode* addThis );
-
-    XMLNode* LinkEndChild( XMLNode* addThis )	{
-        return InsertEndChild( addThis );
-    }
-    /**
-    	Add a child node as the first (left) child.
-		If the child node is already part of the document,
-		it is moved from its old location to the new location.
-		Returns the addThis argument or 0 if the node does not
-		belong to the same document.
-    */
-    XMLNode* InsertFirstChild( XMLNode* addThis );
-    /**
-    	Add a node after the specified child node.
-		If the child node is already part of the document,
-		it is moved from its old location to the new location.
-		Returns the addThis argument or 0 if the afterThis node
-		is not a child of this node, or if the node does not
-		belong to the same document.
-    */
-    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );
-
-    /**
-    	Delete all the children of this node.
-    */
-    void DeleteChildren();
-
-    /**
-    	Delete a child of this node.
-    */
-    void DeleteChild( XMLNode* node );
-
-    /**
-    	Make a copy of this node, but not its children.
-    	You may pass in a Document pointer that will be
-    	the owner of the new Node. If the 'document' is
-    	null, then the node returned will be allocated
-    	from the current Document. (this->GetDocument())
-
-    	Note: if called on a XMLDocument, this will return null.
-    */
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;
-
-	/**
-		Make a copy of this node and all its children.
-
-		If the 'target' is null, then the nodes will
-		be allocated in the current document. If 'target'
-        is specified, the memory will be allocated in the
-        specified XMLDocument.
-
-		NOTE: This is probably not the correct tool to
-		copy a document, since XMLDocuments can have multiple
-		top level XMLNodes. You probably want to use
-        XMLDocument::DeepCopy()
-	*/
-	XMLNode* DeepClone( XMLDocument* target ) const;
-
-    /**
-    	Test if 2 nodes are the same, but don't test children.
-    	The 2 nodes do not need to be in the same Document.
-
-    	Note: if called on a XMLDocument, this will return false.
-    */
-    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;
-
-    /** Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the
-    	XML tree will be conditionally visited and the host will be called back
-    	via the XMLVisitor interface.
-
-    	This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse
-    	the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this
-    	interface versus any other.)
-
-    	The interface has been based on ideas from:
-
-    	- http://www.saxproject.org/
-    	- http://c2.com/cgi/wiki?HierarchicalVisitorPattern
-
-    	Which are both good references for "visiting".
-
-    	An example of using Accept():
-    	@verbatim
-    	XMLPrinter printer;
-    	tinyxmlDoc.Accept( &printer );
-    	const char* xmlcstr = printer.CStr();
-    	@endverbatim
-    */
-    virtual bool Accept( XMLVisitor* visitor ) const = 0;
-
-	/**
-		Set user data into the XMLNode. TinyXML-2 in
-		no way processes or interprets user data.
-		It is initially 0.
-	*/
-	void SetUserData(void* userData)	{ _userData = userData; }
-
-	/**
-		Get user data set into the XMLNode. TinyXML-2 in
-		no way processes or interprets user data.
-		It is initially 0.
-	*/
-	void* GetUserData() const			{ return _userData; }
+/// Get the XMLDocument that owns this XMLNode.
+const XMLDocument* GetDocument() const {
+  TIXMLASSERT( _document );
+  return _document;
+}
+/// Get the XMLDocument that owns this XMLNode.
+XMLDocument* GetDocument()                          {
+  TIXMLASSERT( _document );
+  return _document;
+}
+
+/// Safely cast to an Element, or null.
+virtual XMLElement*         ToElement()             {
+  return 0;
+}
+/// Safely cast to Text, or null.
+virtual XMLText*            ToText()                {
+  return 0;
+}
+/// Safely cast to a Comment, or null.
+virtual XMLComment*         ToComment()             {
+  return 0;
+}
+/// Safely cast to a Document, or null.
+virtual XMLDocument*        ToDocument()    {
+  return 0;
+}
+/// Safely cast to a Declaration, or null.
+virtual XMLDeclaration*     ToDeclaration() {
+  return 0;
+}
+/// Safely cast to an Unknown, or null.
+virtual XMLUnknown*         ToUnknown()             {
+  return 0;
+}
+
+virtual const XMLElement*           ToElement() const {
+  return 0;
+}
+virtual const XMLText*                      ToText() const {
+  return 0;
+}
+virtual const XMLComment*           ToComment() const {
+  return 0;
+}
+virtual const XMLDocument*          ToDocument() const {
+  return 0;
+}
+virtual const XMLDeclaration*       ToDeclaration() const {
+  return 0;
+}
+virtual const XMLUnknown*           ToUnknown() const {
+  return 0;
+}
+
+// ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.
+
+int ChildElementCount(const char *value) const;
+
+int ChildElementCount() const;
+
+/** The meaning of 'value' changes for the specific type.
+    @verbatim
+    Document:	empty (NULL is returned, not an empty string)
+    Element:	name of the element
+    Comment:	the comment text
+    Unknown:	the tag contents
+    Text:		the text string
+    @endverbatim
+ */
+const char* Value() const;
+
+/** Set the Value of an XML node.
+    @sa Value()
+ */
+void SetValue( const char* val, bool staticMem=false );
+
+/// Gets the line number the node is in, if the document was parsed from a file.
+int GetLineNum() const {
+  return _parseLineNum;
+}
+
+/// Get the parent of this node on the DOM.
+const XMLNode*      Parent() const {
+  return _parent;
+}
+
+XMLNode* Parent()                                           {
+  return _parent;
+}
+
+/// Returns true if this node has no children.
+bool NoChildren() const {
+  return !_firstChild;
+}
+
+/// Get the first child node, or null if none exists.
+const XMLNode*  FirstChild() const {
+  return _firstChild;
+}
+
+XMLNode*            FirstChild()                    {
+  return _firstChild;
+}
+
+/** Get the first child element, or optionally the first child
+    element with the specified name.
+ */
+const XMLElement* FirstChildElement( const char* name = 0 ) const;
+
+XMLElement* FirstChildElement( const char* name = 0 )       {
+  return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( name ));
+}
+
+/// Get the last child node, or null if none exists.
+const XMLNode*      LastChild() const {
+  return _lastChild;
+}
+
+XMLNode*            LastChild()                                                             {
+  return _lastChild;
+}
+
+/** Get the last child element or optionally the last child
+    element with the specified name.
+ */
+const XMLElement* LastChildElement( const char* name = 0 ) const;
+
+XMLElement* LastChildElement( const char* name = 0 )        {
+  return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(name) );
+}
+
+/// Get the previous (left) sibling node of this node.
+const XMLNode*      PreviousSibling() const {
+  return _prev;
+}
+
+XMLNode*    PreviousSibling()                                                       {
+  return _prev;
+}
+
+/// Get the previous (left) sibling element of this node, with an optionally supplied name.
+const XMLElement*   PreviousSiblingElement( const char* name = 0 ) const;
+
+XMLElement* PreviousSiblingElement( const char* name = 0 ) {
+  return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( name ) );
+}
+
+/// Get the next (right) sibling node of this node.
+const XMLNode*      NextSibling() const {
+  return _next;
+}
+
+XMLNode*    NextSibling()                                                           {
+  return _next;
+}
+
+/// Get the next (right) sibling element of this node, with an optionally supplied name.
+const XMLElement*   NextSiblingElement( const char* name = 0 ) const;
+
+XMLElement* NextSiblingElement( const char* name = 0 )      {
+  return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( name ) );
+}
+
+/**
+    Add a child node as the last (right) child.
+            If the child node is already part of the document,
+            it is moved from its old location to the new location.
+            Returns the addThis argument or 0 if the node does not
+            belong to the same document.
+ */
+XMLNode* InsertEndChild( XMLNode* addThis );
+
+XMLNode* LinkEndChild( XMLNode* addThis )   {
+  return InsertEndChild( addThis );
+}
+/**
+    Add a child node as the first (left) child.
+            If the child node is already part of the document,
+            it is moved from its old location to the new location.
+            Returns the addThis argument or 0 if the node does not
+            belong to the same document.
+ */
+XMLNode* InsertFirstChild( XMLNode* addThis );
+/**
+    Add a node after the specified child node.
+            If the child node is already part of the document,
+            it is moved from its old location to the new location.
+            Returns the addThis argument or 0 if the afterThis node
+            is not a child of this node, or if the node does not
+            belong to the same document.
+ */
+XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );
+
+/**
+    Delete all the children of this node.
+ */
+void DeleteChildren();
+
+/**
+    Delete a child of this node.
+ */
+void DeleteChild( XMLNode* node );
+
+/**
+    Make a copy of this node, but not its children.
+    You may pass in a Document pointer that will be
+    the owner of the new Node. If the 'document' is
+    null, then the node returned will be allocated
+    from the current Document. (this->GetDocument())
+
+    Note: if called on a XMLDocument, this will return null.
+ */
+virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;
+
+/**
+        Make a copy of this node and all its children.
+
+        If the 'target' is null, then the nodes will
+        be allocated in the current document. If 'target'
+   is specified, the memory will be allocated in the
+   specified XMLDocument.
+
+        NOTE: This is probably not the correct tool to
+        copy a document, since XMLDocuments can have multiple
+        top level XMLNodes. You probably want to use
+   XMLDocument::DeepCopy()
+ */
+XMLNode* DeepClone( XMLDocument* target ) const;
+
+/**
+    Test if 2 nodes are the same, but don't test children.
+    The 2 nodes do not need to be in the same Document.
+
+    Note: if called on a XMLDocument, this will return false.
+ */
+virtual bool ShallowEqual( const XMLNode* compare ) const = 0;
+
+/** Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the
+    XML tree will be conditionally visited and the host will be called back
+    via the XMLVisitor interface.
+
+    This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse
+    the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this
+    interface versus any other.)
+
+    The interface has been based on ideas from:
+
+    - http://www.saxproject.org/
+    - http://c2.com/cgi/wiki?HierarchicalVisitorPattern
+
+    Which are both good references for "visiting".
+
+    An example of using Accept():
+    @verbatim
+    XMLPrinter printer;
+    tinyxmlDoc.Accept( &printer );
+    const char* xmlcstr = printer.CStr();
+    @endverbatim
+ */
+virtual bool Accept( XMLVisitor* visitor ) const = 0;
+
+/**
+        Set user data into the XMLNode. TinyXML-2 in
+        no way processes or interprets user data.
+        It is initially 0.
+ */
+void SetUserData(void* userData)        {
+  _userData = userData;
+}
+
+/**
+        Get user data set into the XMLNode. TinyXML-2 in
+        no way processes or interprets user data.
+        It is initially 0.
+ */
+void* GetUserData() const {
+  return _userData;
+}
 
 protected:
-    explicit XMLNode( XMLDocument* );
-    virtual ~XMLNode();
-
-    virtual char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr);
-
-    XMLDocument*	_document;
-    XMLNode*		_parent;
-    mutable StrPair	_value;
-    int             _parseLineNum;
-
-    XMLNode*		_firstChild;
-    XMLNode*		_lastChild;
-
-    XMLNode*		_prev;
-    XMLNode*		_next;
-
-	void*			_userData;
+explicit XMLNode( XMLDocument* );
+virtual ~XMLNode();
+
+virtual char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr);
+
+XMLDocument*        _document;
+XMLNode*            _parent;
+mutable StrPair _value;
+int _parseLineNum;
+
+XMLNode*            _firstChild;
+XMLNode*            _lastChild;
+
+XMLNode*            _prev;
+XMLNode*            _next;
+
+void*                   _userData;
 
 private:
-    MemPool*		_memPool;
-    void Unlink( XMLNode* child );
-    static void DeleteNode( XMLNode* node );
-    void InsertChildPreamble( XMLNode* insertThis ) const;
-    const XMLElement* ToElementWithName( const char* name ) const;
-
-    XMLNode( const XMLNode& );	// not supported
-    XMLNode& operator=( const XMLNode& );	// not supported
+MemPool*            _memPool;
+void Unlink( XMLNode* child );
+static void DeleteNode( XMLNode* node );
+void InsertChildPreamble( XMLNode* insertThis ) const;
+const XMLElement* ToElementWithName( const char* name ) const;
+
+XMLNode( const XMLNode& );      // not supported
+XMLNode& operator=( const XMLNode& );           // not supported
 };
 
 
 /** XML text.
 
-	Note that a text node can have child element nodes, for example:
-	@verbatim
-	<root>This is <b>bold</b></root>
-	@endverbatim
-
-	A text node can have 2 ways to output the next. "normal" output
-	and CDATA. It will default to the mode it was parsed from the XML file and
-	you generally want to leave it alone, but you can change the output mode with
-	SetCData() and query it with CData().
-*/
+        Note that a text node can have child element nodes, for example:
+        @verbatim
+        <root>This is <b>bold</b></root>
+        @endverbatim
+
+        A text node can have 2 ways to output the next. "normal" output
+        and CDATA. It will default to the mode it was parsed from the XML file and
+        you generally want to leave it alone, but you can change the output mode with
+        SetCData() and query it with CData().
+ */
 class TINYXML2_LIB XMLText : public XMLNode
 {
-    friend class XMLDocument;
+friend class XMLDocument;
 public:
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLText* ToText() override		{
-        return this;
-    }
-    virtual const XMLText* ToText() const override {
-        return this;
-    }
-
-    /// Declare whether this should be CDATA or standard text.
-    void SetCData( bool isCData )			{
-        _isCData = isCData;
-    }
-    /// Returns true if this is a CDATA text element.
-    bool CData() const						{
-        return _isCData;
-    }
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
+virtual bool Accept( XMLVisitor* visitor ) const override;
+
+virtual XMLText* ToText() override {
+  return this;
+}
+virtual const XMLText* ToText() const override {
+  return this;
+}
+
+/// Declare whether this should be CDATA or standard text.
+void SetCData( bool isCData )                       {
+  _isCData = isCData;
+}
+/// Returns true if this is a CDATA text element.
+bool CData() const {
+  return _isCData;
+}
+
+virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
+virtual bool ShallowEqual( const XMLNode* compare ) const override;
 
 protected:
-    explicit XMLText( XMLDocument* doc )	: XMLNode( doc ), _isCData( false )	{}
-    virtual ~XMLText()												{}
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
+explicit XMLText( XMLDocument* doc )        : XMLNode( doc ), _isCData( false )     {
+}
+virtual ~XMLText()                                                                                          {
+}
+
+char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
 
 private:
-    bool _isCData;
-
-    XMLText( const XMLText& );	// not supported
-    XMLText& operator=( const XMLText& );	// not supported
+bool _isCData;
+
+XMLText( const XMLText& );      // not supported
+XMLText& operator=( const XMLText& );           // not supported
 };
 
 
 /** An XML Comment. */
 class TINYXML2_LIB XMLComment : public XMLNode
 {
-    friend class XMLDocument;
+friend class XMLDocument;
 public:
-    virtual XMLComment*	ToComment() override		{
-        return this;
-    }
-    virtual const XMLComment* ToComment() const override {
-        return this;
-    }
-
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
+virtual XMLComment* ToComment() override {
+  return this;
+}
+virtual const XMLComment* ToComment() const override {
+  return this;
+}
+
+virtual bool Accept( XMLVisitor* visitor ) const override;
+
+virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
+virtual bool ShallowEqual( const XMLNode* compare ) const override;
 
 protected:
-    explicit XMLComment( XMLDocument* doc );
-    virtual ~XMLComment();
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
+explicit XMLComment( XMLDocument* doc );
+virtual ~XMLComment();
+
+char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr) override;
 
 private:
-    XMLComment( const XMLComment& );	// not supported
-    XMLComment& operator=( const XMLComment& );	// not supported
+XMLComment( const XMLComment& );        // not supported
+XMLComment& operator=( const XMLComment& );     // not supported
 };
 
 
 /** In correct XML the declaration is the first entry in the file.
-	@verbatim
-		<?xml version="1.0" standalone="yes"?>
-	@endverbatim
-
-	TinyXML-2 will happily read or write files without a declaration,
-	however.
-
-	The text of the declaration isn't interpreted. It is parsed
-	and written as a string.
-*/
+        @verbatim
+                <?xml version="1.0" standalone="yes"?>
+        @endverbatim
+
+        TinyXML-2 will happily read or write files without a declaration,
+        however.
+
+        The text of the declaration isn't interpreted. It is parsed
+        and written as a string.
+ */
 class TINYXML2_LIB XMLDeclaration : public XMLNode
 {
-    friend class XMLDocument;
+friend class XMLDocument;
 public:
-    virtual XMLDeclaration*	ToDeclaration() override		{
-        return this;
-    }
-    virtual const XMLDeclaration* ToDeclaration() const override {
-        return this;
-    }
-
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
+virtual XMLDeclaration*     ToDeclaration() override {
+  return this;
+}
+virtual const XMLDeclaration* ToDeclaration() const override {
+  return this;
+}
+
+virtual bool Accept( XMLVisitor* visitor ) const override;
+
+virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
+virtual bool ShallowEqual( const XMLNode* compare ) const override;
 
 protected:
-    explicit XMLDeclaration( XMLDocument* doc );
-    virtual ~XMLDeclaration();
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
+explicit XMLDeclaration( XMLDocument* doc );
+virtual ~XMLDeclaration();
+
+char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
 
 private:
-    XMLDeclaration( const XMLDeclaration& );	// not supported
-    XMLDeclaration& operator=( const XMLDeclaration& );	// not supported
+XMLDeclaration( const XMLDeclaration& );        // not supported
+XMLDeclaration& operator=( const XMLDeclaration& );     // not supported
 };
 
 
 /** Any tag that TinyXML-2 doesn't recognize is saved as an
-	unknown. It is a tag of text, but should not be modified.
-	It will be written back to the XML, unchanged, when the file
-	is saved.
-
-	DTD tags get thrown into XMLUnknowns.
-*/
+        unknown. It is a tag of text, but should not be modified.
+        It will be written back to the XML, unchanged, when the file
+        is saved.
+
+        DTD tags get thrown into XMLUnknowns.
+ */
 class TINYXML2_LIB XMLUnknown : public XMLNode
 {
-    friend class XMLDocument;
+friend class XMLDocument;
 public:
-    virtual XMLUnknown*	ToUnknown() override		{
-        return this;
-    }
-    virtual const XMLUnknown* ToUnknown() const override {
-        return this;
-    }
-
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
+virtual XMLUnknown* ToUnknown() override {
+  return this;
+}
+virtual const XMLUnknown* ToUnknown() const override {
+  return this;
+}
+
+virtual bool Accept( XMLVisitor* visitor ) const override;
+
+virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
+virtual bool ShallowEqual( const XMLNode* compare ) const override;
 
 protected:
-    explicit XMLUnknown( XMLDocument* doc );
-    virtual ~XMLUnknown();
-
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
+explicit XMLUnknown( XMLDocument* doc );
+virtual ~XMLUnknown();
+
+char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
 
 private:
-    XMLUnknown( const XMLUnknown& );	// not supported
-    XMLUnknown& operator=( const XMLUnknown& );	// not supported
+XMLUnknown( const XMLUnknown& );        // not supported
+XMLUnknown& operator=( const XMLUnknown& );     // not supported
 };
 
 
 
 /** An attribute is a name-value pair. Elements have an arbitrary
-	number of attributes, each with a unique name.
-
-	@note The attributes are not XMLNodes. You may only query the
-	Next() attribute in a list.
-*/
+        number of attributes, each with a unique name.
+
+        @note The attributes are not XMLNodes. You may only query the
+        Next() attribute in a list.
+ */
 class TINYXML2_LIB XMLAttribute
 {
-    friend class XMLElement;
+friend class XMLElement;
 public:
-    /// The name of the attribute.
-    const char* Name() const;
-
-    /// The value of the attribute.
-    const char* Value() const;
-
-    /// Gets the line number the attribute is in, if the document was parsed from a file.
-    int GetLineNum() const { return _parseLineNum; }
-
-    /// The next attribute in the list.
-    const XMLAttribute* Next() const {
-        return _next;
-    }
-
-    /** IntValue interprets the attribute as an integer, and returns the value.
-        If the value isn't an integer, 0 will be returned. There is no error checking;
-    	use QueryIntValue() if you need error checking.
-    */
-	int	IntValue() const {
-		int i = 0;
-		QueryIntValue(&i);
-		return i;
-	}
-
-	int64_t Int64Value() const {
-		int64_t i = 0;
-		QueryInt64Value(&i);
-		return i;
-	}
-
-    uint64_t Unsigned64Value() const {
-        uint64_t i = 0;
-        QueryUnsigned64Value(&i);
-        return i;
-    }
-
-    /// Query as an unsigned integer. See IntValue()
-    unsigned UnsignedValue() const			{
-        unsigned i=0;
-        QueryUnsignedValue( &i );
-        return i;
-    }
-    /// Query as a boolean. See IntValue()
-    bool	 BoolValue() const				{
-        bool b=false;
-        QueryBoolValue( &b );
-        return b;
-    }
-    /// Query as a double. See IntValue()
-    double 	 DoubleValue() const			{
-        double d=0;
-        QueryDoubleValue( &d );
-        return d;
-    }
-    /// Query as a float. See IntValue()
-    float	 FloatValue() const				{
-        float f=0;
-        QueryFloatValue( &f );
-        return f;
-    }
-
-    /** QueryIntValue interprets the attribute as an integer, and returns the value
-    	in the provided parameter. The function will return XML_SUCCESS on success,
-    	and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.
-    */
-    XMLError QueryIntValue( int* value ) const;
-    /// See QueryIntValue
-    XMLError QueryUnsignedValue( unsigned int* value ) const;
-	/// See QueryIntValue
-	XMLError QueryInt64Value(int64_t* value) const;
-    /// See QueryIntValue
-    XMLError QueryUnsigned64Value(uint64_t* value) const;
-	/// See QueryIntValue
-    XMLError QueryBoolValue( bool* value ) const;
-    /// See QueryIntValue
-    XMLError QueryDoubleValue( double* value ) const;
-    /// See QueryIntValue
-    XMLError QueryFloatValue( float* value ) const;
-
-    /// Set the attribute to a string value.
-    void SetAttribute( const char* value );
-    /// Set the attribute to value.
-    void SetAttribute( int value );
-    /// Set the attribute to value.
-    void SetAttribute( unsigned value );
-	/// Set the attribute to value.
-	void SetAttribute(int64_t value);
-    /// Set the attribute to value.
-    void SetAttribute(uint64_t value);
-    /// Set the attribute to value.
-    void SetAttribute( bool value );
-    /// Set the attribute to value.
-    void SetAttribute( double value );
-    /// Set the attribute to value.
-    void SetAttribute( float value );
+/// The name of the attribute.
+const char* Name() const;
+
+/// The value of the attribute.
+const char* Value() const;
+
+/// Gets the line number the attribute is in, if the document was parsed from a file.
+int GetLineNum() const {
+  return _parseLineNum;
+}
+
+/// The next attribute in the list.
+const XMLAttribute* Next() const {
+  return _next;
+}
+
+/** IntValue interprets the attribute as an integer, and returns the value.
+    If the value isn't an integer, 0 will be returned. There is no error checking;
+    use QueryIntValue() if you need error checking.
+ */
+int     IntValue() const {
+  int i = 0;
+  QueryIntValue(&i);
+  return i;
+}
+
+int64_t Int64Value() const {
+  int64_t i = 0;
+  QueryInt64Value(&i);
+  return i;
+}
+
+uint64_t Unsigned64Value() const {
+  uint64_t i = 0;
+  QueryUnsigned64Value(&i);
+  return i;
+}
+
+/// Query as an unsigned integer. See IntValue()
+unsigned UnsignedValue() const {
+  unsigned i=0;
+  QueryUnsignedValue( &i );
+  return i;
+}
+/// Query as a boolean. See IntValue()
+bool         BoolValue() const {
+  bool b=false;
+  QueryBoolValue( &b );
+  return b;
+}
+/// Query as a double. See IntValue()
+double       DoubleValue() const {
+  double d=0;
+  QueryDoubleValue( &d );
+  return d;
+}
+/// Query as a float. See IntValue()
+float        FloatValue() const {
+  float f=0;
+  QueryFloatValue( &f );
+  return f;
+}
+
+/** QueryIntValue interprets the attribute as an integer, and returns the value
+    in the provided parameter. The function will return XML_SUCCESS on success,
+    and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.
+ */
+XMLError QueryIntValue( int* value ) const;
+/// See QueryIntValue
+XMLError QueryUnsignedValue( unsigned int* value ) const;
+/// See QueryIntValue
+XMLError QueryInt64Value(int64_t* value) const;
+/// See QueryIntValue
+XMLError QueryUnsigned64Value(uint64_t* value) const;
+/// See QueryIntValue
+XMLError QueryBoolValue( bool* value ) const;
+/// See QueryIntValue
+XMLError QueryDoubleValue( double* value ) const;
+/// See QueryIntValue
+XMLError QueryFloatValue( float* value ) const;
+
+/// Set the attribute to a string value.
+void SetAttribute( const char* value );
+/// Set the attribute to value.
+void SetAttribute( int value );
+/// Set the attribute to value.
+void SetAttribute( unsigned value );
+/// Set the attribute to value.
+void SetAttribute(int64_t value);
+/// Set the attribute to value.
+void SetAttribute(uint64_t value);
+/// Set the attribute to value.
+void SetAttribute( bool value );
+/// Set the attribute to value.
+void SetAttribute( double value );
+/// Set the attribute to value.
+void SetAttribute( float value );
 
 private:
-    enum { BUF_SIZE = 200 };
-
-    XMLAttribute() : _name(), _value(),_parseLineNum( 0 ), _next( 0 ), _memPool( 0 ) {}
-    virtual ~XMLAttribute()	{}
-
-    XMLAttribute( const XMLAttribute& );	// not supported
-    void operator=( const XMLAttribute& );	// not supported
-    void SetName( const char* name );
-
-    char* ParseDeep( char* p, bool processEntities, int* curLineNumPtr );
-
-    mutable StrPair _name;
-    mutable StrPair _value;
-    int             _parseLineNum;
-    XMLAttribute*   _next;
-    MemPool*        _memPool;
+enum { BUF_SIZE = 200 };
+
+XMLAttribute() : _name(), _value(),_parseLineNum( 0 ), _next( 0 ), _memPool( 0 ) {
+}
+virtual ~XMLAttribute()     {
+}
+
+XMLAttribute( const XMLAttribute& );            // not supported
+void operator=( const XMLAttribute& );          // not supported
+void SetName( const char* name );
+
+char* ParseDeep( char* p, bool processEntities, int* curLineNumPtr );
+
+mutable StrPair _name;
+mutable StrPair _value;
+int _parseLineNum;
+XMLAttribute*   _next;
+MemPool*        _memPool;
 };
 
 
 /** The element is a container class. It has a value, the element name,
-	and can contain other elements, text, comments, and unknowns.
-	Elements also contain an arbitrary number of attributes.
-*/
+        and can contain other elements, text, comments, and unknowns.
+        Elements also contain an arbitrary number of attributes.
+ */
 class TINYXML2_LIB XMLElement : public XMLNode
 {
-    friend class XMLDocument;
+friend class XMLDocument;
 public:
-    /// Get the name of an element (which is the Value() of the node.)
-    const char* Name() const		{
-        return Value();
+/// Get the name of an element (which is the Value() of the node.)
+const char* Name() const {
+  return Value();
+}
+/// Set the name of the element.
+void SetName( const char* str, bool staticMem=false )       {
+  SetValue( str, staticMem );
+}
+
+virtual XMLElement* ToElement() override {
+  return this;
+}
+virtual const XMLElement* ToElement() const override {
+  return this;
+}
+virtual bool Accept( XMLVisitor* visitor ) const override;
+
+/** Given an attribute name, Attribute() returns the value
+    for the attribute of that name, or null if none
+    exists. For example:
+
+    @verbatim
+    const char* value = ele->Attribute( "foo" );
+    @endverbatim
+
+    The 'value' parameter is normally null. However, if specified,
+    the attribute will only be returned if the 'name' and 'value'
+    match. This allow you to write code:
+
+    @verbatim
+    if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();
+    @endverbatim
+
+    rather than:
+    @verbatim
+    if ( ele->Attribute( "foo" ) ) {
+            if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
     }
-    /// Set the name of the element.
-    void SetName( const char* str, bool staticMem=false )	{
-        SetValue( str, staticMem );
-    }
-
-    virtual XMLElement* ToElement() override	{
-        return this;
-    }
-    virtual const XMLElement* ToElement() const override {
-        return this;
-    }
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    /** Given an attribute name, Attribute() returns the value
-    	for the attribute of that name, or null if none
-    	exists. For example:
-
-    	@verbatim
-    	const char* value = ele->Attribute( "foo" );
-    	@endverbatim
-
-    	The 'value' parameter is normally null. However, if specified,
-    	the attribute will only be returned if the 'name' and 'value'
-    	match. This allow you to write code:
-
-    	@verbatim
-    	if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();
-    	@endverbatim
-
-    	rather than:
-    	@verbatim
-    	if ( ele->Attribute( "foo" ) ) {
-    		if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
-    	}
-    	@endverbatim
-    */
-    const char* Attribute( const char* name, const char* value=0 ) const;
-
-    /** Given an attribute name, IntAttribute() returns the value
-    	of the attribute interpreted as an integer. The default
-        value will be returned if the attribute isn't present,
-        or if there is an error. (For a method with error
-    	checking, see QueryIntAttribute()).
-    */
-	int IntAttribute(const char* name, int defaultValue = 0) const;
-    /// See IntAttribute()
-	unsigned UnsignedAttribute(const char* name, unsigned defaultValue = 0) const;
-	/// See IntAttribute()
-	int64_t Int64Attribute(const char* name, int64_t defaultValue = 0) const;
-    /// See IntAttribute()
-    uint64_t Unsigned64Attribute(const char* name, uint64_t defaultValue = 0) const;
-	/// See IntAttribute()
-	bool BoolAttribute(const char* name, bool defaultValue = false) const;
-    /// See IntAttribute()
-	double DoubleAttribute(const char* name, double defaultValue = 0) const;
-    /// See IntAttribute()
-	float FloatAttribute(const char* name, float defaultValue = 0) const;
-
-    /** Given an attribute name, QueryIntAttribute() returns
-    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
-    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
-    	doesn't exist. If successful, the result of the conversion
-    	will be written to 'value'. If not successful, nothing will
-    	be written to 'value'. This allows you to provide default
-    	value:
-
-    	@verbatim
-    	int value = 10;
-    	QueryIntAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
-    	@endverbatim
-    */
-    XMLError QueryIntAttribute( const char* name, int* value ) const				{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryIntValue( value );
-    }
-
-	/// See QueryIntAttribute()
-    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const	{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryUnsignedValue( value );
-    }
-
-	/// See QueryIntAttribute()
-	XMLError QueryInt64Attribute(const char* name, int64_t* value) const {
-		const XMLAttribute* a = FindAttribute(name);
-		if (!a) {
-			return XML_NO_ATTRIBUTE;
-		}
-		return a->QueryInt64Value(value);
-	}
-
-    /// See QueryIntAttribute()
-    XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {
-        const XMLAttribute* a = FindAttribute(name);
-        if(!a) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryUnsigned64Value(value);
-    }
-
-	/// See QueryIntAttribute()
-    XMLError QueryBoolAttribute( const char* name, bool* value ) const				{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryBoolValue( value );
-    }
-    /// See QueryIntAttribute()
-    XMLError QueryDoubleAttribute( const char* name, double* value ) const			{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryDoubleValue( value );
-    }
-    /// See QueryIntAttribute()
-    XMLError QueryFloatAttribute( const char* name, float* value ) const			{
-        const XMLAttribute* a = FindAttribute( name );
-        if ( !a ) {
-            return XML_NO_ATTRIBUTE;
-        }
-        return a->QueryFloatValue( value );
-    }
-
-	/// See QueryIntAttribute()
-	XMLError QueryStringAttribute(const char* name, const char** value) const {
-		const XMLAttribute* a = FindAttribute(name);
-		if (!a) {
-			return XML_NO_ATTRIBUTE;
-		}
-		*value = a->Value();
-		return XML_SUCCESS;
-	}
-
-
-
-    /** Given an attribute name, QueryAttribute() returns
-    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
-    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
-    	doesn't exist. It is overloaded for the primitive types,
-		and is a generally more convenient replacement of
-		QueryIntAttribute() and related functions.
-
-		If successful, the result of the conversion
-    	will be written to 'value'. If not successful, nothing will
-    	be written to 'value'. This allows you to provide default
-    	value:
-
-    	@verbatim
-    	int value = 10;
-    	QueryAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
-    	@endverbatim
-    */
-	XMLError QueryAttribute( const char* name, int* value ) const {
-		return QueryIntAttribute( name, value );
-	}
-
-	XMLError QueryAttribute( const char* name, unsigned int* value ) const {
-		return QueryUnsignedAttribute( name, value );
-	}
-
-	XMLError QueryAttribute(const char* name, int64_t* value) const {
-		return QueryInt64Attribute(name, value);
-	}
-
-    XMLError QueryAttribute(const char* name, uint64_t* value) const {
-        return QueryUnsigned64Attribute(name, value);
-    }
-
-    XMLError QueryAttribute( const char* name, bool* value ) const {
-		return QueryBoolAttribute( name, value );
-	}
-
-	XMLError QueryAttribute( const char* name, double* value ) const {
-		return QueryDoubleAttribute( name, value );
-	}
-
-	XMLError QueryAttribute( const char* name, float* value ) const {
-		return QueryFloatAttribute( name, value );
-	}
-
-	XMLError QueryAttribute(const char* name, const char** value) const {
-		return QueryStringAttribute(name, value);
-	}
-
-	/// Sets the named attribute to value.
-    void SetAttribute( const char* name, const char* value )	{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, int value )			{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, unsigned value )		{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-
-	/// Sets the named attribute to value.
-	void SetAttribute(const char* name, int64_t value) {
-		XMLAttribute* a = FindOrCreateAttribute(name);
-		a->SetAttribute(value);
-	}
-
-    /// Sets the named attribute to value.
-    void SetAttribute(const char* name, uint64_t value) {
-        XMLAttribute* a = FindOrCreateAttribute(name);
-        a->SetAttribute(value);
-    }
-
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, bool value )			{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, double value )		{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-    /// Sets the named attribute to value.
-    void SetAttribute( const char* name, float value )		{
-        XMLAttribute* a = FindOrCreateAttribute( name );
-        a->SetAttribute( value );
-    }
-
-    /**
-    	Delete an attribute.
-    */
-    void DeleteAttribute( const char* name );
-
-    /// Return the first attribute in the list.
-    const XMLAttribute* FirstAttribute() const {
-        return _rootAttribute;
-    }
-    /// Query a specific attribute in the list.
-    const XMLAttribute* FindAttribute( const char* name ) const;
-
-    /** Convenience function for easy access to the text inside an element. Although easy
-    	and concise, GetText() is limited compared to getting the XMLText child
-    	and accessing it directly.
-
-    	If the first child of 'this' is a XMLText, the GetText()
-    	returns the character string of the Text node, else null is returned.
-
-    	This is a convenient method for getting the text of simple contained text:
-    	@verbatim
-    	<foo>This is text</foo>
-    		const char* str = fooElement->GetText();
-    	@endverbatim
-
-    	'str' will be a pointer to "This is text".
-
-    	Note that this function can be misleading. If the element foo was created from
-    	this XML:
-    	@verbatim
-    		<foo><b>This is text</b></foo>
-    	@endverbatim
-
-    	then the value of str would be null. The first child node isn't a text node, it is
-    	another element. From this XML:
-    	@verbatim
-    		<foo>This is <b>text</b></foo>
-    	@endverbatim
-    	GetText() will return "This is ".
-    */
-    const char* GetText() const;
-
-    /** Convenience function for easy access to the text inside an element. Although easy
-    	and concise, SetText() is limited compared to creating an XMLText child
-    	and mutating it directly.
-
-    	If the first child of 'this' is a XMLText, SetText() sets its value to
-		the given string, otherwise it will create a first child that is an XMLText.
-
-    	This is a convenient method for setting the text of simple contained text:
-    	@verbatim
-    	<foo>This is text</foo>
-    		fooElement->SetText( "Hullaballoo!" );
-     	<foo>Hullaballoo!</foo>
-		@endverbatim
-
-    	Note that this function can be misleading. If the element foo was created from
-    	this XML:
-    	@verbatim
-    		<foo><b>This is text</b></foo>
-    	@endverbatim
-
-    	then it will not change "This is text", but rather prefix it with a text element:
-    	@verbatim
-    		<foo>Hullaballoo!<b>This is text</b></foo>
-    	@endverbatim
-
-		For this XML:
-    	@verbatim
-    		<foo />
-    	@endverbatim
-    	SetText() will generate
-    	@verbatim
-    		<foo>Hullaballoo!</foo>
-    	@endverbatim
-    */
-	void SetText( const char* inText );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( int value );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( unsigned value );
-	/// Convenience method for setting text inside an element. See SetText() for important limitations.
-	void SetText(int64_t value);
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText(uint64_t value);
-	/// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( bool value );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( double value );
-    /// Convenience method for setting text inside an element. See SetText() for important limitations.
-    void SetText( float value );
-
-    /**
-    	Convenience method to query the value of a child text node. This is probably best
-    	shown by example. Given you have a document is this form:
-    	@verbatim
-    		<point>
-    			<x>1</x>
-    			<y>1.4</y>
-    		</point>
-    	@endverbatim
-
-    	The QueryIntText() and similar functions provide a safe and easier way to get to the
-    	"value" of x and y.
-
-    	@verbatim
-    		int x = 0;
-    		float y = 0;	// types of x and y are contrived for example
-    		const XMLElement* xElement = pointElement->FirstChildElement( "x" );
-    		const XMLElement* yElement = pointElement->FirstChildElement( "y" );
-    		xElement->QueryIntText( &x );
-    		yElement->QueryFloatText( &y );
-    	@endverbatim
-
-    	@returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted
-    			 to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.
-
-    */
-    XMLError QueryIntText( int* ival ) const;
-    /// See QueryIntText()
-    XMLError QueryUnsignedText( unsigned* uval ) const;
-	/// See QueryIntText()
-	XMLError QueryInt64Text(int64_t* uval) const;
-	/// See QueryIntText()
-	XMLError QueryUnsigned64Text(uint64_t* uval) const;
-	/// See QueryIntText()
-    XMLError QueryBoolText( bool* bval ) const;
-    /// See QueryIntText()
-    XMLError QueryDoubleText( double* dval ) const;
-    /// See QueryIntText()
-    XMLError QueryFloatText( float* fval ) const;
-
-	int IntText(int defaultValue = 0) const;
-
-	/// See QueryIntText()
-	unsigned UnsignedText(unsigned defaultValue = 0) const;
-	/// See QueryIntText()
-	int64_t Int64Text(int64_t defaultValue = 0) const;
-    /// See QueryIntText()
-    uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;
-	/// See QueryIntText()
-	bool BoolText(bool defaultValue = false) const;
-	/// See QueryIntText()
-	double DoubleText(double defaultValue = 0) const;
-	/// See QueryIntText()
-    float FloatText(float defaultValue = 0) const;
-
-    /**
-        Convenience method to create a new XMLElement and add it as last (right)
-        child of this node. Returns the created and inserted element.
-    */
-    XMLElement* InsertNewChildElement(const char* name);
-    /// See InsertNewChildElement()
-    XMLComment* InsertNewComment(const char* comment);
-    /// See InsertNewChildElement()
-    XMLText* InsertNewText(const char* text);
-    /// See InsertNewChildElement()
-    XMLDeclaration* InsertNewDeclaration(const char* text);
-    /// See InsertNewChildElement()
-    XMLUnknown* InsertNewUnknown(const char* text);
-
-
-    // internal:
-    enum ElementClosingType {
-        OPEN,		// <foo>
-        CLOSED,		// <foo/>
-        CLOSING		// </foo>
-    };
-    ElementClosingType ClosingType() const {
-        return _closingType;
-    }
-    virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
-    virtual bool ShallowEqual( const XMLNode* compare ) const override;
+    @endverbatim
+ */
+const char* Attribute( const char* name, const char* value=0 ) const;
+
+/** Given an attribute name, IntAttribute() returns the value
+    of the attribute interpreted as an integer. The default
+    value will be returned if the attribute isn't present,
+    or if there is an error. (For a method with error
+    checking, see QueryIntAttribute()).
+ */
+int IntAttribute(const char* name, int defaultValue = 0) const;
+/// See IntAttribute()
+unsigned UnsignedAttribute(const char* name, unsigned defaultValue = 0) const;
+/// See IntAttribute()
+int64_t Int64Attribute(const char* name, int64_t defaultValue = 0) const;
+/// See IntAttribute()
+uint64_t Unsigned64Attribute(const char* name, uint64_t defaultValue = 0) const;
+/// See IntAttribute()
+bool BoolAttribute(const char* name, bool defaultValue = false) const;
+/// See IntAttribute()
+double DoubleAttribute(const char* name, double defaultValue = 0) const;
+/// See IntAttribute()
+float FloatAttribute(const char* name, float defaultValue = 0) const;
+
+/** Given an attribute name, QueryIntAttribute() returns
+    XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
+    can't be performed, or XML_NO_ATTRIBUTE if the attribute
+    doesn't exist. If successful, the result of the conversion
+    will be written to 'value'. If not successful, nothing will
+    be written to 'value'. This allows you to provide default
+    value:
+
+    @verbatim
+    int value = 10;
+    QueryIntAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
+    @endverbatim
+ */
+XMLError QueryIntAttribute( const char* name, int* value ) const {
+  const XMLAttribute* a = FindAttribute( name );
+  if ( !a ) {
+    return XML_NO_ATTRIBUTE;
+  }
+  return a->QueryIntValue( value );
+}
+
+/// See QueryIntAttribute()
+XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const {
+  const XMLAttribute* a = FindAttribute( name );
+  if ( !a ) {
+    return XML_NO_ATTRIBUTE;
+  }
+  return a->QueryUnsignedValue( value );
+}
+
+/// See QueryIntAttribute()
+XMLError QueryInt64Attribute(const char* name, int64_t* value) const {
+  const XMLAttribute* a = FindAttribute(name);
+  if (!a) {
+    return XML_NO_ATTRIBUTE;
+  }
+  return a->QueryInt64Value(value);
+}
+
+/// See QueryIntAttribute()
+XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {
+  const XMLAttribute* a = FindAttribute(name);
+  if(!a) {
+    return XML_NO_ATTRIBUTE;
+  }
+  return a->QueryUnsigned64Value(value);
+}
+
+/// See QueryIntAttribute()
+XMLError QueryBoolAttribute( const char* name, bool* value ) const {
+  const XMLAttribute* a = FindAttribute( name );
+  if ( !a ) {
+    return XML_NO_ATTRIBUTE;
+  }
+  return a->QueryBoolValue( value );
+}
+/// See QueryIntAttribute()
+XMLError QueryDoubleAttribute( const char* name, double* value ) const {
+  const XMLAttribute* a = FindAttribute( name );
+  if ( !a ) {
+    return XML_NO_ATTRIBUTE;
+  }
+  return a->QueryDoubleValue( value );
+}
+/// See QueryIntAttribute()
+XMLError QueryFloatAttribute( const char* name, float* value ) const {
+  const XMLAttribute* a = FindAttribute( name );
+  if ( !a ) {
+    return XML_NO_ATTRIBUTE;
+  }
+  return a->QueryFloatValue( value );
+}
+
+/// See QueryIntAttribute()
+XMLError QueryStringAttribute(const char* name, const char** value) const {
+  const XMLAttribute* a = FindAttribute(name);
+  if (!a) {
+    return XML_NO_ATTRIBUTE;
+  }
+  *value = a->Value();
+  return XML_SUCCESS;
+}
+
+
+
+/** Given an attribute name, QueryAttribute() returns
+    XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
+    can't be performed, or XML_NO_ATTRIBUTE if the attribute
+    doesn't exist. It is overloaded for the primitive types,
+            and is a generally more convenient replacement of
+            QueryIntAttribute() and related functions.
+
+            If successful, the result of the conversion
+    will be written to 'value'. If not successful, nothing will
+    be written to 'value'. This allows you to provide default
+    value:
+
+    @verbatim
+    int value = 10;
+    QueryAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
+    @endverbatim
+ */
+XMLError QueryAttribute( const char* name, int* value ) const {
+  return QueryIntAttribute( name, value );
+}
+
+XMLError QueryAttribute( const char* name, unsigned int* value ) const {
+  return QueryUnsignedAttribute( name, value );
+}
+
+XMLError QueryAttribute(const char* name, int64_t* value) const {
+  return QueryInt64Attribute(name, value);
+}
+
+XMLError QueryAttribute(const char* name, uint64_t* value) const {
+  return QueryUnsigned64Attribute(name, value);
+}
+
+XMLError QueryAttribute( const char* name, bool* value ) const {
+  return QueryBoolAttribute( name, value );
+}
+
+XMLError QueryAttribute( const char* name, double* value ) const {
+  return QueryDoubleAttribute( name, value );
+}
+
+XMLError QueryAttribute( const char* name, float* value ) const {
+  return QueryFloatAttribute( name, value );
+}
+
+XMLError QueryAttribute(const char* name, const char** value) const {
+  return QueryStringAttribute(name, value);
+}
+
+/// Sets the named attribute to value.
+void SetAttribute( const char* name, const char* value )    {
+  XMLAttribute* a = FindOrCreateAttribute( name );
+  a->SetAttribute( value );
+}
+/// Sets the named attribute to value.
+void SetAttribute( const char* name, int value )                    {
+  XMLAttribute* a = FindOrCreateAttribute( name );
+  a->SetAttribute( value );
+}
+/// Sets the named attribute to value.
+void SetAttribute( const char* name, unsigned value )               {
+  XMLAttribute* a = FindOrCreateAttribute( name );
+  a->SetAttribute( value );
+}
+
+/// Sets the named attribute to value.
+void SetAttribute(const char* name, int64_t value) {
+  XMLAttribute* a = FindOrCreateAttribute(name);
+  a->SetAttribute(value);
+}
+
+/// Sets the named attribute to value.
+void SetAttribute(const char* name, uint64_t value) {
+  XMLAttribute* a = FindOrCreateAttribute(name);
+  a->SetAttribute(value);
+}
+
+/// Sets the named attribute to value.
+void SetAttribute( const char* name, bool value )                   {
+  XMLAttribute* a = FindOrCreateAttribute( name );
+  a->SetAttribute( value );
+}
+/// Sets the named attribute to value.
+void SetAttribute( const char* name, double value )         {
+  XMLAttribute* a = FindOrCreateAttribute( name );
+  a->SetAttribute( value );
+}
+/// Sets the named attribute to value.
+void SetAttribute( const char* name, float value )          {
+  XMLAttribute* a = FindOrCreateAttribute( name );
+  a->SetAttribute( value );
+}
+
+/**
+    Delete an attribute.
+ */
+void DeleteAttribute( const char* name );
+
+/// Return the first attribute in the list.
+const XMLAttribute* FirstAttribute() const {
+  return _rootAttribute;
+}
+/// Query a specific attribute in the list.
+const XMLAttribute* FindAttribute( const char* name ) const;
+
+/** Convenience function for easy access to the text inside an element. Although easy
+    and concise, GetText() is limited compared to getting the XMLText child
+    and accessing it directly.
+
+    If the first child of 'this' is a XMLText, the GetText()
+    returns the character string of the Text node, else null is returned.
+
+    This is a convenient method for getting the text of simple contained text:
+    @verbatim
+    <foo>This is text</foo>
+            const char* str = fooElement->GetText();
+    @endverbatim
+
+    'str' will be a pointer to "This is text".
+
+    Note that this function can be misleading. If the element foo was created from
+    this XML:
+    @verbatim
+            <foo><b>This is text</b></foo>
+    @endverbatim
+
+    then the value of str would be null. The first child node isn't a text node, it is
+    another element. From this XML:
+    @verbatim
+            <foo>This is <b>text</b></foo>
+    @endverbatim
+    GetText() will return "This is ".
+ */
+const char* GetText() const;
+
+/** Convenience function for easy access to the text inside an element. Although easy
+    and concise, SetText() is limited compared to creating an XMLText child
+    and mutating it directly.
+
+    If the first child of 'this' is a XMLText, SetText() sets its value to
+            the given string, otherwise it will create a first child that is an XMLText.
+
+    This is a convenient method for setting the text of simple contained text:
+    @verbatim
+    <foo>This is text</foo>
+            fooElement->SetText( "Hullaballoo!" );
+    <foo>Hullaballoo!</foo>
+            @endverbatim
+
+    Note that this function can be misleading. If the element foo was created from
+    this XML:
+    @verbatim
+            <foo><b>This is text</b></foo>
+    @endverbatim
+
+    then it will not change "This is text", but rather prefix it with a text element:
+    @verbatim
+            <foo>Hullaballoo!<b>This is text</b></foo>
+    @endverbatim
+
+            For this XML:
+    @verbatim
+            <foo />
+    @endverbatim
+    SetText() will generate
+    @verbatim
+            <foo>Hullaballoo!</foo>
+    @endverbatim
+ */
+void SetText( const char* inText );
+/// Convenience method for setting text inside an element. See SetText() for important limitations.
+void SetText( int value );
+/// Convenience method for setting text inside an element. See SetText() for important limitations.
+void SetText( unsigned value );
+/// Convenience method for setting text inside an element. See SetText() for important limitations.
+void SetText(int64_t value);
+/// Convenience method for setting text inside an element. See SetText() for important limitations.
+void SetText(uint64_t value);
+/// Convenience method for setting text inside an element. See SetText() for important limitations.
+void SetText( bool value );
+/// Convenience method for setting text inside an element. See SetText() for important limitations.
+void SetText( double value );
+/// Convenience method for setting text inside an element. See SetText() for important limitations.
+void SetText( float value );
+
+/**
+    Convenience method to query the value of a child text node. This is probably best
+    shown by example. Given you have a document is this form:
+    @verbatim
+            <point>
+                    <x>1</x>
+                    <y>1.4</y>
+            </point>
+    @endverbatim
+
+    The QueryIntText() and similar functions provide a safe and easier way to get to the
+    "value" of x and y.
+
+    @verbatim
+            int x = 0;
+            float y = 0;	// types of x and y are contrived for example
+            const XMLElement* xElement = pointElement->FirstChildElement( "x" );
+            const XMLElement* yElement = pointElement->FirstChildElement( "y" );
+            xElement->QueryIntText( &x );
+            yElement->QueryFloatText( &y );
+    @endverbatim
+
+    @returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted
+                     to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.
+
+ */
+XMLError QueryIntText( int* ival ) const;
+/// See QueryIntText()
+XMLError QueryUnsignedText( unsigned* uval ) const;
+/// See QueryIntText()
+XMLError QueryInt64Text(int64_t* uval) const;
+/// See QueryIntText()
+XMLError QueryUnsigned64Text(uint64_t* uval) const;
+/// See QueryIntText()
+XMLError QueryBoolText( bool* bval ) const;
+/// See QueryIntText()
+XMLError QueryDoubleText( double* dval ) const;
+/// See QueryIntText()
+XMLError QueryFloatText( float* fval ) const;
+
+int IntText(int defaultValue = 0) const;
+
+/// See QueryIntText()
+unsigned UnsignedText(unsigned defaultValue = 0) const;
+/// See QueryIntText()
+int64_t Int64Text(int64_t defaultValue = 0) const;
+/// See QueryIntText()
+uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;
+/// See QueryIntText()
+bool BoolText(bool defaultValue = false) const;
+/// See QueryIntText()
+double DoubleText(double defaultValue = 0) const;
+/// See QueryIntText()
+float FloatText(float defaultValue = 0) const;
+
+/**
+    Convenience method to create a new XMLElement and add it as last (right)
+    child of this node. Returns the created and inserted element.
+ */
+XMLElement* InsertNewChildElement(const char* name);
+/// See InsertNewChildElement()
+XMLComment* InsertNewComment(const char* comment);
+/// See InsertNewChildElement()
+XMLText* InsertNewText(const char* text);
+/// See InsertNewChildElement()
+XMLDeclaration* InsertNewDeclaration(const char* text);
+/// See InsertNewChildElement()
+XMLUnknown* InsertNewUnknown(const char* text);
+
+
+// internal:
+enum ElementClosingType {
+  OPEN,                 // <foo>
+  CLOSED,               // <foo/>
+  CLOSING               // </foo>
+};
+ElementClosingType ClosingType() const {
+  return _closingType;
+}
+virtual XMLNode* ShallowClone( XMLDocument* document ) const override;
+virtual bool ShallowEqual( const XMLNode* compare ) const override;
 
 protected:
-    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
+char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr ) override;
 
 private:
-    XMLElement( XMLDocument* doc );
-    virtual ~XMLElement();
-    XMLElement( const XMLElement& );	// not supported
-    void operator=( const XMLElement& );	// not supported
-
-    XMLAttribute* FindOrCreateAttribute( const char* name );
-    char* ParseAttributes( char* p, int* curLineNumPtr );
-    static void DeleteAttribute( XMLAttribute* attribute );
-    XMLAttribute* CreateAttribute();
-
-    enum { BUF_SIZE = 200 };
-    ElementClosingType _closingType;
-    // The attribute list is ordered; there is no 'lastAttribute'
-    // because the list needs to be scanned for dupes before adding
-    // a new attribute.
-    XMLAttribute* _rootAttribute;
+XMLElement( XMLDocument* doc );
+virtual ~XMLElement();
+XMLElement( const XMLElement& );        // not supported
+void operator=( const XMLElement& );            // not supported
+
+XMLAttribute* FindOrCreateAttribute( const char* name );
+char* ParseAttributes( char* p, int* curLineNumPtr );
+static void DeleteAttribute( XMLAttribute* attribute );
+XMLAttribute* CreateAttribute();
+
+enum { BUF_SIZE = 200 };
+ElementClosingType _closingType;
+// The attribute list is ordered; there is no 'lastAttribute'
+// because the list needs to be scanned for dupes before adding
+// a new attribute.
+XMLAttribute* _rootAttribute;
 };
 
 
 enum Whitespace {
-    PRESERVE_WHITESPACE,
-    COLLAPSE_WHITESPACE,
-    PEDANTIC_WHITESPACE
+  PRESERVE_WHITESPACE,
+  COLLAPSE_WHITESPACE,
+  PEDANTIC_WHITESPACE
 };
 
 
 /** A Document binds together all the functionality.
-	It can be saved, loaded, and printed to the screen.
-	All Nodes are connected and allocated to a Document.
-	If the Document is deleted, all its Nodes are also deleted.
-*/
+        It can be saved, loaded, and printed to the screen.
+        All Nodes are connected and allocated to a Document.
+        If the Document is deleted, all its Nodes are also deleted.
+ */
 class TINYXML2_LIB XMLDocument : public XMLNode
 {
-    friend class XMLElement;
-    // Gives access to SetError and Push/PopDepth, but over-access for everything else.
-    // Wishing C++ had "internal" scope.
-    friend class XMLNode;
-    friend class XMLText;
-    friend class XMLComment;
-    friend class XMLDeclaration;
-    friend class XMLUnknown;
+friend class XMLElement;
+// Gives access to SetError and Push/PopDepth, but over-access for everything else.
+// Wishing C++ had "internal" scope.
+friend class XMLNode;
+friend class XMLText;
+friend class XMLComment;
+friend class XMLDeclaration;
+friend class XMLUnknown;
 public:
-    /// constructor
-    XMLDocument( bool processEntities = true, Whitespace whitespaceMode = PRESERVE_WHITESPACE );
-    ~XMLDocument();
-
-    virtual XMLDocument* ToDocument() override		{
-        TIXMLASSERT( this == _document );
-        return this;
-    }
-    virtual const XMLDocument* ToDocument() const override {
-        TIXMLASSERT( this == _document );
-        return this;
-    }
-
-    /**
-    	Parse an XML file from a character string.
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-
-    	You may optionally pass in the 'nBytes', which is
-    	the number of bytes which will be parsed. If not
-    	specified, TinyXML-2 will assume 'xml' points to a
-    	null terminated string.
-    */
-    XMLError Parse( const char* xml, size_t nBytes=static_cast<size_t>(-1) );
-
-    /**
-    	Load an XML file from disk.
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError LoadFile( const char* filename );
-
-    /**
-    	Load an XML file from disk. You are responsible
-    	for providing and closing the FILE*.
-
-        NOTE: The file should be opened as binary ("rb")
-        not text in order for TinyXML-2 to correctly
-        do newline normalization.
-
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError LoadFile( FILE* );
-
-    /**
-    	Save the XML file to disk.
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError SaveFile( const char* filename, bool compact = false );
-
-    /**
-    	Save the XML file to disk. You are responsible
-    	for providing and closing the FILE*.
-
-    	Returns XML_SUCCESS (0) on success, or
-    	an errorID.
-    */
-    XMLError SaveFile( FILE* fp, bool compact = false );
-
-    bool ProcessEntities() const		{
-        return _processEntities;
-    }
-    Whitespace WhitespaceMode() const	{
-        return _whitespaceMode;
-    }
-
-    /**
-    	Returns true if this document has a leading Byte Order Mark of UTF8.
-    */
-    bool HasBOM() const {
-        return _writeBOM;
-    }
-    /** Sets whether to write the BOM when writing the file.
-    */
-    void SetBOM( bool useBOM ) {
-        _writeBOM = useBOM;
-    }
-
-    /** Return the root element of DOM. Equivalent to FirstChildElement().
-        To get the first node, use FirstChild().
-    */
-    XMLElement* RootElement()				{
-        return FirstChildElement();
-    }
-    const XMLElement* RootElement() const	{
-        return FirstChildElement();
-    }
-
-    /** Print the Document. If the Printer is not provided, it will
-        print to stdout. If you provide Printer, this can print to a file:
-    	@verbatim
-    	XMLPrinter printer( fp );
-    	doc.Print( &printer );
-    	@endverbatim
-
-    	Or you can use a printer to print to memory:
-    	@verbatim
-    	XMLPrinter printer;
-    	doc.Print( &printer );
-    	// printer.CStr() has a const char* to the XML
-    	@endverbatim
-    */
-    void Print( XMLPrinter* streamer=0 ) const;
-    virtual bool Accept( XMLVisitor* visitor ) const override;
-
-    /**
-    	Create a new Element associated with
-    	this Document. The memory for the Element
-    	is managed by the Document.
-    */
-    XMLElement* NewElement( const char* name );
-    /**
-    	Create a new Comment associated with
-    	this Document. The memory for the Comment
-    	is managed by the Document.
-    */
-    XMLComment* NewComment( const char* comment );
-    /**
-    	Create a new Text associated with
-    	this Document. The memory for the Text
-    	is managed by the Document.
-    */
-    XMLText* NewText( const char* text );
-    /**
-    	Create a new Declaration associated with
-    	this Document. The memory for the object
-    	is managed by the Document.
-
-    	If the 'text' param is null, the standard
-    	declaration is used.:
-    	@verbatim
-    		<?xml version="1.0" encoding="UTF-8"?>
-    	@endverbatim
-    */
-    XMLDeclaration* NewDeclaration( const char* text=0 );
-    /**
-    	Create a new Unknown associated with
-    	this Document. The memory for the object
-    	is managed by the Document.
-    */
-    XMLUnknown* NewUnknown( const char* text );
-
-    /**
-    	Delete a node associated with this document.
-    	It will be unlinked from the DOM.
-    */
-    void DeleteNode( XMLNode* node );
-
-    /// Clears the error flags.
-    void ClearError();
-
-    /// Return true if there was an error parsing the document.
-    bool Error() const {
-        return _errorID != XML_SUCCESS;
-    }
-    /// Return the errorID.
-    XMLError  ErrorID() const {
-        return _errorID;
-    }
-	const char* ErrorName() const;
-    static const char* ErrorIDToName(XMLError errorID);
-
-    /** Returns a "long form" error description. A hopefully helpful
-        diagnostic with location, line number, and/or additional info.
-    */
-	const char* ErrorStr() const;
-
-    /// A (trivial) utility function that prints the ErrorStr() to stdout.
-    void PrintError() const;
-
-    /// Return the line where the error occurred, or zero if unknown.
-    int ErrorLineNum() const
-    {
-        return _errorLineNum;
-    }
-
-    /// Clear the document, resetting it to the initial state.
-    void Clear();
-
-	/**
-		Copies this document to a target document.
-		The target will be completely cleared before the copy.
-		If you want to copy a sub-tree, see XMLNode::DeepClone().
-
-		NOTE: that the 'target' must be non-null.
-	*/
-	void DeepCopy(XMLDocument* target) const;
-
-	// internal
-    char* Identify( char* p, XMLNode** node, bool first );
-
-	// internal
-	void MarkInUse(const XMLNode* const);
-
-    virtual XMLNode* ShallowClone( XMLDocument* /*document*/ ) const override{
-        return 0;
-    }
-    virtual bool ShallowEqual( const XMLNode* /*compare*/ ) const override{
-        return false;
-    }
+/// constructor
+XMLDocument( bool processEntities = true, Whitespace whitespaceMode = PRESERVE_WHITESPACE );
+~XMLDocument();
+
+virtual XMLDocument* ToDocument() override {
+  TIXMLASSERT( this == _document );
+  return this;
+}
+virtual const XMLDocument* ToDocument() const override {
+  TIXMLASSERT( this == _document );
+  return this;
+}
+
+/**
+    Parse an XML file from a character string.
+    Returns XML_SUCCESS (0) on success, or
+    an errorID.
+
+    You may optionally pass in the 'nBytes', which is
+    the number of bytes which will be parsed. If not
+    specified, TinyXML-2 will assume 'xml' points to a
+    null terminated string.
+ */
+XMLError Parse( const char* xml, size_t nBytes=static_cast<size_t>(-1) );
+
+/**
+    Load an XML file from disk.
+    Returns XML_SUCCESS (0) on success, or
+    an errorID.
+ */
+XMLError LoadFile( const char* filename );
+
+/**
+    Load an XML file from disk. You are responsible
+    for providing and closing the FILE*.
+
+    NOTE: The file should be opened as binary ("rb")
+    not text in order for TinyXML-2 to correctly
+    do newline normalization.
+
+    Returns XML_SUCCESS (0) on success, or
+    an errorID.
+ */
+XMLError LoadFile( FILE* );
+
+/**
+    Save the XML file to disk.
+    Returns XML_SUCCESS (0) on success, or
+    an errorID.
+ */
+XMLError SaveFile( const char* filename, bool compact = false );
+
+/**
+    Save the XML file to disk. You are responsible
+    for providing and closing the FILE*.
+
+    Returns XML_SUCCESS (0) on success, or
+    an errorID.
+ */
+XMLError SaveFile( FILE* fp, bool compact = false );
+
+bool ProcessEntities() const {
+  return _processEntities;
+}
+Whitespace WhitespaceMode() const {
+  return _whitespaceMode;
+}
+
+/**
+    Returns true if this document has a leading Byte Order Mark of UTF8.
+ */
+bool HasBOM() const {
+  return _writeBOM;
+}
+/** Sets whether to write the BOM when writing the file.
+ */
+void SetBOM( bool useBOM ) {
+  _writeBOM = useBOM;
+}
+
+/** Return the root element of DOM. Equivalent to FirstChildElement().
+    To get the first node, use FirstChild().
+ */
+XMLElement* RootElement()                           {
+  return FirstChildElement();
+}
+const XMLElement* RootElement() const {
+  return FirstChildElement();
+}
+
+/** Print the Document. If the Printer is not provided, it will
+    print to stdout. If you provide Printer, this can print to a file:
+    @verbatim
+    XMLPrinter printer( fp );
+    doc.Print( &printer );
+    @endverbatim
+
+    Or you can use a printer to print to memory:
+    @verbatim
+    XMLPrinter printer;
+    doc.Print( &printer );
+    // printer.CStr() has a const char* to the XML
+    @endverbatim
+ */
+void Print( XMLPrinter* streamer=0 ) const;
+virtual bool Accept( XMLVisitor* visitor ) const override;
+
+/**
+    Create a new Element associated with
+    this Document. The memory for the Element
+    is managed by the Document.
+ */
+XMLElement* NewElement( const char* name );
+/**
+    Create a new Comment associated with
+    this Document. The memory for the Comment
+    is managed by the Document.
+ */
+XMLComment* NewComment( const char* comment );
+/**
+    Create a new Text associated with
+    this Document. The memory for the Text
+    is managed by the Document.
+ */
+XMLText* NewText( const char* text );
+/**
+    Create a new Declaration associated with
+    this Document. The memory for the object
+    is managed by the Document.
+
+    If the 'text' param is null, the standard
+    declaration is used.:
+    @verbatim
+            <?xml version="1.0" encoding="UTF-8"?>
+    @endverbatim
+ */
+XMLDeclaration* NewDeclaration( const char* text=0 );
+/**
+    Create a new Unknown associated with
+    this Document. The memory for the object
+    is managed by the Document.
+ */
+XMLUnknown* NewUnknown( const char* text );
+
+/**
+    Delete a node associated with this document.
+    It will be unlinked from the DOM.
+ */
+void DeleteNode( XMLNode* node );
+
+/// Clears the error flags.
+void ClearError();
+
+/// Return true if there was an error parsing the document.
+bool Error() const {
+  return _errorID != XML_SUCCESS;
+}
+/// Return the errorID.
+XMLError  ErrorID() const {
+  return _errorID;
+}
+const char* ErrorName() const;
+static const char* ErrorIDToName(XMLError errorID);
+
+/** Returns a "long form" error description. A hopefully helpful
+    diagnostic with location, line number, and/or additional info.
+ */
+const char* ErrorStr() const;
+
+/// A (trivial) utility function that prints the ErrorStr() to stdout.
+void PrintError() const;
+
+/// Return the line where the error occurred, or zero if unknown.
+int ErrorLineNum() const
+{
+  return _errorLineNum;
+}
+
+/// Clear the document, resetting it to the initial state.
+void Clear();
+
+/**
+        Copies this document to a target document.
+        The target will be completely cleared before the copy.
+        If you want to copy a sub-tree, see XMLNode::DeepClone().
+
+        NOTE: that the 'target' must be non-null.
+ */
+void DeepCopy(XMLDocument* target) const;
+
+// internal
+char* Identify( char* p, XMLNode** node, bool first );
+
+// internal
+void MarkInUse(const XMLNode* const);
+
+virtual XMLNode* ShallowClone( XMLDocument* /*document*/ ) const override {
+  return 0;
+}
+virtual bool ShallowEqual( const XMLNode* /*compare*/ ) const override {
+  return false;
+}
 
 private:
-    XMLDocument( const XMLDocument& );	// not supported
-    void operator=( const XMLDocument& );	// not supported
-
-    bool			_writeBOM;
-    bool			_processEntities;
-    XMLError		_errorID;
-    Whitespace		_whitespaceMode;
-    mutable StrPair	_errorStr;
-    int             _errorLineNum;
-    char*			_charBuffer;
-    int				_parseCurLineNum;
-	int				_parsingDepth;
-	// Memory tracking does add some overhead.
-	// However, the code assumes that you don't
-	// have a bunch of unlinked nodes around.
-	// Therefore it takes less memory to track
-	// in the document vs. a linked list in the XMLNode,
-	// and the performance is the same.
-	DynArray<XMLNode*, 10> _unlinked;
-
-    MemPoolT< sizeof(XMLElement) >	 _elementPool;
-    MemPoolT< sizeof(XMLAttribute) > _attributePool;
-    MemPoolT< sizeof(XMLText) >		 _textPool;
-    MemPoolT< sizeof(XMLComment) >	 _commentPool;
-
-	static const char* _errorNames[XML_ERROR_COUNT];
-
-    void Parse();
-
-    void SetError( XMLError error, int lineNum, const char* format, ... );
-
-	// Something of an obvious security hole, once it was discovered.
-	// Either an ill-formed XML or an excessively deep one can overflow
-	// the stack. Track stack depth, and error out if needed.
-	class DepthTracker {
-	public:
-		explicit DepthTracker(XMLDocument * document) {
-			this->_document = document;
-			document->PushDepth();
-		}
-		~DepthTracker() {
-			_document->PopDepth();
-		}
-	private:
-		XMLDocument * _document;
-	};
-	void PushDepth();
-	void PopDepth();
-
-    template<class NodeType, size_t PoolElementSize>
-    NodeType* CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool );
+XMLDocument( const XMLDocument& );      // not supported
+void operator=( const XMLDocument& );           // not supported
+
+bool _writeBOM;
+bool _processEntities;
+XMLError _errorID;
+Whitespace _whitespaceMode;
+mutable StrPair _errorStr;
+int _errorLineNum;
+char*                       _charBuffer;
+int _parseCurLineNum;
+int _parsingDepth;
+// Memory tracking does add some overhead.
+// However, the code assumes that you don't
+// have a bunch of unlinked nodes around.
+// Therefore it takes less memory to track
+// in the document vs. a linked list in the XMLNode,
+// and the performance is the same.
+DynArray<XMLNode*, 10> _unlinked;
+
+MemPoolT< sizeof(XMLElement) >       _elementPool;
+MemPoolT< sizeof(XMLAttribute) > _attributePool;
+MemPoolT< sizeof(XMLText) >          _textPool;
+MemPoolT< sizeof(XMLComment) >       _commentPool;
+
+static const char* _errorNames[XML_ERROR_COUNT];
+
+void Parse();
+
+void SetError( XMLError error, int lineNum, const char* format, ... );
+
+// Something of an obvious security hole, once it was discovered.
+// Either an ill-formed XML or an excessively deep one can overflow
+// the stack. Track stack depth, and error out if needed.
+class DepthTracker {
+public:
+explicit DepthTracker(XMLDocument * document) {
+  this->_document = document;
+  document->PushDepth();
+}
+~DepthTracker() {
+  _document->PopDepth();
+}
+private:
+XMLDocument * _document;
+};
+void PushDepth();
+void PopDepth();
+
+template<class NodeType, size_t PoolElementSize>
+NodeType* CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool );
 };
 
 template<class NodeType, size_t PoolElementSize>
 inline NodeType* XMLDocument::CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool )
 {
-    TIXMLASSERT( sizeof( NodeType ) == PoolElementSize );
-    TIXMLASSERT( sizeof( NodeType ) == pool.ItemSize() );
-    NodeType* returnNode = new (pool.Alloc()) NodeType( this );
-    TIXMLASSERT( returnNode );
-    returnNode->_memPool = &pool;
-
-	_unlinked.Push(returnNode);
-    return returnNode;
-}
-
-/**
-	A XMLHandle is a class that wraps a node pointer with null checks; this is
-	an incredibly useful thing. Note that XMLHandle is not part of the TinyXML-2
-	DOM structure. It is a separate utility class.
-
-	Take an example:
-	@verbatim
-	<Document>
-		<Element attributeA = "valueA">
-			<Child attributeB = "value1" />
-			<Child attributeB = "value2" />
-		</Element>
-	</Document>
-	@endverbatim
-
-	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
-	easy to write a *lot* of code that looks like:
-
-	@verbatim
-	XMLElement* root = document.FirstChildElement( "Document" );
-	if ( root )
-	{
-		XMLElement* element = root->FirstChildElement( "Element" );
-		if ( element )
-		{
-			XMLElement* child = element->FirstChildElement( "Child" );
-			if ( child )
-			{
-				XMLElement* child2 = child->NextSiblingElement( "Child" );
-				if ( child2 )
-				{
-					// Finally do something useful.
-	@endverbatim
-
-	And that doesn't even cover "else" cases. XMLHandle addresses the verbosity
-	of such code. A XMLHandle checks for null pointers so it is perfectly safe
-	and correct to use:
-
-	@verbatim
-	XMLHandle docHandle( &document );
-	XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();
-	if ( child2 )
-	{
-		// do something useful
-	@endverbatim
-
-	Which is MUCH more concise and useful.
-
-	It is also safe to copy handles - internally they are nothing more than node pointers.
-	@verbatim
-	XMLHandle handleCopy = handle;
-	@endverbatim
-
-	See also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.
-*/
+  TIXMLASSERT( sizeof( NodeType ) == PoolElementSize );
+  TIXMLASSERT( sizeof( NodeType ) == pool.ItemSize() );
+  NodeType* returnNode = new (pool.Alloc()) NodeType( this );
+  TIXMLASSERT( returnNode );
+  returnNode->_memPool = &pool;
+
+  _unlinked.Push(returnNode);
+  return returnNode;
+}
+
+/**
+        A XMLHandle is a class that wraps a node pointer with null checks; this is
+        an incredibly useful thing. Note that XMLHandle is not part of the TinyXML-2
+        DOM structure. It is a separate utility class.
+
+        Take an example:
+        @verbatim
+        <Document>
+                <Element attributeA = "valueA">
+                        <Child attributeB = "value1" />
+                        <Child attributeB = "value2" />
+                </Element>
+        </Document>
+        @endverbatim
+
+        Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
+        easy to write a *lot* of code that looks like:
+
+        @verbatim
+        XMLElement* root = document.FirstChildElement( "Document" );
+        if ( root )
+        {
+                XMLElement* element = root->FirstChildElement( "Element" );
+                if ( element )
+                {
+                        XMLElement* child = element->FirstChildElement( "Child" );
+                        if ( child )
+                        {
+                                XMLElement* child2 = child->NextSiblingElement( "Child" );
+                                if ( child2 )
+                                {
+                                        // Finally do something useful.
+        @endverbatim
+
+        And that doesn't even cover "else" cases. XMLHandle addresses the verbosity
+        of such code. A XMLHandle checks for null pointers so it is perfectly safe
+        and correct to use:
+
+        @verbatim
+        XMLHandle docHandle( &document );
+        XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();
+        if ( child2 )
+        {
+                // do something useful
+        @endverbatim
+
+        Which is MUCH more concise and useful.
+
+        It is also safe to copy handles - internally they are nothing more than node pointers.
+        @verbatim
+        XMLHandle handleCopy = handle;
+        @endverbatim
+
+        See also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.
+ */
 class TINYXML2_LIB XMLHandle
 {
 public:
-    /// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
-    explicit XMLHandle( XMLNode* node ) : _node( node ) {
-    }
-    /// Create a handle from a node.
-    explicit XMLHandle( XMLNode& node ) : _node( &node ) {
-    }
-    /// Copy constructor
-    XMLHandle( const XMLHandle& ref ) : _node( ref._node ) {
-    }
-    /// Assignment
-    XMLHandle& operator=( const XMLHandle& ref )							{
-        _node = ref._node;
-        return *this;
-    }
-
-    /// Get the first child of this handle.
-    XMLHandle FirstChild() 													{
-        return XMLHandle( _node ? _node->FirstChild() : 0 );
-    }
-    /// Get the first child element of this handle.
-    XMLHandle FirstChildElement( const char* name = 0 )						{
-        return XMLHandle( _node ? _node->FirstChildElement( name ) : 0 );
-    }
-    /// Get the last child of this handle.
-    XMLHandle LastChild()													{
-        return XMLHandle( _node ? _node->LastChild() : 0 );
-    }
-    /// Get the last child element of this handle.
-    XMLHandle LastChildElement( const char* name = 0 )						{
-        return XMLHandle( _node ? _node->LastChildElement( name ) : 0 );
-    }
-    /// Get the previous sibling of this handle.
-    XMLHandle PreviousSibling()												{
-        return XMLHandle( _node ? _node->PreviousSibling() : 0 );
-    }
-    /// Get the previous sibling element of this handle.
-    XMLHandle PreviousSiblingElement( const char* name = 0 )				{
-        return XMLHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
-    }
-    /// Get the next sibling of this handle.
-    XMLHandle NextSibling()													{
-        return XMLHandle( _node ? _node->NextSibling() : 0 );
-    }
-    /// Get the next sibling element of this handle.
-    XMLHandle NextSiblingElement( const char* name = 0 )					{
-        return XMLHandle( _node ? _node->NextSiblingElement( name ) : 0 );
-    }
-
-    /// Safe cast to XMLNode. This can return null.
-    XMLNode* ToNode()							{
-        return _node;
-    }
-    /// Safe cast to XMLElement. This can return null.
-    XMLElement* ToElement() 					{
-        return ( _node ? _node->ToElement() : 0 );
-    }
-    /// Safe cast to XMLText. This can return null.
-    XMLText* ToText() 							{
-        return ( _node ? _node->ToText() : 0 );
-    }
-    /// Safe cast to XMLUnknown. This can return null.
-    XMLUnknown* ToUnknown() 					{
-        return ( _node ? _node->ToUnknown() : 0 );
-    }
-    /// Safe cast to XMLDeclaration. This can return null.
-    XMLDeclaration* ToDeclaration() 			{
-        return ( _node ? _node->ToDeclaration() : 0 );
-    }
+/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+explicit XMLHandle( XMLNode* node ) : _node( node ) {
+}
+/// Create a handle from a node.
+explicit XMLHandle( XMLNode& node ) : _node( &node ) {
+}
+/// Copy constructor
+XMLHandle( const XMLHandle& ref ) : _node( ref._node ) {
+}
+/// Assignment
+XMLHandle& operator=( const XMLHandle& ref )                                                        {
+  _node = ref._node;
+  return *this;
+}
+
+/// Get the first child of this handle.
+XMLHandle FirstChild()                                                                                                      {
+  return XMLHandle( _node ? _node->FirstChild() : 0 );
+}
+/// Get the first child element of this handle.
+XMLHandle FirstChildElement( const char* name = 0 )                                         {
+  return XMLHandle( _node ? _node->FirstChildElement( name ) : 0 );
+}
+/// Get the last child of this handle.
+XMLHandle LastChild()                                                                                                       {
+  return XMLHandle( _node ? _node->LastChild() : 0 );
+}
+/// Get the last child element of this handle.
+XMLHandle LastChildElement( const char* name = 0 )                                          {
+  return XMLHandle( _node ? _node->LastChildElement( name ) : 0 );
+}
+/// Get the previous sibling of this handle.
+XMLHandle PreviousSibling()                                                                                         {
+  return XMLHandle( _node ? _node->PreviousSibling() : 0 );
+}
+/// Get the previous sibling element of this handle.
+XMLHandle PreviousSiblingElement( const char* name = 0 )                            {
+  return XMLHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
+}
+/// Get the next sibling of this handle.
+XMLHandle NextSibling()                                                                                                     {
+  return XMLHandle( _node ? _node->NextSibling() : 0 );
+}
+/// Get the next sibling element of this handle.
+XMLHandle NextSiblingElement( const char* name = 0 )                                        {
+  return XMLHandle( _node ? _node->NextSiblingElement( name ) : 0 );
+}
+
+/// Safe cast to XMLNode. This can return null.
+XMLNode* ToNode()                                                   {
+  return _node;
+}
+/// Safe cast to XMLElement. This can return null.
+XMLElement* ToElement()                                     {
+  return ( _node ? _node->ToElement() : 0 );
+}
+/// Safe cast to XMLText. This can return null.
+XMLText* ToText()                                                   {
+  return ( _node ? _node->ToText() : 0 );
+}
+/// Safe cast to XMLUnknown. This can return null.
+XMLUnknown* ToUnknown()                                     {
+  return ( _node ? _node->ToUnknown() : 0 );
+}
+/// Safe cast to XMLDeclaration. This can return null.
+XMLDeclaration* ToDeclaration()                     {
+  return ( _node ? _node->ToDeclaration() : 0 );
+}
 
 private:
-    XMLNode* _node;
-};
-
-
-/**
-	A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
-	same in all regards, except for the 'const' qualifiers. See XMLHandle for API.
-*/
+XMLNode* _node;
+};
+
+
+/**
+        A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
+        same in all regards, except for the 'const' qualifiers. See XMLHandle for API.
+ */
 class TINYXML2_LIB XMLConstHandle
 {
 public:
-    explicit XMLConstHandle( const XMLNode* node ) : _node( node ) {
-    }
-    explicit XMLConstHandle( const XMLNode& node ) : _node( &node ) {
-    }
-    XMLConstHandle( const XMLConstHandle& ref ) : _node( ref._node ) {
-    }
-
-    XMLConstHandle& operator=( const XMLConstHandle& ref )							{
-        _node = ref._node;
-        return *this;
-    }
-
-    const XMLConstHandle FirstChild() const											{
-        return XMLConstHandle( _node ? _node->FirstChild() : 0 );
-    }
-    const XMLConstHandle FirstChildElement( const char* name = 0 ) const				{
-        return XMLConstHandle( _node ? _node->FirstChildElement( name ) : 0 );
-    }
-    const XMLConstHandle LastChild()	const										{
-        return XMLConstHandle( _node ? _node->LastChild() : 0 );
-    }
-    const XMLConstHandle LastChildElement( const char* name = 0 ) const				{
-        return XMLConstHandle( _node ? _node->LastChildElement( name ) : 0 );
-    }
-    const XMLConstHandle PreviousSibling() const									{
-        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );
-    }
-    const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const		{
-        return XMLConstHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
-    }
-    const XMLConstHandle NextSibling() const										{
-        return XMLConstHandle( _node ? _node->NextSibling() : 0 );
-    }
-    const XMLConstHandle NextSiblingElement( const char* name = 0 ) const			{
-        return XMLConstHandle( _node ? _node->NextSiblingElement( name ) : 0 );
-    }
-
-
-    const XMLNode* ToNode() const				{
-        return _node;
-    }
-    const XMLElement* ToElement() const			{
-        return ( _node ? _node->ToElement() : 0 );
-    }
-    const XMLText* ToText() const				{
-        return ( _node ? _node->ToText() : 0 );
-    }
-    const XMLUnknown* ToUnknown() const			{
-        return ( _node ? _node->ToUnknown() : 0 );
-    }
-    const XMLDeclaration* ToDeclaration() const	{
-        return ( _node ? _node->ToDeclaration() : 0 );
-    }
+explicit XMLConstHandle( const XMLNode* node ) : _node( node ) {
+}
+explicit XMLConstHandle( const XMLNode& node ) : _node( &node ) {
+}
+XMLConstHandle( const XMLConstHandle& ref ) : _node( ref._node ) {
+}
+
+XMLConstHandle& operator=( const XMLConstHandle& ref )                                                      {
+  _node = ref._node;
+  return *this;
+}
+
+const XMLConstHandle FirstChild() const {
+  return XMLConstHandle( _node ? _node->FirstChild() : 0 );
+}
+const XMLConstHandle FirstChildElement( const char* name = 0 ) const {
+  return XMLConstHandle( _node ? _node->FirstChildElement( name ) : 0 );
+}
+const XMLConstHandle LastChild()    const {
+  return XMLConstHandle( _node ? _node->LastChild() : 0 );
+}
+const XMLConstHandle LastChildElement( const char* name = 0 ) const {
+  return XMLConstHandle( _node ? _node->LastChildElement( name ) : 0 );
+}
+const XMLConstHandle PreviousSibling() const {
+  return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );
+}
+const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const {
+  return XMLConstHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
+}
+const XMLConstHandle NextSibling() const {
+  return XMLConstHandle( _node ? _node->NextSibling() : 0 );
+}
+const XMLConstHandle NextSiblingElement( const char* name = 0 ) const {
+  return XMLConstHandle( _node ? _node->NextSiblingElement( name ) : 0 );
+}
+
+
+const XMLNode* ToNode() const {
+  return _node;
+}
+const XMLElement* ToElement() const {
+  return ( _node ? _node->ToElement() : 0 );
+}
+const XMLText* ToText() const {
+  return ( _node ? _node->ToText() : 0 );
+}
+const XMLUnknown* ToUnknown() const {
+  return ( _node ? _node->ToUnknown() : 0 );
+}
+const XMLDeclaration* ToDeclaration() const {
+  return ( _node ? _node->ToDeclaration() : 0 );
+}
 
 private:
-    const XMLNode* _node;
-};
-
-
-/**
-	Printing functionality. The XMLPrinter gives you more
-	options than the XMLDocument::Print() method.
-
-	It can:
-	-# Print to memory.
-	-# Print to a file you provide.
-	-# Print XML without a XMLDocument.
-
-	Print to Memory
-
-	@verbatim
-	XMLPrinter printer;
-	doc.Print( &printer );
-	SomeFunction( printer.CStr() );
-	@endverbatim
-
-	Print to a File
-
-	You provide the file pointer.
-	@verbatim
-	XMLPrinter printer( fp );
-	doc.Print( &printer );
-	@endverbatim
-
-	Print without a XMLDocument
-
-	When loading, an XML parser is very useful. However, sometimes
-	when saving, it just gets in the way. The code is often set up
-	for streaming, and constructing the DOM is just overhead.
-
-	The Printer supports the streaming case. The following code
-	prints out a trivially simple XML file without ever creating
-	an XML document.
-
-	@verbatim
-	XMLPrinter printer( fp );
-	printer.OpenElement( "foo" );
-	printer.PushAttribute( "foo", "bar" );
-	printer.CloseElement();
-	@endverbatim
-*/
+const XMLNode* _node;
+};
+
+
+/**
+        Printing functionality. The XMLPrinter gives you more
+        options than the XMLDocument::Print() method.
+
+        It can:
+        -# Print to memory.
+        -# Print to a file you provide.
+        -# Print XML without a XMLDocument.
+
+        Print to Memory
+
+        @verbatim
+        XMLPrinter printer;
+        doc.Print( &printer );
+        SomeFunction( printer.CStr() );
+        @endverbatim
+
+        Print to a File
+
+        You provide the file pointer.
+        @verbatim
+        XMLPrinter printer( fp );
+        doc.Print( &printer );
+        @endverbatim
+
+        Print without a XMLDocument
+
+        When loading, an XML parser is very useful. However, sometimes
+        when saving, it just gets in the way. The code is often set up
+        for streaming, and constructing the DOM is just overhead.
+
+        The Printer supports the streaming case. The following code
+        prints out a trivially simple XML file without ever creating
+        an XML document.
+
+        @verbatim
+        XMLPrinter printer( fp );
+        printer.OpenElement( "foo" );
+        printer.PushAttribute( "foo", "bar" );
+        printer.CloseElement();
+        @endverbatim
+ */
 class TINYXML2_LIB XMLPrinter : public XMLVisitor
 {
 public:
-    /** Construct the printer. If the FILE* is specified,
-    	this will print to the FILE. Else it will print
-    	to memory, and the result is available in CStr().
-    	If 'compact' is set to true, then output is created
-    	with only required whitespace and newlines.
-    */
-    XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 );
-    virtual ~XMLPrinter()	{}
-
-    /** If streaming, write the BOM and declaration. */
-    void PushHeader( bool writeBOM, bool writeDeclaration );
-    /** If streaming, start writing an element.
-        The element must be closed with CloseElement()
-    */
-    void OpenElement( const char* name, bool compactMode=false );
-    /// If streaming, add an attribute to an open element.
-    void PushAttribute( const char* name, const char* value );
-    void PushAttribute( const char* name, int value );
-    void PushAttribute( const char* name, unsigned value );
-	void PushAttribute( const char* name, int64_t value );
-	void PushAttribute( const char* name, uint64_t value );
-	void PushAttribute( const char* name, bool value );
-    void PushAttribute( const char* name, double value );
-    /// If streaming, close the Element.
-    virtual void CloseElement( bool compactMode=false );
-
-    /// Add a text node.
-    void PushText( const char* text, bool cdata=false );
-    /// Add a text node from an integer.
-    void PushText( int value );
-    /// Add a text node from an unsigned.
-    void PushText( unsigned value );
-	/// Add a text node from a signed 64bit integer.
-	void PushText( int64_t value );
-	/// Add a text node from an unsigned 64bit integer.
-	void PushText( uint64_t value );
-	/// Add a text node from a bool.
-    void PushText( bool value );
-    /// Add a text node from a float.
-    void PushText( float value );
-    /// Add a text node from a double.
-    void PushText( double value );
-
-    /// Add a comment
-    void PushComment( const char* comment );
-
-    void PushDeclaration( const char* value );
-    void PushUnknown( const char* value );
-
-    virtual bool VisitEnter( const XMLDocument& /*doc*/ ) override;
-    virtual bool VisitExit( const XMLDocument& /*doc*/ ) override	{
-        return true;
-    }
-
-    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute ) override;
-    virtual bool VisitExit( const XMLElement& element ) override;
-
-    virtual bool Visit( const XMLText& text ) override;
-    virtual bool Visit( const XMLComment& comment ) override;
-    virtual bool Visit( const XMLDeclaration& declaration ) override;
-    virtual bool Visit( const XMLUnknown& unknown ) override;
-
-    /**
-    	If in print to memory mode, return a pointer to
-    	the XML file in memory.
-    */
-    const char* CStr() const {
-        return _buffer.Mem();
-    }
-    /**
-    	If in print to memory mode, return the size
-    	of the XML file in memory. (Note the size returned
-    	includes the terminating null.)
-    */
-    size_t CStrSize() const {
-        return _buffer.Size();
-    }
-    /**
-    	If in print to memory mode, reset the buffer to the
-    	beginning.
-    */
-    void ClearBuffer( bool resetToFirstElement = true ) {
-        _buffer.Clear();
-        _buffer.Push(0);
-		_firstElement = resetToFirstElement;
-    }
+/** Construct the printer. If the FILE* is specified,
+    this will print to the FILE. Else it will print
+    to memory, and the result is available in CStr().
+    If 'compact' is set to true, then output is created
+    with only required whitespace and newlines.
+ */
+XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 );
+virtual ~XMLPrinter()       {
+}
+
+/** If streaming, write the BOM and declaration. */
+void PushHeader( bool writeBOM, bool writeDeclaration );
+/** If streaming, start writing an element.
+    The element must be closed with CloseElement()
+ */
+void OpenElement( const char* name, bool compactMode=false );
+/// If streaming, add an attribute to an open element.
+void PushAttribute( const char* name, const char* value );
+void PushAttribute( const char* name, int value );
+void PushAttribute( const char* name, unsigned value );
+void PushAttribute( const char* name, int64_t value );
+void PushAttribute( const char* name, uint64_t value );
+void PushAttribute( const char* name, bool value );
+void PushAttribute( const char* name, double value );
+/// If streaming, close the Element.
+virtual void CloseElement( bool compactMode=false );
+
+/// Add a text node.
+void PushText( const char* text, bool cdata=false );
+/// Add a text node from an integer.
+void PushText( int value );
+/// Add a text node from an unsigned.
+void PushText( unsigned value );
+/// Add a text node from a signed 64bit integer.
+void PushText( int64_t value );
+/// Add a text node from an unsigned 64bit integer.
+void PushText( uint64_t value );
+/// Add a text node from a bool.
+void PushText( bool value );
+/// Add a text node from a float.
+void PushText( float value );
+/// Add a text node from a double.
+void PushText( double value );
+
+/// Add a comment
+void PushComment( const char* comment );
+
+void PushDeclaration( const char* value );
+void PushUnknown( const char* value );
+
+virtual bool VisitEnter( const XMLDocument& /*doc*/ ) override;
+virtual bool VisitExit( const XMLDocument& /*doc*/ ) override {
+  return true;
+}
+
+virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute ) override;
+virtual bool VisitExit( const XMLElement& element ) override;
+
+virtual bool Visit( const XMLText& text ) override;
+virtual bool Visit( const XMLComment& comment ) override;
+virtual bool Visit( const XMLDeclaration& declaration ) override;
+virtual bool Visit( const XMLUnknown& unknown ) override;
+
+/**
+    If in print to memory mode, return a pointer to
+    the XML file in memory.
+ */
+const char* CStr() const {
+  return _buffer.Mem();
+}
+/**
+    If in print to memory mode, return the size
+    of the XML file in memory. (Note the size returned
+    includes the terminating null.)
+ */
+size_t CStrSize() const {
+  return _buffer.Size();
+}
+/**
+    If in print to memory mode, reset the buffer to the
+    beginning.
+ */
+void ClearBuffer( bool resetToFirstElement = true ) {
+  _buffer.Clear();
+  _buffer.Push(0);
+  _firstElement = resetToFirstElement;
+}
 
 protected:
-	virtual bool CompactMode( const XMLElement& )	{ return _compactMode; }
-
-	/** Prints out the space before an element. You may override to change
-	    the space and tabs used. A PrintSpace() override should call Print().
-	*/
-    virtual void PrintSpace( int depth );
-    virtual void Print( const char* format, ... );
-    virtual void Write( const char* data, size_t size );
-    virtual void Putc( char ch );
-
-    inline void Write(const char* data) { Write(data, strlen(data)); }
-
-    void SealElementIfJustOpened();
-    bool _elementJustOpened;
-    DynArray< const char*, 10 > _stack;
+virtual bool CompactMode( const XMLElement& )   {
+  return _compactMode;
+}
+
+/** Prints out the space before an element. You may override to change
+    the space and tabs used. A PrintSpace() override should call Print().
+ */
+virtual void PrintSpace( int depth );
+virtual void Print( const char* format, ... );
+virtual void Write( const char* data, size_t size );
+virtual void Putc( char ch );
+
+inline void Write(const char* data) {
+  Write(data, strlen(data));
+}
+
+void SealElementIfJustOpened();
+bool _elementJustOpened;
+DynArray< const char*, 10 > _stack;
 
 private:
-    /**
-       Prepares to write a new node. This includes sealing an element that was
-       just opened, and writing any whitespace necessary if not in compact mode.
-     */
-    void PrepareForNewNode( bool compactMode );
-    void PrintString( const char*, bool restrictedEntitySet );	// prints out, after detecting entities.
-
-    bool _firstElement;
-    FILE* _fp;
-    int _depth;
-    int _textDepth;
-    bool _processEntities;
-	bool _compactMode;
-
-    enum {
-        ENTITY_RANGE = 64,
-        BUF_SIZE = 200
-    };
-    bool _entityFlag[ENTITY_RANGE];
-    bool _restrictedEntityFlag[ENTITY_RANGE];
-
-    DynArray< char, 20 > _buffer;
-
-    // Prohibit cloning, intentionally not implemented
-    XMLPrinter( const XMLPrinter& );
-    XMLPrinter& operator=( const XMLPrinter& );
+/**
+   Prepares to write a new node. This includes sealing an element that was
+   just opened, and writing any whitespace necessary if not in compact mode.
+ */
+void PrepareForNewNode( bool compactMode );
+void PrintString( const char*, bool restrictedEntitySet );      // prints out, after detecting entities.
+
+bool _firstElement;
+FILE* _fp;
+int _depth;
+int _textDepth;
+bool _processEntities;
+bool _compactMode;
+
+enum {
+  ENTITY_RANGE = 64,
+  BUF_SIZE = 200
+};
+bool _entityFlag[ENTITY_RANGE];
+bool _restrictedEntityFlag[ENTITY_RANGE];
+
+DynArray< char, 20 > _buffer;
+
+// Prohibit cloning, intentionally not implemented
+XMLPrinter( const XMLPrinter& );
+XMLPrinter& operator=( const XMLPrinter& );
 };
 
 
tests/mechanical_layer/include/Agent.h
====================
--- original

+++ formatted

@@ -12,34 +12,38 @@

  * Agents can interact with each other and navigate through the environment based on a driving force.
  */
 {
-    const unsigned _id;                         //  agent id
-    const double _mass;                         //  mass
-    const double _moi;                          //  moment of inertia
-    const std::vector<unsigned> _ids_shapes;    //  list of ids of the shapes of the agent
-    const double _radius;                       //  equivalent radius for repulsive force
-    const unsigned _nb_shapes;
-    std::vector<double2> _delta_gtos;           // list of vector from the center of mass G to the center of each physical shape (disc),
-    /*  For composite agents, remember that the positions and velocities given here
-        refer to the centre of mass of the composite agent  */
-    const std::vector<double> _radius_shapes;
-    const double _theta_init;
-    double _x, _y, _theta, _vx, _vy, _w;
-    double _vx_des, _vy_des, _w_des, _theta_des;
-    double2 _v_des;
-    std::list<unsigned> _neighbours;
-    std::list<std::pair<unsigned, unsigned>> _neighbours_walls;
+  const unsigned _id;                           //  agent id
+  const double _mass;                           //  mass
+  const double _moi;                            //  moment of inertia
+  const std::vector<unsigned> _ids_shapes;      //  list of ids of the shapes of the agent
+  const double _radius;                         //  equivalent radius for repulsive force
+  const unsigned _nb_shapes;
+  std::vector<double2> _delta_gtos;             // list of vector from the center of mass G to the center of each physical shape (disc),
+  /*  For composite agents, remember that the positions and velocities given here
+      refer to the centre of mass of the composite agent  */
+  const std::vector<double> _radius_shapes;
+  const double _theta_init;
+  double _x, _y, _theta, _vx, _vy, _w;
+  double _vx_des, _vy_des, _w_des, _theta_des;
+  double2 _v_des;
+  std::list<unsigned> _neighbours;
+  std::list<std::pair<unsigned, unsigned> > _neighbours_walls;
 
-    /*  Constructor for the class   */
-    Agent(unsigned ID, std::vector<unsigned> Ids_shapes, double x, double y, double vx, double vy, double omega,
-          double2 Fp, double Mp, unsigned nb_shapes, const std::vector<double2>& delta_gtos,
-          const std::vector<double>& radius_shapes, double theta_body, double theta_body_init,
-          double mass, double moi);
-    ~Agent();
+  /*  Constructor for the class   */
+  Agent(unsigned ID, std::vector<unsigned> Ids_shapes, double x, double y, double vx, double vy, double omega,
+        double2 Fp, double Mp, unsigned nb_shapes, const std::vector<double2>& delta_gtos,
+        const std::vector<double>& radius_shapes, double theta_body, double theta_body_init,
+        double mass, double moi);
+  ~Agent();
 
-    void move();
-    inline double2 get_r() { return {_x, _y}; }
-    inline double2 get_v() { return {_vx, _vy}; }
-    std::vector<double2> get_delta_gtos();
+  void move();
+  inline double2 get_r() {
+    return {_x, _y};
+  }
+  inline double2 get_v() {
+    return {_vx, _vy};
+  }
+  std::vector<double2> get_delta_gtos();
 };
 
 
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp
====================
--- original

+++ formatted

@@ -1,29 +1,29 @@

 /*
-Original code by Lee Thomason (www.grinninglizard.com)
-
-This software is provided 'as-is', without any express or implied
-warranty. In no event will the authors be held liable for any
-damages arising from the use of this software.
-
-Permission is granted to anyone to use this software for any
-purpose, including commercial applications, and to alter it and
-redistribute it freely, subject to the following restrictions:
-
-1. The origin of this software must not be misrepresented; you must
-not claim that you wrote the original software. If you use this
-software in a product, an acknowledgment in the product documentation
-would be appreciated but is not required.
-
-2. Altered source versions must be plainly marked as such, and
-must not be misrepresented as being the original software.
-
-3. This notice may not be removed or altered from any source
-distribution.
-*/
+   Original code by Lee Thomason (www.grinninglizard.com)
+
+   This software is provided 'as-is', without any express or implied
+   warranty. In no event will the authors be held liable for any
+   damages arising from the use of this software.
+
+   Permission is granted to anyone to use this software for any
+   purpose, including commercial applications, and to alter it and
+   redistribute it freely, subject to the following restrictions:
+
+   1. The origin of this software must not be misrepresented; you must
+   not claim that you wrote the original software. If you use this
+   software in a product, an acknowledgment in the product documentation
+   would be appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and
+   must not be misrepresented as being the original software.
+
+   3. This notice may not be removed or altered from any source
+   distribution.
+ */
 
 #include "tinyxml2.h"
 
-#include <new>		// yes, this one new style header, is in the Android SDK.
+#include <new>          // yes, this one new style header, is in the Android SDK.
 #if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__) || defined(__CC_ARM)
 #   include <stddef.h>
 #   include <stdarg.h>
@@ -33,70 +33,70 @@

 #endif
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
-	// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
-	/*int _snprintf_s(
-	   char *buffer,
-	   size_t sizeOfBuffer,
-	   size_t count,
-	   const char *format [,
-		  argument] ...
-	);*/
-	static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )
-	{
-		va_list va;
-		va_start( va, format );
-		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
-		va_end( va );
-		return result;
-	}
-
-	static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )
-	{
-		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
-		return result;
-	}
-
-	#define TIXML_VSCPRINTF	_vscprintf
-	#define TIXML_SSCANF	sscanf_s
+// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
+/*int _snprintf_s(
+   char *buffer,
+   size_t sizeOfBuffer,
+   size_t count,
+   const char *format [,
+          argument] ...
+   );*/
+static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )
+{
+  va_list va;
+  va_start( va, format );
+  const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
+  va_end( va );
+  return result;
+}
+
+static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )
+{
+  const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
+  return result;
+}
+
+	#define TIXML_VSCPRINTF _vscprintf
+	#define TIXML_SSCANF    sscanf_s
 #elif defined _MSC_VER
-	// Microsoft Visual Studio 2003 and earlier or WinCE
-	#define TIXML_SNPRINTF	_snprintf
+// Microsoft Visual Studio 2003 and earlier or WinCE
+	#define TIXML_SNPRINTF  _snprintf
 	#define TIXML_VSNPRINTF _vsnprintf
-	#define TIXML_SSCANF	sscanf
+	#define TIXML_SSCANF    sscanf
 	#if (_MSC_VER < 1400 ) && (!defined WINCE)
-		// Microsoft Visual Studio 2003 and not WinCE.
+// Microsoft Visual Studio 2003 and not WinCE.
 		#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.
 	#else
-		// Microsoft Visual Studio 2003 and earlier or WinCE.
-		static inline int TIXML_VSCPRINTF( const char* format, va_list va )
-		{
-			int len = 512;
-			for (;;) {
-				len = len*2;
-				char* str = new char[len]();
-				const int required = _vsnprintf(str, len, format, va);
-				delete[] str;
-				if ( required != -1 ) {
-					TIXMLASSERT( required >= 0 );
-					len = required;
-					break;
-				}
-			}
-			TIXMLASSERT( len >= 0 );
-			return len;
-		}
+// Microsoft Visual Studio 2003 and earlier or WinCE.
+static inline int TIXML_VSCPRINTF( const char* format, va_list va )
+{
+  int len = 512;
+  for (;;) {
+    len = len*2;
+    char* str = new char[len]();
+    const int required = _vsnprintf(str, len, format, va);
+    delete[] str;
+    if ( required != -1 ) {
+      TIXMLASSERT( required >= 0 );
+      len = required;
+      break;
+    }
+  }
+  TIXMLASSERT( len >= 0 );
+  return len;
+}
 	#endif
 #else
-	// GCC version 3 and higher
-	//#warning( "Using sn* functions." )
-	#define TIXML_SNPRINTF	snprintf
-	#define TIXML_VSNPRINTF	vsnprintf
-	static inline int TIXML_VSCPRINTF( const char* format, va_list va )
-	{
-		int len = vsnprintf( 0, 0, format, va );
-		TIXMLASSERT( len >= 0 );
-		return len;
-	}
+// GCC version 3 and higher
+//#warning( "Using sn* functions." )
+	#define TIXML_SNPRINTF  snprintf
+	#define TIXML_VSNPRINTF vsnprintf
+static inline int TIXML_VSCPRINTF( const char* format, va_list va )
+{
+  int len = vsnprintf( 0, 0, format, va );
+  TIXMLASSERT( len >= 0 );
+  return len;
+}
 	#define TIXML_SSCANF   sscanf
 #endif
 
@@ -115,12 +115,12 @@

 #endif
 
 
-static const char LINE_FEED				= static_cast<char>(0x0a);			// all line endings are normalized to LF
+static const char LINE_FEED                             = static_cast<char>(0x0a);                      // all line endings are normalized to LF
 static const char LF = LINE_FEED;
-static const char CARRIAGE_RETURN		= static_cast<char>(0x0d);			// CR gets filtered out
+static const char CARRIAGE_RETURN               = static_cast<char>(0x0d);                      // CR gets filtered out
 static const char CR = CARRIAGE_RETURN;
-static const char SINGLE_QUOTE			= '\'';
-static const char DOUBLE_QUOTE			= '\"';
+static const char SINGLE_QUOTE                  = '\'';
+static const char DOUBLE_QUOTE                  = '\"';
 
 // Bunch of unicode info at:
 //		http://www.unicode.org/faq/utf_bom.html
@@ -134,248 +134,248 @@

 {
 
 struct Entity {
-    const char* pattern;
-    int length;
-    char value;
+  const char* pattern;
+  int length;
+  char value;
 };
 
 static const int NUM_ENTITIES = 5;
 static const Entity entities[NUM_ENTITIES] = {
-    { "quot", 4,	DOUBLE_QUOTE },
-    { "amp", 3,		'&'  },
-    { "apos", 4,	SINGLE_QUOTE },
-    { "lt",	2, 		'<'	 },
-    { "gt",	2,		'>'	 }
+  { "quot", 4,        DOUBLE_QUOTE },
+  { "amp", 3,         '&'  },
+  { "apos", 4,        SINGLE_QUOTE },
+  { "lt",     2,              '<'      },
+  { "gt",     2,              '>'      }
 };
 
 
 StrPair::~StrPair()
 {
-    Reset();
+  Reset();
 }
 
 
 void StrPair::TransferTo( StrPair* other )
 {
-    if ( this == other ) {
-        return;
-    }
-    // This in effect implements the assignment operator by "moving"
-    // ownership (as in auto_ptr).
-
-    TIXMLASSERT( other != 0 );
-    TIXMLASSERT( other->_flags == 0 );
-    TIXMLASSERT( other->_start == 0 );
-    TIXMLASSERT( other->_end == 0 );
-
-    other->Reset();
-
-    other->_flags = _flags;
-    other->_start = _start;
-    other->_end = _end;
-
-    _flags = 0;
-    _start = 0;
-    _end = 0;
+  if ( this == other ) {
+    return;
+  }
+  // This in effect implements the assignment operator by "moving"
+  // ownership (as in auto_ptr).
+
+  TIXMLASSERT( other != 0 );
+  TIXMLASSERT( other->_flags == 0 );
+  TIXMLASSERT( other->_start == 0 );
+  TIXMLASSERT( other->_end == 0 );
+
+  other->Reset();
+
+  other->_flags = _flags;
+  other->_start = _start;
+  other->_end = _end;
+
+  _flags = 0;
+  _start = 0;
+  _end = 0;
 }
 
 
 void StrPair::Reset()
 {
-    if ( _flags & NEEDS_DELETE ) {
-        delete [] _start;
-    }
-    _flags = 0;
-    _start = 0;
-    _end = 0;
+  if ( _flags & NEEDS_DELETE ) {
+    delete [] _start;
+  }
+  _flags = 0;
+  _start = 0;
+  _end = 0;
 }
 
 
 void StrPair::SetStr( const char* str, int flags )
 {
-    TIXMLASSERT( str );
-    Reset();
-    size_t len = strlen( str );
-    TIXMLASSERT( _start == 0 );
-    _start = new char[ len+1 ];
-    memcpy( _start, str, len+1 );
-    _end = _start + len;
-    _flags = flags | NEEDS_DELETE;
+  TIXMLASSERT( str );
+  Reset();
+  size_t len = strlen( str );
+  TIXMLASSERT( _start == 0 );
+  _start = new char[ len+1 ];
+  memcpy( _start, str, len+1 );
+  _end = _start + len;
+  _flags = flags | NEEDS_DELETE;
 }
 
 
 char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )
 {
+  TIXMLASSERT( p );
+  TIXMLASSERT( endTag && *endTag );
+  TIXMLASSERT(curLineNumPtr);
+
+  char* start = p;
+  const char endChar = *endTag;
+  size_t length = strlen( endTag );
+
+  // Inner loop of text parsing.
+  while ( *p ) {
+    if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {
+      Set( start, p, strFlags );
+      return p + length;
+    } else if (*p == '\n') {
+      ++(*curLineNumPtr);
+    }
+    ++p;
     TIXMLASSERT( p );
-    TIXMLASSERT( endTag && *endTag );
-	TIXMLASSERT(curLineNumPtr);
-
-    char* start = p;
-    const char  endChar = *endTag;
-    size_t length = strlen( endTag );
-
-    // Inner loop of text parsing.
-    while ( *p ) {
-        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {
-            Set( start, p, strFlags );
-            return p + length;
-        } else if (*p == '\n') {
-            ++(*curLineNumPtr);
-        }
-        ++p;
-        TIXMLASSERT( p );
-    }
+  }
+  return 0;
+}
+
+
+char* StrPair::ParseName( char* p )
+{
+  if ( !p || !(*p) ) {
     return 0;
-}
-
-
-char* StrPair::ParseName( char* p )
-{
-    if ( !p || !(*p) ) {
-        return 0;
-    }
-    if ( !XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
-        return 0;
-    }
-
-    char* const start = p;
+  }
+  if ( !XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
+    return 0;
+  }
+
+  char* const start = p;
+  ++p;
+  while ( *p && XMLUtil::IsNameChar( static_cast<unsigned char>(*p) ) ) {
     ++p;
-    while ( *p && XMLUtil::IsNameChar( static_cast<unsigned char>(*p) ) ) {
-        ++p;
-    }
-
-    Set( start, p, 0 );
-    return p;
+  }
+
+  Set( start, p, 0 );
+  return p;
 }
 
 
 void StrPair::CollapseWhitespace()
 {
-    // Adjusting _start would cause undefined behavior on delete[]
-    TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );
-    // Trim leading space.
-    _start = XMLUtil::SkipWhiteSpace( _start, 0 );
-
-    if ( *_start ) {
-        const char* p = _start;	// the read pointer
-        char* q = _start;	// the write pointer
-
-        while( *p ) {
-            if ( XMLUtil::IsWhiteSpace( *p )) {
-                p = XMLUtil::SkipWhiteSpace( p, 0 );
-                if ( *p == 0 ) {
-                    break;    // don't write to q; this trims the trailing space.
-                }
-                *q = ' ';
-                ++q;
-            }
-            *q = *p;
-            ++q;
-            ++p;
-        }
-        *q = 0;
-    }
+  // Adjusting _start would cause undefined behavior on delete[]
+  TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );
+  // Trim leading space.
+  _start = XMLUtil::SkipWhiteSpace( _start, 0 );
+
+  if ( *_start ) {
+    const char* p = _start;     // the read pointer
+    char* q = _start;           // the write pointer
+
+    while( *p ) {
+      if ( XMLUtil::IsWhiteSpace( *p )) {
+	p = XMLUtil::SkipWhiteSpace( p, 0 );
+	if ( *p == 0 ) {
+	  break;              // don't write to q; this trims the trailing space.
+	}
+	*q = ' ';
+	++q;
+      }
+      *q = *p;
+      ++q;
+      ++p;
+    }
+    *q = 0;
+  }
 }
 
 
 const char* StrPair::GetStr()
 {
-    TIXMLASSERT( _start );
-    TIXMLASSERT( _end );
-    if ( _flags & NEEDS_FLUSH ) {
-        *_end = 0;
-        _flags ^= NEEDS_FLUSH;
-
-        if ( _flags ) {
-            const char* p = _start;	// the read pointer
-            char* q = _start;	// the write pointer
-
-            while( p < _end ) {
-                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {
-                    // CR-LF pair becomes LF
-                    // CR alone becomes LF
-                    // LF-CR becomes LF
-                    if ( *(p+1) == LF ) {
-                        p += 2;
-                    }
-                    else {
-                        ++p;
-                    }
-                    *q = LF;
-                    ++q;
-                }
-                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {
-                    if ( *(p+1) == CR ) {
-                        p += 2;
-                    }
-                    else {
-                        ++p;
-                    }
-                    *q = LF;
-                    ++q;
-                }
-                else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {
-                    // Entities handled by tinyXML2:
-                    // - special entities in the entity table [in/out]
-                    // - numeric character reference [in]
-                    //   &#20013; or &#x4e2d;
-
-                    if ( *(p+1) == '#' ) {
-                        const int buflen = 10;
-                        char buf[buflen] = { 0 };
-                        int len = 0;
-                        const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
-                        if ( adjusted == 0 ) {
-                            *q = *p;
-                            ++p;
-                            ++q;
-                        }
-                        else {
-                            TIXMLASSERT( 0 <= len && len <= buflen );
-                            TIXMLASSERT( q + len <= adjusted );
-                            p = adjusted;
-                            memcpy( q, buf, len );
-                            q += len;
-                        }
-                    }
-                    else {
-                        bool entityFound = false;
-                        for( int i = 0; i < NUM_ENTITIES; ++i ) {
-                            const Entity& entity = entities[i];
-                            if ( strncmp( p + 1, entity.pattern, entity.length ) == 0
-                                    && *( p + entity.length + 1 ) == ';' ) {
-                                // Found an entity - convert.
-                                *q = entity.value;
-                                ++q;
-                                p += entity.length + 2;
-                                entityFound = true;
-                                break;
-                            }
-                        }
-                        if ( !entityFound ) {
-                            // fixme: treat as error?
-                            ++p;
-                            ++q;
-                        }
-                    }
-                }
-                else {
-                    *q = *p;
-                    ++p;
-                    ++q;
-                }
-            }
-            *q = 0;
-        }
-        // The loop below has plenty going on, and this
-        // is a less useful mode. Break it out.
-        if ( _flags & NEEDS_WHITESPACE_COLLAPSING ) {
-            CollapseWhitespace();
-        }
-        _flags = (_flags & NEEDS_DELETE);
-    }
-    TIXMLASSERT( _start );
-    return _start;
+  TIXMLASSERT( _start );
+  TIXMLASSERT( _end );
+  if ( _flags & NEEDS_FLUSH ) {
+    *_end = 0;
+    _flags ^= NEEDS_FLUSH;
+
+    if ( _flags ) {
+      const char* p = _start;           // the read pointer
+      char* q = _start;         // the write pointer
+
+      while( p < _end ) {
+	if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {
+	  // CR-LF pair becomes LF
+	  // CR alone becomes LF
+	  // LF-CR becomes LF
+	  if ( *(p+1) == LF ) {
+	    p += 2;
+	  }
+	  else {
+	    ++p;
+	  }
+	  *q = LF;
+	  ++q;
+	}
+	else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {
+	  if ( *(p+1) == CR ) {
+	    p += 2;
+	  }
+	  else {
+	    ++p;
+	  }
+	  *q = LF;
+	  ++q;
+	}
+	else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {
+	  // Entities handled by tinyXML2:
+	  // - special entities in the entity table [in/out]
+	  // - numeric character reference [in]
+	  //   &#20013; or &#x4e2d;
+
+	  if ( *(p+1) == '#' ) {
+	    const int buflen = 10;
+	    char buf[buflen] = { 0 };
+	    int len = 0;
+	    const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
+	    if ( adjusted == 0 ) {
+	      *q = *p;
+	      ++p;
+	      ++q;
+	    }
+	    else {
+	      TIXMLASSERT( 0 <= len && len <= buflen );
+	      TIXMLASSERT( q + len <= adjusted );
+	      p = adjusted;
+	      memcpy( q, buf, len );
+	      q += len;
+	    }
+	  }
+	  else {
+	    bool entityFound = false;
+	    for( int i = 0; i < NUM_ENTITIES; ++i ) {
+	      const Entity& entity = entities[i];
+	      if ( strncmp( p + 1, entity.pattern, entity.length ) == 0
+	           && *( p + entity.length + 1 ) == ';' ) {
+		// Found an entity - convert.
+		*q = entity.value;
+		++q;
+		p += entity.length + 2;
+		entityFound = true;
+		break;
+	      }
+	    }
+	    if ( !entityFound ) {
+	      // fixme: treat as error?
+	      ++p;
+	      ++q;
+	    }
+	  }
+	}
+	else {
+	  *q = *p;
+	  ++p;
+	  ++q;
+	}
+      }
+      *q = 0;
+    }
+    // The loop below has plenty going on, and this
+    // is a less useful mode. Break it out.
+    if ( _flags & NEEDS_WHITESPACE_COLLAPSING ) {
+      CollapseWhitespace();
+    }
+    _flags = (_flags & NEEDS_DELETE);
+  }
+  TIXMLASSERT( _start );
+  return _start;
 }
 
 
@@ -388,1682 +388,1682 @@

 
 void XMLUtil::SetBoolSerialization(const char* writeTrue, const char* writeFalse)
 {
-	static const char* defTrue  = "true";
-	static const char* defFalse = "false";
-
-	writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
-	writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
+  static const char* defTrue  = "true";
+  static const char* defFalse = "false";
+
+  writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
+  writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
 }
 
 
 const char* XMLUtil::ReadBOM( const char* p, bool* bom )
 {
-    TIXMLASSERT( p );
-    TIXMLASSERT( bom );
-    *bom = false;
-    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
-    // Check for BOM:
-    if (    *(pu+0) == TIXML_UTF_LEAD_0
-            && *(pu+1) == TIXML_UTF_LEAD_1
-            && *(pu+2) == TIXML_UTF_LEAD_2 ) {
-        *bom = true;
-        p += 3;
-    }
+  TIXMLASSERT( p );
+  TIXMLASSERT( bom );
+  *bom = false;
+  const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
+  // Check for BOM:
+  if (    *(pu+0) == TIXML_UTF_LEAD_0
+          && *(pu+1) == TIXML_UTF_LEAD_1
+          && *(pu+2) == TIXML_UTF_LEAD_2 ) {
+    *bom = true;
+    p += 3;
+  }
+  TIXMLASSERT( p );
+  return p;
+}
+
+
+void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+  const unsigned long BYTE_MASK = 0xBF;
+  const unsigned long BYTE_MARK = 0x80;
+  const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+  if (input < 0x80) {
+    *length = 1;
+  }
+  else if ( input < 0x800 ) {
+    *length = 2;
+  }
+  else if ( input < 0x10000 ) {
+    *length = 3;
+  }
+  else if ( input < 0x200000 ) {
+    *length = 4;
+  }
+  else {
+    *length = 0;        // This code won't convert this correctly anyway.
+    return;
+  }
+
+  output += *length;
+
+  // Scary scary fall throughs are annotated with carefully designed comments
+  // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
+  switch (*length) {
+  case 4:
+    --output;
+    *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
+    input >>= 6;
+  //fall through
+  case 3:
+    --output;
+    *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
+    input >>= 6;
+  //fall through
+  case 2:
+    --output;
+    *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
+    input >>= 6;
+  //fall through
+  case 1:
+    --output;
+    *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
+    break;
+  default:
+    TIXMLASSERT( false );
+  }
+}
+
+
+const char* XMLUtil::GetCharacterRef(const char* p, char* value, int* length)
+{
+  // Assume an entity, and pull it out.
+  *length = 0;
+
+  static const uint32_t MAX_CODE_POINT = 0x10FFFF;
+
+  if (*(p + 1) == '#' && *(p + 2)) {
+    uint32_t ucs = 0;
+    ptrdiff_t delta = 0;
+    uint32_t mult = 1;
+    static const char SEMICOLON = ';';
+
+    bool hex = false;
+    uint32_t radix = 10;
+    const char* q = 0;
+    char terminator = '#';
+
+    if (*(p + 2) == 'x') {
+      // Hexadecimal.
+      hex = true;
+      radix = 16;
+      terminator = 'x';
+
+      q = p + 3;
+    }
+    else {
+      // Decimal.
+      q = p + 2;
+    }
+    if (!(*q)) {
+      return 0;
+    }
+
+    q = strchr(q, SEMICOLON);
+    if (!q) {
+      return 0;
+    }
+    TIXMLASSERT(*q == SEMICOLON);
+
+    delta = q - p;
+    --q;
+
+    while (*q != terminator) {
+      uint32_t digit = 0;
+
+      if (*q >= '0' && *q <= '9') {
+	digit = *q - '0';
+      }
+      else if (hex && (*q >= 'a' && *q <= 'f')) {
+	digit = *q - 'a' + 10;
+      }
+      else if (hex && (*q >= 'A' && *q <= 'F')) {
+	digit = *q - 'A' + 10;
+      }
+      else {
+	return 0;
+      }
+      TIXMLASSERT(digit < radix);
+
+      const unsigned int digitScaled = mult * digit;
+      ucs += digitScaled;
+      mult *= radix;
+
+      // Security check: could a value exist that is out of range?
+      // Easily; limit to the MAX_CODE_POINT, which also allows for a
+      // bunch of leading zeroes.
+      if (mult > MAX_CODE_POINT) {
+	mult = MAX_CODE_POINT;
+      }
+      --q;
+    }
+    // Out of range:
+    if (ucs > MAX_CODE_POINT) {
+      return 0;
+    }
+    // convert the UCS to UTF-8
+    ConvertUTF32ToUTF8(ucs, value, length);
+    if (length == 0) {
+      // If length is 0, there was an error. (Security? Bad input?)
+      // Fail safely.
+      return 0;
+    }
+    return p + delta + 1;
+  }
+  return p + 1;
+}
+
+void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
+{
+  TIXML_SNPRINTF( buffer, bufferSize, "%d", v );
+}
+
+
+void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )
+{
+  TIXML_SNPRINTF( buffer, bufferSize, "%u", v );
+}
+
+
+void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )
+{
+  TIXML_SNPRINTF( buffer, bufferSize, "%s", v ? writeBoolTrue : writeBoolFalse);
+}
+
+/*
+        ToStr() of a number is a very tricky topic.
+        https://github.com/leethomason/tinyxml2/issues/106
+ */
+void XMLUtil::ToStr( float v, char* buffer, int bufferSize )
+{
+  TIXML_SNPRINTF( buffer, bufferSize, "%.8g", v );
+}
+
+
+void XMLUtil::ToStr( double v, char* buffer, int bufferSize )
+{
+  TIXML_SNPRINTF( buffer, bufferSize, "%.17g", v );
+}
+
+
+void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
+{
+  // horrible syntax trick to make the compiler happy about %lld
+  TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
+}
+
+void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
+{
+  // horrible syntax trick to make the compiler happy about %llu
+  TIXML_SNPRINTF(buffer, bufferSize, "%llu", static_cast<unsigned long long>(v));
+}
+
+bool XMLUtil::ToInt(const char* str, int* value)
+{
+  if (IsPrefixHex(str)) {
+    unsigned v;
+    if (TIXML_SSCANF(str, "%x", &v) == 1) {
+      *value = static_cast<int>(v);
+      return true;
+    }
+  }
+  else {
+    if (TIXML_SSCANF(str, "%d", value) == 1) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool XMLUtil::ToUnsigned(const char* str, unsigned* value)
+{
+  if (TIXML_SSCANF(str, IsPrefixHex(str) ? "%x" : "%u", value) == 1) {
+    return true;
+  }
+  return false;
+}
+
+bool XMLUtil::ToBool( const char* str, bool* value )
+{
+  int ival = 0;
+  if ( ToInt( str, &ival )) {
+    *value = (ival==0) ? false : true;
+    return true;
+  }
+  static const char* TRUE_VALS[] = { "true", "True", "TRUE", 0 };
+  static const char* FALSE_VALS[] = { "false", "False", "FALSE", 0 };
+
+  for (int i = 0; TRUE_VALS[i]; ++i) {
+    if (StringEqual(str, TRUE_VALS[i])) {
+      *value = true;
+      return true;
+    }
+  }
+  for (int i = 0; FALSE_VALS[i]; ++i) {
+    if (StringEqual(str, FALSE_VALS[i])) {
+      *value = false;
+      return true;
+    }
+  }
+  return false;
+}
+
+
+bool XMLUtil::ToFloat( const char* str, float* value )
+{
+  if ( TIXML_SSCANF( str, "%f", value ) == 1 ) {
+    return true;
+  }
+  return false;
+}
+
+
+bool XMLUtil::ToDouble( const char* str, double* value )
+{
+  if ( TIXML_SSCANF( str, "%lf", value ) == 1 ) {
+    return true;
+  }
+  return false;
+}
+
+
+bool XMLUtil::ToInt64(const char* str, int64_t* value)
+{
+  if (IsPrefixHex(str)) {
+    unsigned long long v = 0;           // horrible syntax trick to make the compiler happy about %llx
+    if (TIXML_SSCANF(str, "%llx", &v) == 1) {
+      *value = static_cast<int64_t>(v);
+      return true;
+    }
+  }
+  else {
+    long long v = 0;            // horrible syntax trick to make the compiler happy about %lld
+    if (TIXML_SSCANF(str, "%lld", &v) == 1) {
+      *value = static_cast<int64_t>(v);
+      return true;
+    }
+  }
+  return false;
+}
+
+
+bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
+  unsigned long long v = 0;     // horrible syntax trick to make the compiler happy about %llu
+  if(TIXML_SSCANF(str, IsPrefixHex(str) ? "%llx" : "%llu", &v) == 1) {
+    *value = static_cast<uint64_t>(v);
+    return true;
+  }
+  return false;
+}
+
+
+char* XMLDocument::Identify( char* p, XMLNode** node, bool first )
+{
+  TIXMLASSERT( node );
+  TIXMLASSERT( p );
+  char* const start = p;
+  int const startLine = _parseCurLineNum;
+  p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
+  if( !*p ) {
+    *node = 0;
     TIXMLASSERT( p );
     return p;
-}
-
-
-void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
-{
-    const unsigned long BYTE_MASK = 0xBF;
-    const unsigned long BYTE_MARK = 0x80;
-    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
-
-    if (input < 0x80) {
-        *length = 1;
-    }
-    else if ( input < 0x800 ) {
-        *length = 2;
-    }
-    else if ( input < 0x10000 ) {
-        *length = 3;
-    }
-    else if ( input < 0x200000 ) {
-        *length = 4;
+  }
+
+  // These strings define the matching patterns:
+  static const char* xmlHeader                = { "<?" };
+  static const char* commentHeader    = { "<!--" };
+  static const char* cdataHeader              = { "<![CDATA[" };
+  static const char* dtdHeader                = { "<!" };
+  static const char* elementHeader    = { "<" };        // and a header for everything else; check last.
+
+  static const int xmlHeaderLen               = 2;
+  static const int commentHeaderLen   = 4;
+  static const int cdataHeaderLen             = 9;
+  static const int dtdHeaderLen               = 2;
+  static const int elementHeaderLen   = 1;
+
+  TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );                  // use same memory pool
+  TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );      // use same memory pool
+  XMLNode* returnNode = 0;
+  if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {
+    returnNode = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += xmlHeaderLen;
+  }
+  else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {
+    returnNode = CreateUnlinkedNode<XMLComment>( _commentPool );
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += commentHeaderLen;
+  }
+  else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {
+    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
+    returnNode = text;
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += cdataHeaderLen;
+    text->SetCData( true );
+  }
+  else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {
+    returnNode = CreateUnlinkedNode<XMLUnknown>( _commentPool );
+    returnNode->_parseLineNum = _parseCurLineNum;
+    p += dtdHeaderLen;
+  }
+  else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {
+
+    // Preserve whitespace pedantically before closing tag, when it's immediately after opening tag
+    if (WhitespaceMode() == PEDANTIC_WHITESPACE && first && p != start && *(p + elementHeaderLen) == '/') {
+      returnNode = CreateUnlinkedNode<XMLText>(_textPool);
+      returnNode->_parseLineNum = startLine;
+      p = start;        // Back it up, all the text counts.
+      _parseCurLineNum = startLine;
     }
     else {
-        *length = 0;    // This code won't convert this correctly anyway.
-        return;
-    }
-
-    output += *length;
-
-    // Scary scary fall throughs are annotated with carefully designed comments
-    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
-    switch (*length) {
-        case 4:
-            --output;
-            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
-            input >>= 6;
-            //fall through
-        case 3:
-            --output;
-            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
-            input >>= 6;
-            //fall through
-        case 2:
-            --output;
-            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
-            input >>= 6;
-            //fall through
-        case 1:
-            --output;
-            *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
-            break;
-        default:
-            TIXMLASSERT( false );
-    }
-}
-
-
-const char* XMLUtil::GetCharacterRef(const char* p, char* value, int* length)
-{
-    // Assume an entity, and pull it out.
-    *length = 0;
-
-    static const uint32_t MAX_CODE_POINT = 0x10FFFF;
-
-    if (*(p + 1) == '#' && *(p + 2)) {
-        uint32_t ucs = 0;
-        ptrdiff_t delta = 0;
-        uint32_t mult = 1;
-        static const char SEMICOLON = ';';
-
-        bool hex = false;
-        uint32_t radix = 10;
-        const char* q = 0;
-        char terminator = '#';
-
-        if (*(p + 2) == 'x') {
-            // Hexadecimal.
-            hex = true;
-            radix = 16;
-            terminator = 'x';
-
-            q = p + 3;
-        }
-        else {
-            // Decimal.
-            q = p + 2;
-        }
-        if (!(*q)) {
-            return 0;
-        }
-
-        q = strchr(q, SEMICOLON);
-        if (!q) {
-            return 0;
-        }
-        TIXMLASSERT(*q == SEMICOLON);
-
-        delta = q - p;
-        --q;
-
-        while (*q != terminator) {
-            uint32_t digit = 0;
-
-            if (*q >= '0' && *q <= '9') {
-                digit = *q - '0';
-            }
-            else if (hex && (*q >= 'a' && *q <= 'f')) {
-                digit = *q - 'a' + 10;
-            }
-            else if (hex && (*q >= 'A' && *q <= 'F')) {
-                digit = *q - 'A' + 10;
-            }
-            else {
-                return 0;
-            }
-            TIXMLASSERT(digit < radix);
-
-            const unsigned int digitScaled = mult * digit;
-            ucs += digitScaled;
-            mult *= radix;       
-            
-            // Security check: could a value exist that is out of range?
-            // Easily; limit to the MAX_CODE_POINT, which also allows for a
-            // bunch of leading zeroes.
-            if (mult > MAX_CODE_POINT) {
-                mult = MAX_CODE_POINT;
-            }
-            --q;
-        }
-        // Out of range:
-        if (ucs > MAX_CODE_POINT) {
-            return 0;
-        }
-        // convert the UCS to UTF-8
-        ConvertUTF32ToUTF8(ucs, value, length);
-		if (length == 0) {
-            // If length is 0, there was an error. (Security? Bad input?)
-            // Fail safely.
-			return 0;
-		}
-        return p + delta + 1;
-    }
-    return p + 1;
-}
-
-void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%d", v );
-}
-
-
-void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%u", v );
-}
-
-
-void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%s", v ? writeBoolTrue : writeBoolFalse);
-}
-
-/*
-	ToStr() of a number is a very tricky topic.
-	https://github.com/leethomason/tinyxml2/issues/106
-*/
-void XMLUtil::ToStr( float v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%.8g", v );
-}
-
-
-void XMLUtil::ToStr( double v, char* buffer, int bufferSize )
-{
-    TIXML_SNPRINTF( buffer, bufferSize, "%.17g", v );
-}
-
-
-void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
-{
-	// horrible syntax trick to make the compiler happy about %lld
-	TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
-}
-
-void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
-{
-    // horrible syntax trick to make the compiler happy about %llu
-    TIXML_SNPRINTF(buffer, bufferSize, "%llu", static_cast<unsigned long long>(v));
-}
-
-bool XMLUtil::ToInt(const char* str, int* value)
-{
-    if (IsPrefixHex(str)) {
-        unsigned v;
-        if (TIXML_SSCANF(str, "%x", &v) == 1) {
-            *value = static_cast<int>(v);
-            return true;
-        }
-    }
-    else {
-        if (TIXML_SSCANF(str, "%d", value) == 1) {
-            return true;
-        }
-    }
-    return false;
-}
-
-bool XMLUtil::ToUnsigned(const char* str, unsigned* value)
-{
-    if (TIXML_SSCANF(str, IsPrefixHex(str) ? "%x" : "%u", value) == 1) {
-        return true;
-    }
-    return false;
-}
-
-bool XMLUtil::ToBool( const char* str, bool* value )
-{
-    int ival = 0;
-    if ( ToInt( str, &ival )) {
-        *value = (ival==0) ? false : true;
-        return true;
-    }
-    static const char* TRUE_VALS[] = { "true", "True", "TRUE", 0 };
-    static const char* FALSE_VALS[] = { "false", "False", "FALSE", 0 };
-
-    for (int i = 0; TRUE_VALS[i]; ++i) {
-        if (StringEqual(str, TRUE_VALS[i])) {
-            *value = true;
-            return true;
-        }
-    }
-    for (int i = 0; FALSE_VALS[i]; ++i) {
-        if (StringEqual(str, FALSE_VALS[i])) {
-            *value = false;
-            return true;
-        }
-    }
-    return false;
-}
-
-
-bool XMLUtil::ToFloat( const char* str, float* value )
-{
-    if ( TIXML_SSCANF( str, "%f", value ) == 1 ) {
-        return true;
-    }
-    return false;
-}
-
-
-bool XMLUtil::ToDouble( const char* str, double* value )
-{
-    if ( TIXML_SSCANF( str, "%lf", value ) == 1 ) {
-        return true;
-    }
-    return false;
-}
-
-
-bool XMLUtil::ToInt64(const char* str, int64_t* value)
-{
-    if (IsPrefixHex(str)) {
-        unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llx
-        if (TIXML_SSCANF(str, "%llx", &v) == 1) {
-            *value = static_cast<int64_t>(v);
-            return true;
-        }
-    }
-    else {
-        long long v = 0;	// horrible syntax trick to make the compiler happy about %lld
-        if (TIXML_SSCANF(str, "%lld", &v) == 1) {
-            *value = static_cast<int64_t>(v);
-            return true;
-        }
-    }
-	return false;
-}
-
-
-bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
-    unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llu
-    if(TIXML_SSCANF(str, IsPrefixHex(str) ? "%llx" : "%llu", &v) == 1) {
-        *value = static_cast<uint64_t>(v);
-        return true;
-    }
-    return false;
-}
-
-
-char* XMLDocument::Identify( char* p, XMLNode** node, bool first )
-{
-    TIXMLASSERT( node );
+      returnNode = CreateUnlinkedNode<XMLElement>(_elementPool);
+      returnNode->_parseLineNum = _parseCurLineNum;
+      p += elementHeaderLen;
+    }
+  }
+  else {
+    returnNode = CreateUnlinkedNode<XMLText>( _textPool );
+    returnNode->_parseLineNum = _parseCurLineNum;     // Report line of first non-whitespace character
+    p = start;          // Back it up, all the text counts.
+    _parseCurLineNum = startLine;
+  }
+
+  TIXMLASSERT( returnNode );
+  TIXMLASSERT( p );
+  *node = returnNode;
+  return p;
+}
+
+
+bool XMLDocument::Accept( XMLVisitor* visitor ) const
+{
+  TIXMLASSERT( visitor );
+  if ( visitor->VisitEnter( *this ) ) {
+    for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
+      if ( !node->Accept( visitor ) ) {
+	break;
+      }
+    }
+  }
+  return visitor->VisitExit( *this );
+}
+
+
+// --------- XMLNode ----------- //
+
+XMLNode::XMLNode( XMLDocument* doc ) :
+  _document( doc ),
+  _parent( 0 ),
+  _value(),
+  _parseLineNum( 0 ),
+  _firstChild( 0 ), _lastChild( 0 ),
+  _prev( 0 ), _next( 0 ),
+  _userData( 0 ),
+  _memPool( 0 )
+{
+}
+
+
+XMLNode::~XMLNode()
+{
+  DeleteChildren();
+  if ( _parent ) {
+    _parent->Unlink( this );
+  }
+}
+
+// ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.
+
+int XMLNode::ChildElementCount(const char *value) const {
+  int count = 0;
+
+  const XMLElement *e = FirstChildElement(value);
+
+  while (e) {
+    e = e->NextSiblingElement(value);
+    count++;
+  }
+
+  return count;
+}
+
+int XMLNode::ChildElementCount() const {
+  int count = 0;
+
+  const XMLElement *e = FirstChildElement();
+
+  while (e) {
+    e = e->NextSiblingElement();
+    count++;
+  }
+
+  return count;
+}
+
+const char* XMLNode::Value() const
+{
+  // Edge case: XMLDocuments don't have a Value. Return null.
+  if ( this->ToDocument() )
+    return 0;
+  return _value.GetStr();
+}
+
+void XMLNode::SetValue( const char* str, bool staticMem )
+{
+  if ( staticMem ) {
+    _value.SetInternedStr( str );
+  }
+  else {
+    _value.SetStr( str );
+  }
+}
+
+XMLNode* XMLNode::DeepClone(XMLDocument* target) const
+{
+  XMLNode* clone = this->ShallowClone(target);
+  if (!clone) return 0;
+
+  for (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {
+    XMLNode* childClone = child->DeepClone(target);
+    TIXMLASSERT(childClone);
+    clone->InsertEndChild(childClone);
+  }
+  return clone;
+}
+
+void XMLNode::DeleteChildren()
+{
+  while( _firstChild ) {
+    TIXMLASSERT( _lastChild );
+    DeleteChild( _firstChild );
+  }
+  _firstChild = _lastChild = 0;
+}
+
+
+void XMLNode::Unlink( XMLNode* child )
+{
+  TIXMLASSERT( child );
+  TIXMLASSERT( child->_document == _document );
+  TIXMLASSERT( child->_parent == this );
+  if ( child == _firstChild ) {
+    _firstChild = _firstChild->_next;
+  }
+  if ( child == _lastChild ) {
+    _lastChild = _lastChild->_prev;
+  }
+
+  if ( child->_prev ) {
+    child->_prev->_next = child->_next;
+  }
+  if ( child->_next ) {
+    child->_next->_prev = child->_prev;
+  }
+  child->_next = 0;
+  child->_prev = 0;
+  child->_parent = 0;
+}
+
+
+void XMLNode::DeleteChild( XMLNode* node )
+{
+  TIXMLASSERT( node );
+  TIXMLASSERT( node->_document == _document );
+  TIXMLASSERT( node->_parent == this );
+  Unlink( node );
+  TIXMLASSERT(node->_prev == 0);
+  TIXMLASSERT(node->_next == 0);
+  TIXMLASSERT(node->_parent == 0);
+  DeleteNode( node );
+}
+
+
+XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )
+{
+  TIXMLASSERT( addThis );
+  if ( addThis->_document != _document ) {
+    TIXMLASSERT( false );
+    return 0;
+  }
+  InsertChildPreamble( addThis );
+
+  if ( _lastChild ) {
+    TIXMLASSERT( _firstChild );
+    TIXMLASSERT( _lastChild->_next == 0 );
+    _lastChild->_next = addThis;
+    addThis->_prev = _lastChild;
+    _lastChild = addThis;
+
+    addThis->_next = 0;
+  }
+  else {
+    TIXMLASSERT( _firstChild == 0 );
+    _firstChild = _lastChild = addThis;
+
+    addThis->_prev = 0;
+    addThis->_next = 0;
+  }
+  addThis->_parent = this;
+  return addThis;
+}
+
+
+XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )
+{
+  TIXMLASSERT( addThis );
+  if ( addThis->_document != _document ) {
+    TIXMLASSERT( false );
+    return 0;
+  }
+  InsertChildPreamble( addThis );
+
+  if ( _firstChild ) {
+    TIXMLASSERT( _lastChild );
+    TIXMLASSERT( _firstChild->_prev == 0 );
+
+    _firstChild->_prev = addThis;
+    addThis->_next = _firstChild;
+    _firstChild = addThis;
+
+    addThis->_prev = 0;
+  }
+  else {
+    TIXMLASSERT( _lastChild == 0 );
+    _firstChild = _lastChild = addThis;
+
+    addThis->_prev = 0;
+    addThis->_next = 0;
+  }
+  addThis->_parent = this;
+  return addThis;
+}
+
+
+XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )
+{
+  TIXMLASSERT( addThis );
+  if ( addThis->_document != _document ) {
+    TIXMLASSERT( false );
+    return 0;
+  }
+
+  TIXMLASSERT( afterThis );
+
+  if ( afterThis->_parent != this ) {
+    TIXMLASSERT( false );
+    return 0;
+  }
+  if ( afterThis == addThis ) {
+    // Current state: BeforeThis -> AddThis -> OneAfterAddThis
+    // Now AddThis must disappear from it's location and then
+    // reappear between BeforeThis and OneAfterAddThis.
+    // So just leave it where it is.
+    return addThis;
+  }
+
+  if ( afterThis->_next == 0 ) {
+    // The last node or the only node.
+    return InsertEndChild( addThis );
+  }
+  InsertChildPreamble( addThis );
+  addThis->_prev = afterThis;
+  addThis->_next = afterThis->_next;
+  afterThis->_next->_prev = addThis;
+  afterThis->_next = addThis;
+  addThis->_parent = this;
+  return addThis;
+}
+
+
+
+
+const XMLElement* XMLNode::FirstChildElement( const char* name ) const
+{
+  for( const XMLNode* node = _firstChild; node; node = node->_next ) {
+    const XMLElement* element = node->ToElementWithName( name );
+    if ( element ) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+
+const XMLElement* XMLNode::LastChildElement( const char* name ) const
+{
+  for( const XMLNode* node = _lastChild; node; node = node->_prev ) {
+    const XMLElement* element = node->ToElementWithName( name );
+    if ( element ) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+
+const XMLElement* XMLNode::NextSiblingElement( const char* name ) const
+{
+  for( const XMLNode* node = _next; node; node = node->_next ) {
+    const XMLElement* element = node->ToElementWithName( name );
+    if ( element ) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+
+const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const
+{
+  for( const XMLNode* node = _prev; node; node = node->_prev ) {
+    const XMLElement* element = node->ToElementWithName( name );
+    if ( element ) {
+      return element;
+    }
+  }
+  return 0;
+}
+
+
+char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
+{
+  // This is a recursive method, but thinking about it "at the current level"
+  // it is a pretty simple flat list:
+  //		<foo/>
+  //		<!-- comment -->
+  //
+  // With a special case:
+  //		<foo>
+  //		</foo>
+  //		<!-- comment -->
+  //
+  // Where the closing element (/foo) *must* be the next thing after the opening
+  // element, and the names must match. BUT the tricky bit is that the closing
+  // element will be read by the child.
+  //
+  // 'endTag' is the end tag for this node, it is returned by a call to a child.
+  // 'parentEnd' is the end tag for the parent, which is filled in and returned.
+
+  XMLDocument::DepthTracker tracker(_document);
+  if (_document->Error())
+    return 0;
+
+  bool first = true;
+  while( p && *p ) {
+    XMLNode* node = 0;
+
+    p = _document->Identify( p, &node, first );
     TIXMLASSERT( p );
-    char* const start = p;
-    int const startLine = _parseCurLineNum;
-    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
-    if( !*p ) {
-        *node = 0;
-        TIXMLASSERT( p );
-        return p;
-    }
-
-    // These strings define the matching patterns:
-    static const char* xmlHeader		= { "<?" };
-    static const char* commentHeader	= { "<!--" };
-    static const char* cdataHeader		= { "<![CDATA[" };
-    static const char* dtdHeader		= { "<!" };
-    static const char* elementHeader	= { "<" };	// and a header for everything else; check last.
-
-    static const int xmlHeaderLen		= 2;
-    static const int commentHeaderLen	= 4;
-    static const int cdataHeaderLen		= 9;
-    static const int dtdHeaderLen		= 2;
-    static const int elementHeaderLen	= 1;
-
-    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );		// use same memory pool
-    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );	// use same memory pool
-    XMLNode* returnNode = 0;
-    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {
-        returnNode = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += xmlHeaderLen;
-    }
-    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {
-        returnNode = CreateUnlinkedNode<XMLComment>( _commentPool );
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += commentHeaderLen;
-    }
-    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {
-        XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
-        returnNode = text;
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += cdataHeaderLen;
-        text->SetCData( true );
-    }
-    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {
-        returnNode = CreateUnlinkedNode<XMLUnknown>( _commentPool );
-        returnNode->_parseLineNum = _parseCurLineNum;
-        p += dtdHeaderLen;
-    }
-    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {
-
-        // Preserve whitespace pedantically before closing tag, when it's immediately after opening tag
-        if (WhitespaceMode() == PEDANTIC_WHITESPACE && first && p != start && *(p + elementHeaderLen) == '/') {
-            returnNode = CreateUnlinkedNode<XMLText>(_textPool);
-            returnNode->_parseLineNum = startLine;
-            p = start;	// Back it up, all the text counts.
-            _parseCurLineNum = startLine;
-        }
-        else {
-            returnNode = CreateUnlinkedNode<XMLElement>(_elementPool);
-            returnNode->_parseLineNum = _parseCurLineNum;
-            p += elementHeaderLen;
-        }
-    }
-    else {
-        returnNode = CreateUnlinkedNode<XMLText>( _textPool );
-        returnNode->_parseLineNum = _parseCurLineNum; // Report line of first non-whitespace character
-        p = start;	// Back it up, all the text counts.
-        _parseCurLineNum = startLine;
-    }
-
-    TIXMLASSERT( returnNode );
-    TIXMLASSERT( p );
-    *node = returnNode;
-    return p;
-}
-
-
-bool XMLDocument::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    if ( visitor->VisitEnter( *this ) ) {
-        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
-            if ( !node->Accept( visitor ) ) {
-                break;
-            }
-        }
-    }
-    return visitor->VisitExit( *this );
-}
-
-
-// --------- XMLNode ----------- //
-
-XMLNode::XMLNode( XMLDocument* doc ) :
-    _document( doc ),
-    _parent( 0 ),
-    _value(),
-    _parseLineNum( 0 ),
-    _firstChild( 0 ), _lastChild( 0 ),
-    _prev( 0 ), _next( 0 ),
-	_userData( 0 ),
-    _memPool( 0 )
-{
-}
-
-
-XMLNode::~XMLNode()
-{
-    DeleteChildren();
-    if ( _parent ) {
-        _parent->Unlink( this );
-    }
-}
-
-// ChildElementCount was originally suggested by msteiger on the sourceforge page for TinyXML and modified by KB1SPH for TinyXML-2.
-
-int XMLNode::ChildElementCount(const char *value) const {
-	int count = 0;
-
-	const XMLElement *e = FirstChildElement(value);
-
-	while (e) {
-		e = e->NextSiblingElement(value);
-		count++;
-	}
-
-	return count;
-}
-
-int XMLNode::ChildElementCount() const {
-	int count = 0;
-
-	const XMLElement *e = FirstChildElement();
-
-	while (e) {
-		e = e->NextSiblingElement();
-		count++;
-	}
-
-	return count;
-}
-
-const char* XMLNode::Value() const
-{
-    // Edge case: XMLDocuments don't have a Value. Return null.
-    if ( this->ToDocument() )
-        return 0;
-    return _value.GetStr();
-}
-
-void XMLNode::SetValue( const char* str, bool staticMem )
-{
-    if ( staticMem ) {
-        _value.SetInternedStr( str );
-    }
-    else {
-        _value.SetStr( str );
-    }
-}
-
-XMLNode* XMLNode::DeepClone(XMLDocument* target) const
-{
-	XMLNode* clone = this->ShallowClone(target);
-	if (!clone) return 0;
-
-	for (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {
-		XMLNode* childClone = child->DeepClone(target);
-		TIXMLASSERT(childClone);
-		clone->InsertEndChild(childClone);
-	}
-	return clone;
-}
-
-void XMLNode::DeleteChildren()
-{
-    while( _firstChild ) {
-        TIXMLASSERT( _lastChild );
-        DeleteChild( _firstChild );
-    }
-    _firstChild = _lastChild = 0;
-}
-
-
-void XMLNode::Unlink( XMLNode* child )
-{
-    TIXMLASSERT( child );
-    TIXMLASSERT( child->_document == _document );
-    TIXMLASSERT( child->_parent == this );
-    if ( child == _firstChild ) {
-        _firstChild = _firstChild->_next;
-    }
-    if ( child == _lastChild ) {
-        _lastChild = _lastChild->_prev;
-    }
-
-    if ( child->_prev ) {
-        child->_prev->_next = child->_next;
-    }
-    if ( child->_next ) {
-        child->_next->_prev = child->_prev;
-    }
-	child->_next = 0;
-	child->_prev = 0;
-	child->_parent = 0;
-}
-
-
-void XMLNode::DeleteChild( XMLNode* node )
-{
-    TIXMLASSERT( node );
-    TIXMLASSERT( node->_document == _document );
-    TIXMLASSERT( node->_parent == this );
-    Unlink( node );
-	TIXMLASSERT(node->_prev == 0);
-	TIXMLASSERT(node->_next == 0);
-	TIXMLASSERT(node->_parent == 0);
-    DeleteNode( node );
-}
-
-
-XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )
-{
-    TIXMLASSERT( addThis );
-    if ( addThis->_document != _document ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-    InsertChildPreamble( addThis );
-
-    if ( _lastChild ) {
-        TIXMLASSERT( _firstChild );
-        TIXMLASSERT( _lastChild->_next == 0 );
-        _lastChild->_next = addThis;
-        addThis->_prev = _lastChild;
-        _lastChild = addThis;
-
-        addThis->_next = 0;
-    }
-    else {
-        TIXMLASSERT( _firstChild == 0 );
-        _firstChild = _lastChild = addThis;
-
-        addThis->_prev = 0;
-        addThis->_next = 0;
-    }
-    addThis->_parent = this;
-    return addThis;
-}
-
-
-XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )
-{
-    TIXMLASSERT( addThis );
-    if ( addThis->_document != _document ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-    InsertChildPreamble( addThis );
-
-    if ( _firstChild ) {
-        TIXMLASSERT( _lastChild );
-        TIXMLASSERT( _firstChild->_prev == 0 );
-
-        _firstChild->_prev = addThis;
-        addThis->_next = _firstChild;
-        _firstChild = addThis;
-
-        addThis->_prev = 0;
-    }
-    else {
-        TIXMLASSERT( _lastChild == 0 );
-        _firstChild = _lastChild = addThis;
-
-        addThis->_prev = 0;
-        addThis->_next = 0;
-    }
-    addThis->_parent = this;
-    return addThis;
-}
-
-
-XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )
-{
-    TIXMLASSERT( addThis );
-    if ( addThis->_document != _document ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-
-    TIXMLASSERT( afterThis );
-
-    if ( afterThis->_parent != this ) {
-        TIXMLASSERT( false );
-        return 0;
-    }
-    if ( afterThis == addThis ) {
-        // Current state: BeforeThis -> AddThis -> OneAfterAddThis
-        // Now AddThis must disappear from it's location and then
-        // reappear between BeforeThis and OneAfterAddThis.
-        // So just leave it where it is.
-        return addThis;
-    }
-
-    if ( afterThis->_next == 0 ) {
-        // The last node or the only node.
-        return InsertEndChild( addThis );
-    }
-    InsertChildPreamble( addThis );
-    addThis->_prev = afterThis;
-    addThis->_next = afterThis->_next;
-    afterThis->_next->_prev = addThis;
-    afterThis->_next = addThis;
-    addThis->_parent = this;
-    return addThis;
-}
-
-
-
-
-const XMLElement* XMLNode::FirstChildElement( const char* name ) const
-{
-    for( const XMLNode* node = _firstChild; node; node = node->_next ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-const XMLElement* XMLNode::LastChildElement( const char* name ) const
-{
-    for( const XMLNode* node = _lastChild; node; node = node->_prev ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-const XMLElement* XMLNode::NextSiblingElement( const char* name ) const
-{
-    for( const XMLNode* node = _next; node; node = node->_next ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const
-{
-    for( const XMLNode* node = _prev; node; node = node->_prev ) {
-        const XMLElement* element = node->ToElementWithName( name );
-        if ( element ) {
-            return element;
-        }
-    }
-    return 0;
-}
-
-
-char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
-{
-    // This is a recursive method, but thinking about it "at the current level"
-    // it is a pretty simple flat list:
-    //		<foo/>
-    //		<!-- comment -->
-    //
-    // With a special case:
-    //		<foo>
-    //		</foo>
-    //		<!-- comment -->
-    //
-    // Where the closing element (/foo) *must* be the next thing after the opening
-    // element, and the names must match. BUT the tricky bit is that the closing
-    // element will be read by the child.
-    //
-    // 'endTag' is the end tag for this node, it is returned by a call to a child.
-    // 'parentEnd' is the end tag for the parent, which is filled in and returned.
-
-	XMLDocument::DepthTracker tracker(_document);
-	if (_document->Error())
-		return 0;
-
-	bool first = true;
-	while( p && *p ) {
-        XMLNode* node = 0;
-
-        p = _document->Identify( p, &node, first );
-        TIXMLASSERT( p );
-        if ( node == 0 ) {
-            break;
-        }
-        first = false;
-
-       const int initialLineNum = node->_parseLineNum;
-
-        StrPair endTag;
-        p = node->ParseDeep( p, &endTag, curLineNumPtr );
-        if ( !p ) {
-            _document->DeleteNode( node );
-            if ( !_document->Error() ) {
-                _document->SetError( XML_ERROR_PARSING, initialLineNum, 0);
-            }
-            break;
-        }
-
-        const XMLDeclaration* const decl = node->ToDeclaration();
-        if ( decl ) {
-            // Declarations are only allowed at document level
-            //
-            // Multiple declarations are allowed but all declarations
-            // must occur before anything else. 
-            //
-            // Optimized due to a security test case. If the first node is 
-            // a declaration, and the last node is a declaration, then only 
-            // declarations have so far been added.
-            bool wellLocated = false;
-
-            if (ToDocument()) {
-                if (FirstChild()) {
-                    wellLocated =
-                        FirstChild() &&
-                        FirstChild()->ToDeclaration() &&
-                        LastChild() &&
-                        LastChild()->ToDeclaration();
-                }
-                else {
-                    wellLocated = true;
-                }
-            }
-            if ( !wellLocated ) {
-                _document->SetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, "XMLDeclaration value=%s", decl->Value());
-                _document->DeleteNode( node );
-                break;
-            }
-        }
-
-        XMLElement* ele = node->ToElement();
-        if ( ele ) {
-            // We read the end tag. Return it to the parent.
-            if ( ele->ClosingType() == XMLElement::CLOSING ) {
-                if ( parentEndTag ) {
-                    ele->_value.TransferTo( parentEndTag );
-                }
-                node->_memPool->SetTracked();   // created and then immediately deleted.
-                DeleteNode( node );
-                return p;
-            }
-
-            // Handle an end tag returned to this level.
-            // And handle a bunch of annoying errors.
-            bool mismatch = false;
-            if ( endTag.Empty() ) {
-                if ( ele->ClosingType() == XMLElement::OPEN ) {
-                    mismatch = true;
-                }
-            }
-            else {
-                if ( ele->ClosingType() != XMLElement::OPEN ) {
-                    mismatch = true;
-                }
-                else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele->Name() ) ) {
-                    mismatch = true;
-                }
-            }
-            if ( mismatch ) {
-                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, "XMLElement name=%s", ele->Name());
-                _document->DeleteNode( node );
-                break;
-            }
-        }
-        InsertEndChild( node );
-    }
-    return 0;
-}
-
-/*static*/ void XMLNode::DeleteNode( XMLNode* node )
-{
     if ( node == 0 ) {
-        return;
-    }
-	TIXMLASSERT(node->_document);
-	if (!node->ToDocument()) {
-		node->_document->MarkInUse(node);
-	}
-
-    MemPool* pool = node->_memPool;
-    node->~XMLNode();
-    pool->Free( node );
-}
-
-void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const
-{
-    TIXMLASSERT( insertThis );
-    TIXMLASSERT( insertThis->_document == _document );
-
-	if (insertThis->_parent) {
-        insertThis->_parent->Unlink( insertThis );
+      break;
+    }
+    first = false;
+
+    const int initialLineNum = node->_parseLineNum;
+
+    StrPair endTag;
+    p = node->ParseDeep( p, &endTag, curLineNumPtr );
+    if ( !p ) {
+      _document->DeleteNode( node );
+      if ( !_document->Error() ) {
+	_document->SetError( XML_ERROR_PARSING, initialLineNum, 0);
+      }
+      break;
+    }
+
+    const XMLDeclaration* const decl = node->ToDeclaration();
+    if ( decl ) {
+      // Declarations are only allowed at document level
+      //
+      // Multiple declarations are allowed but all declarations
+      // must occur before anything else.
+      //
+      // Optimized due to a security test case. If the first node is
+      // a declaration, and the last node is a declaration, then only
+      // declarations have so far been added.
+      bool wellLocated = false;
+
+      if (ToDocument()) {
+	if (FirstChild()) {
+	  wellLocated =
+	    FirstChild() &&
+	    FirstChild()->ToDeclaration() &&
+	    LastChild() &&
+	    LastChild()->ToDeclaration();
 	}
 	else {
-		insertThis->_document->MarkInUse(insertThis);
-        insertThis->_memPool->SetTracked();
+	  wellLocated = true;
 	}
+      }
+      if ( !wellLocated ) {
+	_document->SetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, "XMLDeclaration value=%s", decl->Value());
+	_document->DeleteNode( node );
+	break;
+      }
+    }
+
+    XMLElement* ele = node->ToElement();
+    if ( ele ) {
+      // We read the end tag. Return it to the parent.
+      if ( ele->ClosingType() == XMLElement::CLOSING ) {
+	if ( parentEndTag ) {
+	  ele->_value.TransferTo( parentEndTag );
+	}
+	node->_memPool->SetTracked();           // created and then immediately deleted.
+	DeleteNode( node );
+	return p;
+      }
+
+      // Handle an end tag returned to this level.
+      // And handle a bunch of annoying errors.
+      bool mismatch = false;
+      if ( endTag.Empty() ) {
+	if ( ele->ClosingType() == XMLElement::OPEN ) {
+	  mismatch = true;
+	}
+      }
+      else {
+	if ( ele->ClosingType() != XMLElement::OPEN ) {
+	  mismatch = true;
+	}
+	else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele->Name() ) ) {
+	  mismatch = true;
+	}
+      }
+      if ( mismatch ) {
+	_document->SetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, "XMLElement name=%s", ele->Name());
+	_document->DeleteNode( node );
+	break;
+      }
+    }
+    InsertEndChild( node );
+  }
+  return 0;
+}
+
+/*static*/ void XMLNode::DeleteNode( XMLNode* node )
+{
+  if ( node == 0 ) {
+    return;
+  }
+  TIXMLASSERT(node->_document);
+  if (!node->ToDocument()) {
+    node->_document->MarkInUse(node);
+  }
+
+  MemPool* pool = node->_memPool;
+  node->~XMLNode();
+  pool->Free( node );
+}
+
+void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const
+{
+  TIXMLASSERT( insertThis );
+  TIXMLASSERT( insertThis->_document == _document );
+
+  if (insertThis->_parent) {
+    insertThis->_parent->Unlink( insertThis );
+  }
+  else {
+    insertThis->_document->MarkInUse(insertThis);
+    insertThis->_memPool->SetTracked();
+  }
 }
 
 const XMLElement* XMLNode::ToElementWithName( const char* name ) const
 {
-    const XMLElement* element = this->ToElement();
-    if ( element == 0 ) {
-        return 0;
-    }
-    if ( name == 0 ) {
-        return element;
-    }
-    if ( XMLUtil::StringEqual( element->Name(), name ) ) {
-       return element;
-    }
+  const XMLElement* element = this->ToElement();
+  if ( element == 0 ) {
     return 0;
+  }
+  if ( name == 0 ) {
+    return element;
+  }
+  if ( XMLUtil::StringEqual( element->Name(), name ) ) {
+    return element;
+  }
+  return 0;
 }
 
 // --------- XMLText ---------- //
 char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
 {
-    if ( this->CData() ) {
-        p = _value.ParseText( p, "]]>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
-        if ( !p ) {
-            _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );
-        }
-        return p;
-    }
-    else {
-        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
-        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {
-            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
-        }
-
-        p = _value.ParseText( p, "<", flags, curLineNumPtr );
-        if ( p && *p ) {
-            return p-1;
-        }
-        if ( !p ) {
-            _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );
-        }
-    }
+  if ( this->CData() ) {
+    p = _value.ParseText( p, "]]>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
+    if ( !p ) {
+      _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );
+    }
+    return p;
+  }
+  else {
+    int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
+    if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {
+      flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
+    }
+
+    p = _value.ParseText( p, "<", flags, curLineNumPtr );
+    if ( p && *p ) {
+      return p-1;
+    }
+    if ( !p ) {
+      _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );
+    }
+  }
+  return 0;
+}
+
+
+XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const
+{
+  if ( !doc ) {
+    doc = _document;
+  }
+  XMLText* text = doc->NewText( Value() );      // fixme: this will always allocate memory. Intern?
+  text->SetCData( this->CData() );
+  return text;
+}
+
+
+bool XMLText::ShallowEqual( const XMLNode* compare ) const
+{
+  TIXMLASSERT( compare );
+  const XMLText* text = compare->ToText();
+  return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );
+}
+
+
+bool XMLText::Accept( XMLVisitor* visitor ) const
+{
+  TIXMLASSERT( visitor );
+  return visitor->Visit( *this );
+}
+
+
+// --------- XMLComment ---------- //
+
+XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )
+{
+}
+
+
+XMLComment::~XMLComment()
+{
+}
+
+
+char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
+{
+  // Comment parses as text.
+  p = _value.ParseText( p, "-->", StrPair::COMMENT, curLineNumPtr );
+  if ( p == 0 ) {
+    _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );
+  }
+  return p;
+}
+
+
+XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const
+{
+  if ( !doc ) {
+    doc = _document;
+  }
+  XMLComment* comment = doc->NewComment( Value() );     // fixme: this will always allocate memory. Intern?
+  return comment;
+}
+
+
+bool XMLComment::ShallowEqual( const XMLNode* compare ) const
+{
+  TIXMLASSERT( compare );
+  const XMLComment* comment = compare->ToComment();
+  return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));
+}
+
+
+bool XMLComment::Accept( XMLVisitor* visitor ) const
+{
+  TIXMLASSERT( visitor );
+  return visitor->Visit( *this );
+}
+
+
+// --------- XMLDeclaration ---------- //
+
+XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )
+{
+}
+
+
+XMLDeclaration::~XMLDeclaration()
+{
+  //printf( "~XMLDeclaration\n" );
+}
+
+
+char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
+{
+  // Declaration parses as text.
+  p = _value.ParseText( p, "?>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
+  if ( p == 0 ) {
+    _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );
+  }
+  return p;
+}
+
+
+XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const
+{
+  if ( !doc ) {
+    doc = _document;
+  }
+  XMLDeclaration* dec = doc->NewDeclaration( Value() );         // fixme: this will always allocate memory. Intern?
+  return dec;
+}
+
+
+bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const
+{
+  TIXMLASSERT( compare );
+  const XMLDeclaration* declaration = compare->ToDeclaration();
+  return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));
+}
+
+
+
+bool XMLDeclaration::Accept( XMLVisitor* visitor ) const
+{
+  TIXMLASSERT( visitor );
+  return visitor->Visit( *this );
+}
+
+// --------- XMLUnknown ---------- //
+
+XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )
+{
+}
+
+
+XMLUnknown::~XMLUnknown()
+{
+}
+
+
+char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
+{
+  // Unknown parses as text.
+  p = _value.ParseText( p, ">", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
+  if ( !p ) {
+    _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );
+  }
+  return p;
+}
+
+
+XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const
+{
+  if ( !doc ) {
+    doc = _document;
+  }
+  XMLUnknown* text = doc->NewUnknown( Value() );        // fixme: this will always allocate memory. Intern?
+  return text;
+}
+
+
+bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const
+{
+  TIXMLASSERT( compare );
+  const XMLUnknown* unknown = compare->ToUnknown();
+  return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));
+}
+
+
+bool XMLUnknown::Accept( XMLVisitor* visitor ) const
+{
+  TIXMLASSERT( visitor );
+  return visitor->Visit( *this );
+}
+
+// --------- XMLAttribute ---------- //
+
+const char* XMLAttribute::Name() const
+{
+  return _name.GetStr();
+}
+
+const char* XMLAttribute::Value() const
+{
+  return _value.GetStr();
+}
+
+char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )
+{
+  // Parse using the name rules: bug fix, was using ParseText before
+  p = _name.ParseName( p );
+  if ( !p || !*p ) {
     return 0;
-}
-
-
-XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLText* text = doc->NewText( Value() );	// fixme: this will always allocate memory. Intern?
-    text->SetCData( this->CData() );
-    return text;
-}
-
-
-bool XMLText::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLText* text = compare->ToText();
-    return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );
-}
-
-
-bool XMLText::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-
-// --------- XMLComment ---------- //
-
-XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )
-{
-}
-
-
-XMLComment::~XMLComment()
-{
-}
-
-
-char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
-{
-    // Comment parses as text.
-    p = _value.ParseText( p, "-->", StrPair::COMMENT, curLineNumPtr );
-    if ( p == 0 ) {
-        _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );
-    }
-    return p;
-}
-
-
-XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLComment* comment = doc->NewComment( Value() );	// fixme: this will always allocate memory. Intern?
-    return comment;
-}
-
-
-bool XMLComment::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLComment* comment = compare->ToComment();
-    return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));
-}
-
-
-bool XMLComment::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-
-// --------- XMLDeclaration ---------- //
-
-XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )
-{
-}
-
-
-XMLDeclaration::~XMLDeclaration()
-{
-    //printf( "~XMLDeclaration\n" );
-}
-
-
-char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
-{
-    // Declaration parses as text.
-    p = _value.ParseText( p, "?>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
-    if ( p == 0 ) {
-        _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );
-    }
-    return p;
-}
-
-
-XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLDeclaration* dec = doc->NewDeclaration( Value() );	// fixme: this will always allocate memory. Intern?
-    return dec;
-}
-
-
-bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLDeclaration* declaration = compare->ToDeclaration();
-    return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));
-}
-
-
-
-bool XMLDeclaration::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-// --------- XMLUnknown ---------- //
-
-XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )
-{
-}
-
-
-XMLUnknown::~XMLUnknown()
-{
-}
-
-
-char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
-{
-    // Unknown parses as text.
-    p = _value.ParseText( p, ">", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
-    if ( !p ) {
-        _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );
-    }
-    return p;
-}
-
-
-XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const
-{
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLUnknown* text = doc->NewUnknown( Value() );	// fixme: this will always allocate memory. Intern?
-    return text;
-}
-
-
-bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const
-{
-    TIXMLASSERT( compare );
-    const XMLUnknown* unknown = compare->ToUnknown();
-    return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));
-}
-
-
-bool XMLUnknown::Accept( XMLVisitor* visitor ) const
-{
-    TIXMLASSERT( visitor );
-    return visitor->Visit( *this );
-}
-
-// --------- XMLAttribute ---------- //
-
-const char* XMLAttribute::Name() const
-{
-    return _name.GetStr();
-}
-
-const char* XMLAttribute::Value() const
-{
-    return _value.GetStr();
-}
-
-char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )
-{
-    // Parse using the name rules: bug fix, was using ParseText before
-    p = _name.ParseName( p );
-    if ( !p || !*p ) {
-        return 0;
-    }
-
-    // Skip white space before =
-    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-    if ( *p != '=' ) {
-        return 0;
-    }
-
-    ++p;	// move up to opening quote
-    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-    if ( *p != '\"' && *p != '\'' ) {
-        return 0;
-    }
-
-    const char endTag[2] = { *p, 0 };
-    ++p;	// move past opening quote
-
-    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );
-    return p;
+  }
+
+  // Skip white space before =
+  p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
+  if ( *p != '=' ) {
+    return 0;
+  }
+
+  ++p;          // move up to opening quote
+  p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
+  if ( *p != '\"' && *p != '\'' ) {
+    return 0;
+  }
+
+  const char endTag[2] = { *p, 0 };
+  ++p;          // move past opening quote
+
+  p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );
+  return p;
 }
 
 
 void XMLAttribute::SetName( const char* n )
 {
-    _name.SetStr( n );
+  _name.SetStr( n );
 }
 
 
 XMLError XMLAttribute::QueryIntValue( int* value ) const
 {
-    if ( XMLUtil::ToInt( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
+  if ( XMLUtil::ToInt( Value(), value )) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
 }
 
 
 XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const
 {
-    if ( XMLUtil::ToUnsigned( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
+  if ( XMLUtil::ToUnsigned( Value(), value )) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
 }
 
 
 XMLError XMLAttribute::QueryInt64Value(int64_t* value) const
 {
-	if (XMLUtil::ToInt64(Value(), value)) {
-		return XML_SUCCESS;
-	}
-	return XML_WRONG_ATTRIBUTE_TYPE;
+  if (XMLUtil::ToInt64(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
 }
 
 
 XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const
 {
-    if(XMLUtil::ToUnsigned64(Value(), value)) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
+  if(XMLUtil::ToUnsigned64(Value(), value)) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
 }
 
 
 XMLError XMLAttribute::QueryBoolValue( bool* value ) const
 {
-    if ( XMLUtil::ToBool( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
+  if ( XMLUtil::ToBool( Value(), value )) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
 }
 
 
 XMLError XMLAttribute::QueryFloatValue( float* value ) const
 {
-    if ( XMLUtil::ToFloat( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
+  if ( XMLUtil::ToFloat( Value(), value )) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
 }
 
 
 XMLError XMLAttribute::QueryDoubleValue( double* value ) const
 {
-    if ( XMLUtil::ToDouble( Value(), value )) {
-        return XML_SUCCESS;
-    }
-    return XML_WRONG_ATTRIBUTE_TYPE;
+  if ( XMLUtil::ToDouble( Value(), value )) {
+    return XML_SUCCESS;
+  }
+  return XML_WRONG_ATTRIBUTE_TYPE;
 }
 
 
 void XMLAttribute::SetAttribute( const char* v )
 {
-    _value.SetStr( v );
+  _value.SetStr( v );
 }
 
 
 void XMLAttribute::SetAttribute( int v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  _value.SetStr( buf );
 }
 
 
 void XMLAttribute::SetAttribute( unsigned v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  _value.SetStr( buf );
 }
 
 
 void XMLAttribute::SetAttribute(int64_t v)
 {
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	_value.SetStr(buf);
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
 }
 
 void XMLAttribute::SetAttribute(uint64_t v)
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr(v, buf, BUF_SIZE);
-    _value.SetStr(buf);
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  _value.SetStr(buf);
 }
 
 
 void XMLAttribute::SetAttribute( bool v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  _value.SetStr( buf );
 }
 
 void XMLAttribute::SetAttribute( double v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  _value.SetStr( buf );
 }
 
 void XMLAttribute::SetAttribute( float v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    _value.SetStr( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  _value.SetStr( buf );
 }
 
 
 // --------- XMLElement ---------- //
 XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),
-    _closingType( OPEN ),
-    _rootAttribute( 0 )
+  _closingType( OPEN ),
+  _rootAttribute( 0 )
 {
 }
 
 
 XMLElement::~XMLElement()
 {
-    while( _rootAttribute ) {
-        XMLAttribute* next = _rootAttribute->_next;
-        DeleteAttribute( _rootAttribute );
-        _rootAttribute = next;
-    }
+  while( _rootAttribute ) {
+    XMLAttribute* next = _rootAttribute->_next;
+    DeleteAttribute( _rootAttribute );
+    _rootAttribute = next;
+  }
 }
 
 
 const XMLAttribute* XMLElement::FindAttribute( const char* name ) const
 {
-    for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {
-        if ( XMLUtil::StringEqual( a->Name(), name ) ) {
-            return a;
-        }
-    }
+  for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {
+    if ( XMLUtil::StringEqual( a->Name(), name ) ) {
+      return a;
+    }
+  }
+  return 0;
+}
+
+
+const char* XMLElement::Attribute( const char* name, const char* value ) const
+{
+  const XMLAttribute* a = FindAttribute( name );
+  if ( !a ) {
     return 0;
-}
-
-
-const char* XMLElement::Attribute( const char* name, const char* value ) const
-{
-    const XMLAttribute* a = FindAttribute( name );
-    if ( !a ) {
-        return 0;
-    }
-    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {
-        return a->Value();
-    }
-    return 0;
+  }
+  if ( !value || XMLUtil::StringEqual( a->Value(), value )) {
+    return a->Value();
+  }
+  return 0;
 }
 
 int XMLElement::IntAttribute(const char* name, int defaultValue) const
 {
-	int i = defaultValue;
-	QueryIntAttribute(name, &i);
-	return i;
+  int i = defaultValue;
+  QueryIntAttribute(name, &i);
+  return i;
 }
 
 unsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const
 {
-	unsigned i = defaultValue;
-	QueryUnsignedAttribute(name, &i);
-	return i;
+  unsigned i = defaultValue;
+  QueryUnsignedAttribute(name, &i);
+  return i;
 }
 
 int64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const
 {
-	int64_t i = defaultValue;
-	QueryInt64Attribute(name, &i);
-	return i;
+  int64_t i = defaultValue;
+  QueryInt64Attribute(name, &i);
+  return i;
 }
 
 uint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const
 {
-	uint64_t i = defaultValue;
-	QueryUnsigned64Attribute(name, &i);
-	return i;
+  uint64_t i = defaultValue;
+  QueryUnsigned64Attribute(name, &i);
+  return i;
 }
 
 bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const
 {
-	bool b = defaultValue;
-	QueryBoolAttribute(name, &b);
-	return b;
+  bool b = defaultValue;
+  QueryBoolAttribute(name, &b);
+  return b;
 }
 
 double XMLElement::DoubleAttribute(const char* name, double defaultValue) const
 {
-	double d = defaultValue;
-	QueryDoubleAttribute(name, &d);
-	return d;
+  double d = defaultValue;
+  QueryDoubleAttribute(name, &d);
+  return d;
 }
 
 float XMLElement::FloatAttribute(const char* name, float defaultValue) const
 {
-	float f = defaultValue;
-	QueryFloatAttribute(name, &f);
-	return f;
+  float f = defaultValue;
+  QueryFloatAttribute(name, &f);
+  return f;
 }
 
 const char* XMLElement::GetText() const
 {
-    /* skip comment node */
-    const XMLNode* node = FirstChild();
-    while (node) {
-        if (node->ToComment()) {
-            node = node->NextSibling();
-            continue;
-        }
-        break;
-    }
-
-    if ( node && node->ToText() ) {
-        return node->Value();
-    }
-    return 0;
-}
-
-
-void	XMLElement::SetText( const char* inText )
-{
-	if ( FirstChild() && FirstChild()->ToText() )
-		FirstChild()->SetValue( inText );
-	else {
-		XMLText*	theText = GetDocument()->NewText( inText );
-		InsertFirstChild( theText );
-	}
+  /* skip comment node */
+  const XMLNode* node = FirstChild();
+  while (node) {
+    if (node->ToComment()) {
+      node = node->NextSibling();
+      continue;
+    }
+    break;
+  }
+
+  if ( node && node->ToText() ) {
+    return node->Value();
+  }
+  return 0;
+}
+
+
+void XMLElement::SetText( const char* inText )
+{
+  if ( FirstChild() && FirstChild()->ToText() )
+    FirstChild()->SetValue( inText );
+  else {
+    XMLText*        theText = GetDocument()->NewText( inText );
+    InsertFirstChild( theText );
+  }
 }
 
 
 void XMLElement::SetText( int v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  SetText( buf );
 }
 
 
 void XMLElement::SetText( unsigned v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  SetText( buf );
 }
 
 
 void XMLElement::SetText(int64_t v)
 {
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	SetText(buf);
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
 }
 
 void XMLElement::SetText(uint64_t v) {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr(v, buf, BUF_SIZE);
-    SetText(buf);
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  SetText(buf);
 }
 
 
 void XMLElement::SetText( bool v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  SetText( buf );
 }
 
 
 void XMLElement::SetText( float v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  SetText( buf );
 }
 
 
 void XMLElement::SetText( double v )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    SetText( buf );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  SetText( buf );
 }
 
 
 XMLError XMLElement::QueryIntText( int* ival ) const
 {
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToInt( t, ival ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
+  if ( FirstChild() && FirstChild()->ToText() ) {
+    const char* t = FirstChild()->Value();
+    if ( XMLUtil::ToInt( t, ival ) ) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
 }
 
 
 XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const
 {
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToUnsigned( t, uval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
+  if ( FirstChild() && FirstChild()->ToText() ) {
+    const char* t = FirstChild()->Value();
+    if ( XMLUtil::ToUnsigned( t, uval ) ) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
 }
 
 
 XMLError XMLElement::QueryInt64Text(int64_t* ival) const
 {
-	if (FirstChild() && FirstChild()->ToText()) {
-		const char* t = FirstChild()->Value();
-		if (XMLUtil::ToInt64(t, ival)) {
-			return XML_SUCCESS;
-		}
-		return XML_CAN_NOT_CONVERT_TEXT;
-	}
-	return XML_NO_TEXT_NODE;
+  if (FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if (XMLUtil::ToInt64(t, ival)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
 }
 
 
 XMLError XMLElement::QueryUnsigned64Text(uint64_t* uval) const
 {
-    if(FirstChild() && FirstChild()->ToText()) {
-        const char* t = FirstChild()->Value();
-        if(XMLUtil::ToUnsigned64(t, uval)) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
+  if(FirstChild() && FirstChild()->ToText()) {
+    const char* t = FirstChild()->Value();
+    if(XMLUtil::ToUnsigned64(t, uval)) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
 }
 
 
 XMLError XMLElement::QueryBoolText( bool* bval ) const
 {
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToBool( t, bval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
+  if ( FirstChild() && FirstChild()->ToText() ) {
+    const char* t = FirstChild()->Value();
+    if ( XMLUtil::ToBool( t, bval ) ) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
 }
 
 
 XMLError XMLElement::QueryDoubleText( double* dval ) const
 {
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToDouble( t, dval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
+  if ( FirstChild() && FirstChild()->ToText() ) {
+    const char* t = FirstChild()->Value();
+    if ( XMLUtil::ToDouble( t, dval ) ) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
 }
 
 
 XMLError XMLElement::QueryFloatText( float* fval ) const
 {
-    if ( FirstChild() && FirstChild()->ToText() ) {
-        const char* t = FirstChild()->Value();
-        if ( XMLUtil::ToFloat( t, fval ) ) {
-            return XML_SUCCESS;
-        }
-        return XML_CAN_NOT_CONVERT_TEXT;
-    }
-    return XML_NO_TEXT_NODE;
+  if ( FirstChild() && FirstChild()->ToText() ) {
+    const char* t = FirstChild()->Value();
+    if ( XMLUtil::ToFloat( t, fval ) ) {
+      return XML_SUCCESS;
+    }
+    return XML_CAN_NOT_CONVERT_TEXT;
+  }
+  return XML_NO_TEXT_NODE;
 }
 
 int XMLElement::IntText(int defaultValue) const
 {
-	int i = defaultValue;
-	QueryIntText(&i);
-	return i;
+  int i = defaultValue;
+  QueryIntText(&i);
+  return i;
 }
 
 unsigned XMLElement::UnsignedText(unsigned defaultValue) const
 {
-	unsigned i = defaultValue;
-	QueryUnsignedText(&i);
-	return i;
+  unsigned i = defaultValue;
+  QueryUnsignedText(&i);
+  return i;
 }
 
 int64_t XMLElement::Int64Text(int64_t defaultValue) const
 {
-	int64_t i = defaultValue;
-	QueryInt64Text(&i);
-	return i;
+  int64_t i = defaultValue;
+  QueryInt64Text(&i);
+  return i;
 }
 
 uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const
 {
-	uint64_t i = defaultValue;
-	QueryUnsigned64Text(&i);
-	return i;
+  uint64_t i = defaultValue;
+  QueryUnsigned64Text(&i);
+  return i;
 }
 
 bool XMLElement::BoolText(bool defaultValue) const
 {
-	bool b = defaultValue;
-	QueryBoolText(&b);
-	return b;
+  bool b = defaultValue;
+  QueryBoolText(&b);
+  return b;
 }
 
 double XMLElement::DoubleText(double defaultValue) const
 {
-	double d = defaultValue;
-	QueryDoubleText(&d);
-	return d;
+  double d = defaultValue;
+  QueryDoubleText(&d);
+  return d;
 }
 
 float XMLElement::FloatText(float defaultValue) const
 {
-	float f = defaultValue;
-	QueryFloatText(&f);
-	return f;
+  float f = defaultValue;
+  QueryFloatText(&f);
+  return f;
 }
 
 
 XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )
 {
-    XMLAttribute* last = 0;
-    XMLAttribute* attrib = 0;
-    for( attrib = _rootAttribute;
-            attrib;
-            last = attrib, attrib = attrib->_next ) {
-        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {
-            break;
-        }
-    }
-    if ( !attrib ) {
-        attrib = CreateAttribute();
-        TIXMLASSERT( attrib );
-        if ( last ) {
-            TIXMLASSERT( last->_next == 0 );
-            last->_next = attrib;
-        }
-        else {
-            TIXMLASSERT( _rootAttribute == 0 );
-            _rootAttribute = attrib;
-        }
-        attrib->SetName( name );
-    }
-    return attrib;
+  XMLAttribute* last = 0;
+  XMLAttribute* attrib = 0;
+  for( attrib = _rootAttribute;
+       attrib;
+       last = attrib, attrib = attrib->_next ) {
+    if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {
+      break;
+    }
+  }
+  if ( !attrib ) {
+    attrib = CreateAttribute();
+    TIXMLASSERT( attrib );
+    if ( last ) {
+      TIXMLASSERT( last->_next == 0 );
+      last->_next = attrib;
+    }
+    else {
+      TIXMLASSERT( _rootAttribute == 0 );
+      _rootAttribute = attrib;
+    }
+    attrib->SetName( name );
+  }
+  return attrib;
 }
 
 
 void XMLElement::DeleteAttribute( const char* name )
 {
-    XMLAttribute* prev = 0;
-    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {
-        if ( XMLUtil::StringEqual( name, a->Name() ) ) {
-            if ( prev ) {
-                prev->_next = a->_next;
-            }
-            else {
-                _rootAttribute = a->_next;
-            }
-            DeleteAttribute( a );
-            break;
-        }
-        prev = a;
-    }
+  XMLAttribute* prev = 0;
+  for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {
+    if ( XMLUtil::StringEqual( name, a->Name() ) ) {
+      if ( prev ) {
+	prev->_next = a->_next;
+      }
+      else {
+	_rootAttribute = a->_next;
+      }
+      DeleteAttribute( a );
+      break;
+    }
+    prev = a;
+  }
 }
 
 
 char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )
 {
-    XMLAttribute* prevAttribute = 0;
-
-    // Read the attributes.
-    while( p ) {
-        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-        if ( !(*p) ) {
-            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, "XMLElement name=%s", Name() );
-            return 0;
-        }
-
-        // attribute.
-        if (XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
-            XMLAttribute* attrib = CreateAttribute();
-            TIXMLASSERT( attrib );
-            attrib->_parseLineNum = _document->_parseCurLineNum;
-
-            const int attrLineNum = attrib->_parseLineNum;
-
-            p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );
-            if ( !p || Attribute( attrib->Name() ) ) {
-                DeleteAttribute( attrib );
-                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, "XMLElement name=%s", Name() );
-                return 0;
-            }
-            // There is a minor bug here: if the attribute in the source xml
-            // document is duplicated, it will not be detected and the
-            // attribute will be doubly added. However, tracking the 'prevAttribute'
-            // avoids re-scanning the attribute list. Preferring performance for
-            // now, may reconsider in the future.
-            if ( prevAttribute ) {
-                TIXMLASSERT( prevAttribute->_next == 0 );
-                prevAttribute->_next = attrib;
-            }
-            else {
-                TIXMLASSERT( _rootAttribute == 0 );
-                _rootAttribute = attrib;
-            }
-            prevAttribute = attrib;
-        }
-        // end of the tag
-        else if ( *p == '>' ) {
-            ++p;
-            break;
-        }
-        // end of the tag
-        else if ( *p == '/' && *(p+1) == '>' ) {
-            _closingType = CLOSED;
-            return p+2;	// done; sealed element.
-        }
-        else {
-            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );
-            return 0;
-        }
-    }
-    return p;
+  XMLAttribute* prevAttribute = 0;
+
+  // Read the attributes.
+  while( p ) {
+    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
+    if ( !(*p) ) {
+      _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, "XMLElement name=%s", Name() );
+      return 0;
+    }
+
+    // attribute.
+    if (XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
+      XMLAttribute* attrib = CreateAttribute();
+      TIXMLASSERT( attrib );
+      attrib->_parseLineNum = _document->_parseCurLineNum;
+
+      const int attrLineNum = attrib->_parseLineNum;
+
+      p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );
+      if ( !p || Attribute( attrib->Name() ) ) {
+	DeleteAttribute( attrib );
+	_document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, "XMLElement name=%s", Name() );
+	return 0;
+      }
+      // There is a minor bug here: if the attribute in the source xml
+      // document is duplicated, it will not be detected and the
+      // attribute will be doubly added. However, tracking the 'prevAttribute'
+      // avoids re-scanning the attribute list. Preferring performance for
+      // now, may reconsider in the future.
+      if ( prevAttribute ) {
+	TIXMLASSERT( prevAttribute->_next == 0 );
+	prevAttribute->_next = attrib;
+      }
+      else {
+	TIXMLASSERT( _rootAttribute == 0 );
+	_rootAttribute = attrib;
+      }
+      prevAttribute = attrib;
+    }
+    // end of the tag
+    else if ( *p == '>' ) {
+      ++p;
+      break;
+    }
+    // end of the tag
+    else if ( *p == '/' && *(p+1) == '>' ) {
+      _closingType = CLOSED;
+      return p+2;       // done; sealed element.
+    }
+    else {
+      _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );
+      return 0;
+    }
+  }
+  return p;
 }
 
 void XMLElement::DeleteAttribute( XMLAttribute* attribute )
 {
-    if ( attribute == 0 ) {
-        return;
-    }
-    MemPool* pool = attribute->_memPool;
-    attribute->~XMLAttribute();
-    pool->Free( attribute );
+  if ( attribute == 0 ) {
+    return;
+  }
+  MemPool* pool = attribute->_memPool;
+  attribute->~XMLAttribute();
+  pool->Free( attribute );
 }
 
 XMLAttribute* XMLElement::CreateAttribute()
 {
-    TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );
-    XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();
-    TIXMLASSERT( attrib );
-    attrib->_memPool = &_document->_attributePool;
-    attrib->_memPool->SetTracked();
-    return attrib;
+  TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );
+  XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();
+  TIXMLASSERT( attrib );
+  attrib->_memPool = &_document->_attributePool;
+  attrib->_memPool->SetTracked();
+  return attrib;
 }
 
 
 XMLElement* XMLElement::InsertNewChildElement(const char* name)
 {
-    XMLElement* node = _document->NewElement(name);
-    return InsertEndChild(node) ? node : 0;
+  XMLElement* node = _document->NewElement(name);
+  return InsertEndChild(node) ? node : 0;
 }
 
 XMLComment* XMLElement::InsertNewComment(const char* comment)
 {
-    XMLComment* node = _document->NewComment(comment);
-    return InsertEndChild(node) ? node : 0;
+  XMLComment* node = _document->NewComment(comment);
+  return InsertEndChild(node) ? node : 0;
 }
 
 XMLText* XMLElement::InsertNewText(const char* text)
 {
-    XMLText* node = _document->NewText(text);
-    return InsertEndChild(node) ? node : 0;
+  XMLText* node = _document->NewText(text);
+  return InsertEndChild(node) ? node : 0;
 }
 
 XMLDeclaration* XMLElement::InsertNewDeclaration(const char* text)
 {
-    XMLDeclaration* node = _document->NewDeclaration(text);
-    return InsertEndChild(node) ? node : 0;
+  XMLDeclaration* node = _document->NewDeclaration(text);
+  return InsertEndChild(node) ? node : 0;
 }
 
 XMLUnknown* XMLElement::InsertNewUnknown(const char* text)
 {
-    XMLUnknown* node = _document->NewUnknown(text);
-    return InsertEndChild(node) ? node : 0;
+  XMLUnknown* node = _document->NewUnknown(text);
+  return InsertEndChild(node) ? node : 0;
 }
 
 
@@ -2074,83 +2074,83 @@

 //
 char* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
 {
-    // Read the element name.
-    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
-
-    // The closing element is the </element> form. It is
-    // parsed just like a regular element then deleted from
-    // the DOM.
-    if ( *p == '/' ) {
-        _closingType = CLOSING;
-        ++p;
-    }
-
-    p = _value.ParseName( p );
-    if ( _value.Empty() ) {
-        return 0;
-    }
-
-    p = ParseAttributes( p, curLineNumPtr );
-    if ( !p || !*p || _closingType != OPEN ) {
-        return p;
-    }
-
-    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );
+  // Read the element name.
+  p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
+
+  // The closing element is the </element> form. It is
+  // parsed just like a regular element then deleted from
+  // the DOM.
+  if ( *p == '/' ) {
+    _closingType = CLOSING;
+    ++p;
+  }
+
+  p = _value.ParseName( p );
+  if ( _value.Empty() ) {
+    return 0;
+  }
+
+  p = ParseAttributes( p, curLineNumPtr );
+  if ( !p || !*p || _closingType != OPEN ) {
     return p;
+  }
+
+  p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );
+  return p;
 }
 
 
 
 XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const
 {
-    if ( !doc ) {
-        doc = _document;
-    }
-    XMLElement* element = doc->NewElement( Value() );					// fixme: this will always allocate memory. Intern?
-    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {
-        element->SetAttribute( a->Name(), a->Value() );					// fixme: this will always allocate memory. Intern?
-    }
-    return element;
+  if ( !doc ) {
+    doc = _document;
+  }
+  XMLElement* element = doc->NewElement( Value() );                                     // fixme: this will always allocate memory. Intern?
+  for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {
+    element->SetAttribute( a->Name(), a->Value() );                                     // fixme: this will always allocate memory. Intern?
+  }
+  return element;
 }
 
 
 bool XMLElement::ShallowEqual( const XMLNode* compare ) const
 {
-    TIXMLASSERT( compare );
-    const XMLElement* other = compare->ToElement();
-    if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {
-
-        const XMLAttribute* a=FirstAttribute();
-        const XMLAttribute* b=other->FirstAttribute();
-
-        while ( a && b ) {
-            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {
-                return false;
-            }
-            a = a->Next();
-            b = b->Next();
-        }
-        if ( a || b ) {
-            // different count
-            return false;
-        }
-        return true;
-    }
-    return false;
+  TIXMLASSERT( compare );
+  const XMLElement* other = compare->ToElement();
+  if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {
+
+    const XMLAttribute* a=FirstAttribute();
+    const XMLAttribute* b=other->FirstAttribute();
+
+    while ( a && b ) {
+      if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {
+	return false;
+      }
+      a = a->Next();
+      b = b->Next();
+    }
+    if ( a || b ) {
+      // different count
+      return false;
+    }
+    return true;
+  }
+  return false;
 }
 
 
 bool XMLElement::Accept( XMLVisitor* visitor ) const
 {
-    TIXMLASSERT( visitor );
-    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {
-        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
-            if ( !node->Accept( visitor ) ) {
-                break;
-            }
-        }
-    }
-    return visitor->VisitExit( *this );
+  TIXMLASSERT( visitor );
+  if ( visitor->VisitEnter( *this, _rootAttribute ) ) {
+    for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
+      if ( !node->Accept( visitor ) ) {
+	break;
+      }
+    }
+  }
+  return visitor->VisitExit( *this );
 }
 
 
@@ -2158,862 +2158,862 @@

 
 // Warning: List must match 'enum XMLError'
 const char* XMLDocument::_errorNames[XML_ERROR_COUNT] = {
-    "XML_SUCCESS",
-    "XML_NO_ATTRIBUTE",
-    "XML_WRONG_ATTRIBUTE_TYPE",
-    "XML_ERROR_FILE_NOT_FOUND",
-    "XML_ERROR_FILE_COULD_NOT_BE_OPENED",
-    "XML_ERROR_FILE_READ_ERROR",
-    "XML_ERROR_PARSING_ELEMENT",
-    "XML_ERROR_PARSING_ATTRIBUTE",
-    "XML_ERROR_PARSING_TEXT",
-    "XML_ERROR_PARSING_CDATA",
-    "XML_ERROR_PARSING_COMMENT",
-    "XML_ERROR_PARSING_DECLARATION",
-    "XML_ERROR_PARSING_UNKNOWN",
-    "XML_ERROR_EMPTY_DOCUMENT",
-    "XML_ERROR_MISMATCHED_ELEMENT",
-    "XML_ERROR_PARSING",
-    "XML_CAN_NOT_CONVERT_TEXT",
-    "XML_NO_TEXT_NODE",
-	"XML_ELEMENT_DEPTH_EXCEEDED"
+  "XML_SUCCESS",
+  "XML_NO_ATTRIBUTE",
+  "XML_WRONG_ATTRIBUTE_TYPE",
+  "XML_ERROR_FILE_NOT_FOUND",
+  "XML_ERROR_FILE_COULD_NOT_BE_OPENED",
+  "XML_ERROR_FILE_READ_ERROR",
+  "XML_ERROR_PARSING_ELEMENT",
+  "XML_ERROR_PARSING_ATTRIBUTE",
+  "XML_ERROR_PARSING_TEXT",
+  "XML_ERROR_PARSING_CDATA",
+  "XML_ERROR_PARSING_COMMENT",
+  "XML_ERROR_PARSING_DECLARATION",
+  "XML_ERROR_PARSING_UNKNOWN",
+  "XML_ERROR_EMPTY_DOCUMENT",
+  "XML_ERROR_MISMATCHED_ELEMENT",
+  "XML_ERROR_PARSING",
+  "XML_CAN_NOT_CONVERT_TEXT",
+  "XML_NO_TEXT_NODE",
+  "XML_ELEMENT_DEPTH_EXCEEDED"
 };
 
 
 XMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :
-    XMLNode( 0 ),
-    _writeBOM( false ),
-    _processEntities( processEntities ),
-    _errorID(XML_SUCCESS),
-    _whitespaceMode( whitespaceMode ),
-    _errorStr(),
-    _errorLineNum( 0 ),
-    _charBuffer( 0 ),
-    _parseCurLineNum( 0 ),
-	_parsingDepth(0),
-    _unlinked(),
-    _elementPool(),
-    _attributePool(),
-    _textPool(),
-    _commentPool()
-{
-    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
-    _document = this;
+  XMLNode( 0 ),
+  _writeBOM( false ),
+  _processEntities( processEntities ),
+  _errorID(XML_SUCCESS),
+  _whitespaceMode( whitespaceMode ),
+  _errorStr(),
+  _errorLineNum( 0 ),
+  _charBuffer( 0 ),
+  _parseCurLineNum( 0 ),
+  _parsingDepth(0),
+  _unlinked(),
+  _elementPool(),
+  _attributePool(),
+  _textPool(),
+  _commentPool()
+{
+  // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
+  _document = this;
 }
 
 
 XMLDocument::~XMLDocument()
 {
-    Clear();
+  Clear();
 }
 
 
 void XMLDocument::MarkInUse(const XMLNode* const node)
 {
-	TIXMLASSERT(node);
-	TIXMLASSERT(node->_parent == 0);
-
-	for (size_t i = 0; i < _unlinked.Size(); ++i) {
-		if (node == _unlinked[i]) {
-			_unlinked.SwapRemove(i);
-			break;
-		}
+  TIXMLASSERT(node);
+  TIXMLASSERT(node->_parent == 0);
+
+  for (size_t i = 0; i < _unlinked.Size(); ++i) {
+    if (node == _unlinked[i]) {
+      _unlinked.SwapRemove(i);
+      break;
+    }
+  }
+}
+
+void XMLDocument::Clear()
+{
+  DeleteChildren();
+  while( _unlinked.Size()) {
+    DeleteNode(_unlinked[0]);                   // Will remove from _unlinked as part of delete.
+  }
+
+#ifdef TINYXML2_DEBUG
+  const bool hadError = Error();
+#endif
+  ClearError();
+
+  delete [] _charBuffer;
+  _charBuffer = 0;
+  _parsingDepth = 0;
+
+#if 0
+  _textPool.Trace( "text" );
+  _elementPool.Trace( "element" );
+  _commentPool.Trace( "comment" );
+  _attributePool.Trace( "attribute" );
+#endif
+
+#ifdef TINYXML2_DEBUG
+  if ( !hadError ) {
+    TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );
+    TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );
+    TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );
+    TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );
+  }
+#endif
+}
+
+
+void XMLDocument::DeepCopy(XMLDocument* target) const
+{
+  TIXMLASSERT(target);
+  if (target == this) {
+    return;     // technically success - a no-op.
+  }
+
+  target->Clear();
+  for (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {
+    target->InsertEndChild(node->DeepClone(target));
+  }
+}
+
+XMLElement* XMLDocument::NewElement( const char* name )
+{
+  XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );
+  ele->SetName( name );
+  return ele;
+}
+
+
+XMLComment* XMLDocument::NewComment( const char* str )
+{
+  XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );
+  comment->SetValue( str );
+  return comment;
+}
+
+
+XMLText* XMLDocument::NewText( const char* str )
+{
+  XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
+  text->SetValue( str );
+  return text;
+}
+
+
+XMLDeclaration* XMLDocument::NewDeclaration( const char* str )
+{
+  XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
+  dec->SetValue( str ? str : "xml version=\"1.0\" encoding=\"UTF-8\"" );
+  return dec;
+}
+
+
+XMLUnknown* XMLDocument::NewUnknown( const char* str )
+{
+  XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );
+  unk->SetValue( str );
+  return unk;
+}
+
+static FILE* callfopen( const char* filepath, const char* mode )
+{
+  TIXMLASSERT( filepath );
+  TIXMLASSERT( mode );
+#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
+  FILE* fp = 0;
+  const errno_t err = fopen_s( &fp, filepath, mode );
+  if ( err ) {
+    return 0;
+  }
+#else
+  FILE* fp = fopen( filepath, mode );
+#endif
+  return fp;
+}
+
+void XMLDocument::DeleteNode( XMLNode* node )   {
+  TIXMLASSERT( node );
+  TIXMLASSERT(node->_document == this );
+  if (node->_parent) {
+    node->_parent->DeleteChild( node );
+  }
+  else {
+    // Isn't in the tree.
+    // Use the parent delete.
+    // Also, we need to mark it tracked: we 'know'
+    // it was never used.
+    node->_memPool->SetTracked();
+    // Call the static XMLNode version:
+    XMLNode::DeleteNode(node);
+  }
+}
+
+
+XMLError XMLDocument::LoadFile( const char* filename )
+{
+  if ( !filename ) {
+    TIXMLASSERT( false );
+    SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
+    return _errorID;
+  }
+
+  Clear();
+  FILE* fp = callfopen( filename, "rb" );
+  if ( !fp ) {
+    SetError( XML_ERROR_FILE_NOT_FOUND, 0, "filename=%s", filename );
+    return _errorID;
+  }
+  LoadFile( fp );
+  fclose( fp );
+  return _errorID;
+}
+
+XMLError XMLDocument::LoadFile( FILE* fp )
+{
+  Clear();
+
+  TIXML_FSEEK( fp, 0, SEEK_SET );
+  if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {
+    SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
+    return _errorID;
+  }
+
+  TIXML_FSEEK( fp, 0, SEEK_END );
+
+  unsigned long long filelength;
+  {
+    const long long fileLengthSigned = TIXML_FTELL( fp );
+    TIXML_FSEEK( fp, 0, SEEK_SET );
+    if ( fileLengthSigned == -1L ) {
+      SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
+      return _errorID;
+    }
+    TIXMLASSERT( fileLengthSigned >= 0 );
+    filelength = static_cast<unsigned long long>(fileLengthSigned);
+  }
+
+  const size_t maxSizeT = static_cast<size_t>(-1);
+  // We'll do the comparison as an unsigned long long, because that's guaranteed to be at
+  // least 8 bytes, even on a 32-bit platform.
+  if ( filelength >= static_cast<unsigned long long>(maxSizeT) ) {
+    // Cannot handle files which won't fit in buffer together with null terminator
+    SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
+    return _errorID;
+  }
+
+  if ( filelength == 0 ) {
+    SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
+    return _errorID;
+  }
+
+  const size_t size = static_cast<size_t>(filelength);
+  TIXMLASSERT( _charBuffer == 0 );
+  _charBuffer = new char[size+1];
+  const size_t read = fread( _charBuffer, 1, size, fp );
+  if ( read != size ) {
+    SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
+    return _errorID;
+  }
+
+  _charBuffer[size] = 0;
+
+  Parse();
+  return _errorID;
+}
+
+
+XMLError XMLDocument::SaveFile( const char* filename, bool compact )
+{
+  if ( !filename ) {
+    TIXMLASSERT( false );
+    SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
+    return _errorID;
+  }
+
+  FILE* fp = callfopen( filename, "w" );
+  if ( !fp ) {
+    SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=%s", filename );
+    return _errorID;
+  }
+  SaveFile(fp, compact);
+  fclose( fp );
+  return _errorID;
+}
+
+
+XMLError XMLDocument::SaveFile( FILE* fp, bool compact )
+{
+  // Clear any error from the last save, otherwise it will get reported
+  // for *this* call.
+  ClearError();
+  XMLPrinter stream( fp, compact );
+  Print( &stream );
+  return _errorID;
+}
+
+
+XMLError XMLDocument::Parse( const char* xml, size_t nBytes )
+{
+  Clear();
+
+  if ( nBytes == 0 || !xml || !*xml ) {
+    SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
+    return _errorID;
+  }
+  if ( nBytes == static_cast<size_t>(-1) ) {
+    nBytes = strlen( xml );
+  }
+  TIXMLASSERT( _charBuffer == 0 );
+  _charBuffer = new char[ nBytes+1 ];
+  memcpy( _charBuffer, xml, nBytes );
+  _charBuffer[nBytes] = 0;
+
+  Parse();
+  if ( Error() ) {
+    // clean up now essentially dangling memory.
+    // and the parse fail can put objects in the
+    // pools that are dead and inaccessible.
+    DeleteChildren();
+    _elementPool.Clear();
+    _attributePool.Clear();
+    _textPool.Clear();
+    _commentPool.Clear();
+  }
+  return _errorID;
+}
+
+
+void XMLDocument::Print( XMLPrinter* streamer ) const
+{
+  if ( streamer ) {
+    Accept( streamer );
+  }
+  else {
+    XMLPrinter stdoutStreamer( stdout );
+    Accept( &stdoutStreamer );
+  }
+}
+
+
+void XMLDocument::ClearError() {
+  _errorID = XML_SUCCESS;
+  _errorLineNum = 0;
+  _errorStr.Reset();
+}
+
+
+void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )
+{
+  TIXMLASSERT(error >= 0 && error < XML_ERROR_COUNT);
+  _errorID = error;
+  _errorLineNum = lineNum;
+  _errorStr.Reset();
+
+  const size_t BUFFER_SIZE = 1000;
+  char* buffer = new char[BUFFER_SIZE];
+
+  TIXMLASSERT(sizeof(error) <= sizeof(int));
+  TIXML_SNPRINTF(buffer, BUFFER_SIZE, "Error=%s ErrorID=%d (0x%x) Line number=%d",
+                 ErrorIDToName(error), static_cast<int>(error), static_cast<unsigned int>(error), lineNum);
+
+  if (format) {
+    size_t len = strlen(buffer);
+    TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, ": ");
+    len = strlen(buffer);
+
+    va_list va;
+    va_start(va, format);
+    TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
+    va_end(va);
+  }
+  _errorStr.SetStr(buffer);
+  delete[] buffer;
+}
+
+
+/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID)
+{
+  TIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );
+  const char* errorName = _errorNames[errorID];
+  TIXMLASSERT( errorName && errorName[0] );
+  return errorName;
+}
+
+const char* XMLDocument::ErrorStr() const
+{
+  return _errorStr.Empty() ? "" : _errorStr.GetStr();
+}
+
+
+void XMLDocument::PrintError() const
+{
+  printf("%s\n", ErrorStr());
+}
+
+const char* XMLDocument::ErrorName() const
+{
+  return ErrorIDToName(_errorID);
+}
+
+void XMLDocument::Parse()
+{
+  TIXMLASSERT( NoChildren() );   // Clear() must have been called previously
+  TIXMLASSERT( _charBuffer );
+  _parseCurLineNum = 1;
+  _parseLineNum = 1;
+  char* p = _charBuffer;
+  p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
+  p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );
+  if ( !*p ) {
+    SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
+    return;
+  }
+  ParseDeep(p, 0, &_parseCurLineNum );
+}
+
+void XMLDocument::PushDepth()
+{
+  _parsingDepth++;
+  if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
+    SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, "Element nesting is too deep." );
+  }
+}
+
+void XMLDocument::PopDepth()
+{
+  TIXMLASSERT(_parsingDepth > 0);
+  --_parsingDepth;
+}
+
+XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :
+  _elementJustOpened( false ),
+  _stack(),
+  _firstElement( true ),
+  _fp( file ),
+  _depth( depth ),
+  _textDepth( -1 ),
+  _processEntities( true ),
+  _compactMode( compact ),
+  _buffer()
+{
+  for( int i=0; i<ENTITY_RANGE; ++i ) {
+    _entityFlag[i] = false;
+    _restrictedEntityFlag[i] = false;
+  }
+  for( int i=0; i<NUM_ENTITIES; ++i ) {
+    const char entityValue = entities[i].value;
+    const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
+    TIXMLASSERT( flagIndex < ENTITY_RANGE );
+    _entityFlag[flagIndex] = true;
+  }
+  _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
+  _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
+  _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;        // not required, but consistency is nice
+  _buffer.Push( 0 );
+}
+
+
+void XMLPrinter::Print( const char* format, ... )
+{
+  va_list va;
+  va_start( va, format );
+
+  if ( _fp ) {
+    vfprintf( _fp, format, va );
+  }
+  else {
+    const int len = TIXML_VSCPRINTF( format, va );
+    // Close out and re-start the va-args
+    va_end( va );
+    TIXMLASSERT( len >= 0 );
+    va_start( va, format );
+    TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );
+    char* p = _buffer.PushArr( len ) - 1;       // back up over the null terminator.
+    TIXML_VSNPRINTF( p, len+1, format, va );
+  }
+  va_end( va );
+}
+
+
+void XMLPrinter::Write( const char* data, size_t size )
+{
+  if ( _fp ) {
+    fwrite ( data, sizeof(char), size, _fp);
+  }
+  else {
+    char* p = _buffer.PushArr( static_cast<int>(size) ) - 1;       // back up over the null terminator.
+    memcpy( p, data, size );
+    p[size] = 0;
+  }
+}
+
+
+void XMLPrinter::Putc( char ch )
+{
+  if ( _fp ) {
+    fputc ( ch, _fp);
+  }
+  else {
+    char* p = _buffer.PushArr( sizeof(char) ) - 1;       // back up over the null terminator.
+    p[0] = ch;
+    p[1] = 0;
+  }
+}
+
+
+void XMLPrinter::PrintSpace( int depth )
+{
+  for( int i=0; i<depth; ++i ) {
+    Write( "    " );
+  }
+}
+
+
+void XMLPrinter::PrintString( const char* p, bool restricted )
+{
+  // Look for runs of bytes between entities to print.
+  const char* q = p;
+
+  if ( _processEntities ) {
+    const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
+    while ( *q ) {
+      TIXMLASSERT( p <= q );
+      // Remember, char is sometimes signed. (How many times has that bitten me?)
+      if ( *q > 0 && *q < ENTITY_RANGE ) {
+	// Check for entities. If one is found, flush
+	// the stream up until the entity, write the
+	// entity, and keep looking.
+	if ( flag[static_cast<unsigned char>(*q)] ) {
+	  while ( p < q ) {
+	    const size_t delta = q - p;
+	    const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
+	    Write( p, toPrint );
+	    p += toPrint;
+	  }
+	  bool entityPatternPrinted = false;
+	  for( int i=0; i<NUM_ENTITIES; ++i ) {
+	    if ( entities[i].value == *q ) {
+	      Putc( '&' );
+	      Write( entities[i].pattern, entities[i].length );
+	      Putc( ';' );
+	      entityPatternPrinted = true;
+	      break;
+	    }
+	  }
+	  if ( !entityPatternPrinted ) {
+	    // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release
+	    TIXMLASSERT( false );
+	  }
+	  ++p;
 	}
-}
-
-void XMLDocument::Clear()
-{
-    DeleteChildren();
-	while( _unlinked.Size()) {
-		DeleteNode(_unlinked[0]);	// Will remove from _unlinked as part of delete.
-	}
-
-#ifdef TINYXML2_DEBUG
-    const bool hadError = Error();
-#endif
-    ClearError();
-
-    delete [] _charBuffer;
-    _charBuffer = 0;
-	_parsingDepth = 0;
-
-#if 0
-    _textPool.Trace( "text" );
-    _elementPool.Trace( "element" );
-    _commentPool.Trace( "comment" );
-    _attributePool.Trace( "attribute" );
-#endif
-
-#ifdef TINYXML2_DEBUG
-    if ( !hadError ) {
-        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );
-        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );
-        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );
-        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );
-    }
-#endif
-}
-
-
-void XMLDocument::DeepCopy(XMLDocument* target) const
-{
-	TIXMLASSERT(target);
-    if (target == this) {
-        return; // technically success - a no-op.
-    }
-
-	target->Clear();
-	for (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {
-		target->InsertEndChild(node->DeepClone(target));
-	}
-}
-
-XMLElement* XMLDocument::NewElement( const char* name )
-{
-    XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );
-    ele->SetName( name );
-    return ele;
-}
-
-
-XMLComment* XMLDocument::NewComment( const char* str )
-{
-    XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );
-    comment->SetValue( str );
-    return comment;
-}
-
-
-XMLText* XMLDocument::NewText( const char* str )
-{
-    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
-    text->SetValue( str );
-    return text;
-}
-
-
-XMLDeclaration* XMLDocument::NewDeclaration( const char* str )
-{
-    XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
-    dec->SetValue( str ? str : "xml version=\"1.0\" encoding=\"UTF-8\"" );
-    return dec;
-}
-
-
-XMLUnknown* XMLDocument::NewUnknown( const char* str )
-{
-    XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );
-    unk->SetValue( str );
-    return unk;
-}
-
-static FILE* callfopen( const char* filepath, const char* mode )
-{
-    TIXMLASSERT( filepath );
-    TIXMLASSERT( mode );
-#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
-    FILE* fp = 0;
-    const errno_t err = fopen_s( &fp, filepath, mode );
-    if ( err ) {
-        return 0;
-    }
-#else
-    FILE* fp = fopen( filepath, mode );
-#endif
-    return fp;
-}
-
-void XMLDocument::DeleteNode( XMLNode* node )	{
-    TIXMLASSERT( node );
-    TIXMLASSERT(node->_document == this );
-    if (node->_parent) {
-        node->_parent->DeleteChild( node );
-    }
-    else {
-        // Isn't in the tree.
-        // Use the parent delete.
-        // Also, we need to mark it tracked: we 'know'
-        // it was never used.
-        node->_memPool->SetTracked();
-        // Call the static XMLNode version:
-        XMLNode::DeleteNode(node);
-    }
-}
-
-
-XMLError XMLDocument::LoadFile( const char* filename )
-{
-    if ( !filename ) {
-        TIXMLASSERT( false );
-        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
-        return _errorID;
-    }
-
-    Clear();
-    FILE* fp = callfopen( filename, "rb" );
-    if ( !fp ) {
-        SetError( XML_ERROR_FILE_NOT_FOUND, 0, "filename=%s", filename );
-        return _errorID;
-    }
-    LoadFile( fp );
-    fclose( fp );
-    return _errorID;
-}
-
-XMLError XMLDocument::LoadFile( FILE* fp )
-{
-    Clear();
-
-    TIXML_FSEEK( fp, 0, SEEK_SET );
-    if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {
-        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-        return _errorID;
-    }
-
-    TIXML_FSEEK( fp, 0, SEEK_END );
-
-    unsigned long long filelength;
-    {
-        const long long fileLengthSigned = TIXML_FTELL( fp );
-        TIXML_FSEEK( fp, 0, SEEK_SET );
-        if ( fileLengthSigned == -1L ) {
-            SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-            return _errorID;
-        }
-        TIXMLASSERT( fileLengthSigned >= 0 );
-        filelength = static_cast<unsigned long long>(fileLengthSigned);
-    }
-
-    const size_t maxSizeT = static_cast<size_t>(-1);
-    // We'll do the comparison as an unsigned long long, because that's guaranteed to be at
-    // least 8 bytes, even on a 32-bit platform.
-    if ( filelength >= static_cast<unsigned long long>(maxSizeT) ) {
-        // Cannot handle files which won't fit in buffer together with null terminator
-        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-        return _errorID;
-    }
-
-    if ( filelength == 0 ) {
-        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
-        return _errorID;
-    }
-
-    const size_t size = static_cast<size_t>(filelength);
-    TIXMLASSERT( _charBuffer == 0 );
-    _charBuffer = new char[size+1];
-    const size_t read = fread( _charBuffer, 1, size, fp );
-    if ( read != size ) {
-        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
-        return _errorID;
-    }
-
-    _charBuffer[size] = 0;
-
-    Parse();
-    return _errorID;
-}
-
-
-XMLError XMLDocument::SaveFile( const char* filename, bool compact )
-{
-    if ( !filename ) {
-        TIXMLASSERT( false );
-        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
-        return _errorID;
-    }
-
-    FILE* fp = callfopen( filename, "w" );
-    if ( !fp ) {
-        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=%s", filename );
-        return _errorID;
-    }
-    SaveFile(fp, compact);
-    fclose( fp );
-    return _errorID;
-}
-
-
-XMLError XMLDocument::SaveFile( FILE* fp, bool compact )
-{
-    // Clear any error from the last save, otherwise it will get reported
-    // for *this* call.
-    ClearError();
-    XMLPrinter stream( fp, compact );
-    Print( &stream );
-    return _errorID;
-}
-
-
-XMLError XMLDocument::Parse( const char* xml, size_t nBytes )
-{
-    Clear();
-
-    if ( nBytes == 0 || !xml || !*xml ) {
-        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
-        return _errorID;
-    }
-    if ( nBytes == static_cast<size_t>(-1) ) {
-        nBytes = strlen( xml );
-    }
-    TIXMLASSERT( _charBuffer == 0 );
-    _charBuffer = new char[ nBytes+1 ];
-    memcpy( _charBuffer, xml, nBytes );
-    _charBuffer[nBytes] = 0;
-
-    Parse();
-    if ( Error() ) {
-        // clean up now essentially dangling memory.
-        // and the parse fail can put objects in the
-        // pools that are dead and inaccessible.
-        DeleteChildren();
-        _elementPool.Clear();
-        _attributePool.Clear();
-        _textPool.Clear();
-        _commentPool.Clear();
-    }
-    return _errorID;
-}
-
-
-void XMLDocument::Print( XMLPrinter* streamer ) const
-{
-    if ( streamer ) {
-        Accept( streamer );
-    }
-    else {
-        XMLPrinter stdoutStreamer( stdout );
-        Accept( &stdoutStreamer );
-    }
-}
-
-
-void XMLDocument::ClearError() {
-    _errorID = XML_SUCCESS;
-    _errorLineNum = 0;
-    _errorStr.Reset();
-}
-
-
-void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )
-{
-    TIXMLASSERT(error >= 0 && error < XML_ERROR_COUNT);
-    _errorID = error;
-    _errorLineNum = lineNum;
-	_errorStr.Reset();
-
-    const size_t BUFFER_SIZE = 1000;
-    char* buffer = new char[BUFFER_SIZE];
-
-    TIXMLASSERT(sizeof(error) <= sizeof(int));
-    TIXML_SNPRINTF(buffer, BUFFER_SIZE, "Error=%s ErrorID=%d (0x%x) Line number=%d",
-        ErrorIDToName(error), static_cast<int>(error), static_cast<unsigned int>(error), lineNum);
-
-	if (format) {
-		size_t len = strlen(buffer);
-		TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, ": ");
-		len = strlen(buffer);
-
-		va_list va;
-		va_start(va, format);
-		TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
-		va_end(va);
-	}
-	_errorStr.SetStr(buffer);
-	delete[] buffer;
-}
-
-
-/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID)
-{
-	TIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );
-    const char* errorName = _errorNames[errorID];
-    TIXMLASSERT( errorName && errorName[0] );
-    return errorName;
-}
-
-const char* XMLDocument::ErrorStr() const
-{
-	return _errorStr.Empty() ? "" : _errorStr.GetStr();
-}
-
-
-void XMLDocument::PrintError() const
-{
-    printf("%s\n", ErrorStr());
-}
-
-const char* XMLDocument::ErrorName() const
-{
-    return ErrorIDToName(_errorID);
-}
-
-void XMLDocument::Parse()
-{
-    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously
-    TIXMLASSERT( _charBuffer );
-    _parseCurLineNum = 1;
-    _parseLineNum = 1;
-    char* p = _charBuffer;
-    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
-    p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );
-    if ( !*p ) {
-        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
-        return;
-    }
-    ParseDeep(p, 0, &_parseCurLineNum );
-}
-
-void XMLDocument::PushDepth()
-{
-	_parsingDepth++;
-	if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
-		SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, "Element nesting is too deep." );
-	}
-}
-
-void XMLDocument::PopDepth()
-{
-	TIXMLASSERT(_parsingDepth > 0);
-	--_parsingDepth;
-}
-
-XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :
-    _elementJustOpened( false ),
-    _stack(),
-    _firstElement( true ),
-    _fp( file ),
-    _depth( depth ),
-    _textDepth( -1 ),
-    _processEntities( true ),
-    _compactMode( compact ),
-    _buffer()
-{
-    for( int i=0; i<ENTITY_RANGE; ++i ) {
-        _entityFlag[i] = false;
-        _restrictedEntityFlag[i] = false;
-    }
-    for( int i=0; i<NUM_ENTITIES; ++i ) {
-        const char entityValue = entities[i].value;
-        const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
-        TIXMLASSERT( flagIndex < ENTITY_RANGE );
-        _entityFlag[flagIndex] = true;
-    }
-    _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
-    _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
-    _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;	// not required, but consistency is nice
-    _buffer.Push( 0 );
-}
-
-
-void XMLPrinter::Print( const char* format, ... )
-{
-    va_list     va;
-    va_start( va, format );
-
-    if ( _fp ) {
-        vfprintf( _fp, format, va );
-    }
-    else {
-        const int len = TIXML_VSCPRINTF( format, va );
-        // Close out and re-start the va-args
-        va_end( va );
-        TIXMLASSERT( len >= 0 );
-        va_start( va, format );
-        TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );
-        char* p = _buffer.PushArr( len ) - 1;	// back up over the null terminator.
-		TIXML_VSNPRINTF( p, len+1, format, va );
-    }
-    va_end( va );
-}
-
-
-void XMLPrinter::Write( const char* data, size_t size )
-{
-    if ( _fp ) {
-        fwrite ( data , sizeof(char), size, _fp);
-    }
-    else {
-        char* p = _buffer.PushArr( static_cast<int>(size) ) - 1;   // back up over the null terminator.
-        memcpy( p, data, size );
-        p[size] = 0;
-    }
-}
-
-
-void XMLPrinter::Putc( char ch )
-{
-    if ( _fp ) {
-        fputc ( ch, _fp);
-    }
-    else {
-        char* p = _buffer.PushArr( sizeof(char) ) - 1;   // back up over the null terminator.
-        p[0] = ch;
-        p[1] = 0;
-    }
-}
-
-
-void XMLPrinter::PrintSpace( int depth )
-{
-    for( int i=0; i<depth; ++i ) {
-        Write( "    " );
-    }
-}
-
-
-void XMLPrinter::PrintString( const char* p, bool restricted )
-{
-    // Look for runs of bytes between entities to print.
-    const char* q = p;
-
-    if ( _processEntities ) {
-        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
-        while ( *q ) {
-            TIXMLASSERT( p <= q );
-            // Remember, char is sometimes signed. (How many times has that bitten me?)
-            if ( *q > 0 && *q < ENTITY_RANGE ) {
-                // Check for entities. If one is found, flush
-                // the stream up until the entity, write the
-                // entity, and keep looking.
-                if ( flag[static_cast<unsigned char>(*q)] ) {
-                    while ( p < q ) {
-                        const size_t delta = q - p;
-                        const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
-                        Write( p, toPrint );
-                        p += toPrint;
-                    }
-                    bool entityPatternPrinted = false;
-                    for( int i=0; i<NUM_ENTITIES; ++i ) {
-                        if ( entities[i].value == *q ) {
-                            Putc( '&' );
-                            Write( entities[i].pattern, entities[i].length );
-                            Putc( ';' );
-                            entityPatternPrinted = true;
-                            break;
-                        }
-                    }
-                    if ( !entityPatternPrinted ) {
-                        // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release
-                        TIXMLASSERT( false );
-                    }
-                    ++p;
-                }
-            }
-            ++q;
-            TIXMLASSERT( p <= q );
-        }
-        // Flush the remaining string. This will be the entire
-        // string if an entity wasn't found.
-        if ( p < q ) {
-            const size_t delta = q - p;
-            const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
-            Write( p, toPrint );
-        }
-    }
-    else {
-        Write( p );
-    }
+      }
+      ++q;
+      TIXMLASSERT( p <= q );
+    }
+    // Flush the remaining string. This will be the entire
+    // string if an entity wasn't found.
+    if ( p < q ) {
+      const size_t delta = q - p;
+      const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
+      Write( p, toPrint );
+    }
+  }
+  else {
+    Write( p );
+  }
 }
 
 
 void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )
 {
-    if ( writeBOM ) {
-        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };
-        Write( reinterpret_cast< const char* >( bom ) );
-    }
-    if ( writeDec ) {
-        PushDeclaration( "xml version=\"1.0\"" );
-    }
+  if ( writeBOM ) {
+    static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };
+    Write( reinterpret_cast< const char* >( bom ) );
+  }
+  if ( writeDec ) {
+    PushDeclaration( "xml version=\"1.0\"" );
+  }
 }
 
 void XMLPrinter::PrepareForNewNode( bool compactMode )
 {
-    SealElementIfJustOpened();
-
-    if ( compactMode ) {
-        return;
-    }
-
-    if ( _firstElement ) {
-        PrintSpace (_depth);
-    } else if ( _textDepth < 0) {
-        Putc( '\n' );
-        PrintSpace( _depth );
-    }
-
-    _firstElement = false;
+  SealElementIfJustOpened();
+
+  if ( compactMode ) {
+    return;
+  }
+
+  if ( _firstElement ) {
+    PrintSpace (_depth);
+  } else if ( _textDepth < 0) {
+    Putc( '\n' );
+    PrintSpace( _depth );
+  }
+
+  _firstElement = false;
 }
 
 void XMLPrinter::OpenElement( const char* name, bool compactMode )
 {
-    PrepareForNewNode( compactMode );
-    _stack.Push( name );
-
-    Write ( "<" );
+  PrepareForNewNode( compactMode );
+  _stack.Push( name );
+
+  Write ( "<" );
+  Write ( name );
+
+  _elementJustOpened = true;
+  ++_depth;
+}
+
+
+void XMLPrinter::PushAttribute( const char* name, const char* value )
+{
+  TIXMLASSERT( _elementJustOpened );
+  Putc ( ' ' );
+  Write( name );
+  Write( "=\"" );
+  PrintString( value, false );
+  Putc ( '\"' );
+}
+
+
+void XMLPrinter::PushAttribute( const char* name, int v )
+{
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  PushAttribute( name, buf );
+}
+
+
+void XMLPrinter::PushAttribute( const char* name, unsigned v )
+{
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  PushAttribute( name, buf );
+}
+
+
+void XMLPrinter::PushAttribute(const char* name, int64_t v)
+{
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+
+void XMLPrinter::PushAttribute(const char* name, uint64_t v)
+{
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(v, buf, BUF_SIZE);
+  PushAttribute(name, buf);
+}
+
+
+void XMLPrinter::PushAttribute( const char* name, bool v )
+{
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  PushAttribute( name, buf );
+}
+
+
+void XMLPrinter::PushAttribute( const char* name, double v )
+{
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( v, buf, BUF_SIZE );
+  PushAttribute( name, buf );
+}
+
+
+void XMLPrinter::CloseElement( bool compactMode )
+{
+  --_depth;
+  const char* name = _stack.Pop();
+
+  if ( _elementJustOpened ) {
+    Write( "/>" );
+  }
+  else {
+    if ( _textDepth < 0 && !compactMode) {
+      Putc( '\n' );
+      PrintSpace( _depth );
+    }
+    Write ( "</" );
     Write ( name );
-
-    _elementJustOpened = true;
-    ++_depth;
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, const char* value )
-{
-    TIXMLASSERT( _elementJustOpened );
-    Putc ( ' ' );
-    Write( name );
-    Write( "=\"" );
-    PrintString( value, false );
-    Putc ( '\"' );
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, int v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, unsigned v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::PushAttribute(const char* name, int64_t v)
-{
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	PushAttribute(name, buf);
-}
-
-
-void XMLPrinter::PushAttribute(const char* name, uint64_t v)
-{
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(v, buf, BUF_SIZE);
-	PushAttribute(name, buf);
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, bool v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::PushAttribute( const char* name, double v )
-{
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( v, buf, BUF_SIZE );
-    PushAttribute( name, buf );
-}
-
-
-void XMLPrinter::CloseElement( bool compactMode )
-{
-    --_depth;
-    const char* name = _stack.Pop();
-
-    if ( _elementJustOpened ) {
-        Write( "/>" );
-    }
-    else {
-        if ( _textDepth < 0 && !compactMode) {
-            Putc( '\n' );
-            PrintSpace( _depth );
-        }
-        Write ( "</" );
-        Write ( name );
-        Write ( ">" );
-    }
-
-    if ( _textDepth == _depth ) {
-        _textDepth = -1;
-    }
-    if ( _depth == 0 && !compactMode) {
-        Putc( '\n' );
-    }
-    _elementJustOpened = false;
+    Write ( ">" );
+  }
+
+  if ( _textDepth == _depth ) {
+    _textDepth = -1;
+  }
+  if ( _depth == 0 && !compactMode) {
+    Putc( '\n' );
+  }
+  _elementJustOpened = false;
 }
 
 
 void XMLPrinter::SealElementIfJustOpened()
 {
-    if ( !_elementJustOpened ) {
-        return;
-    }
-    _elementJustOpened = false;
-    Putc( '>' );
+  if ( !_elementJustOpened ) {
+    return;
+  }
+  _elementJustOpened = false;
+  Putc( '>' );
 }
 
 
 void XMLPrinter::PushText( const char* text, bool cdata )
 {
-    _textDepth = _depth-1;
-
-    SealElementIfJustOpened();
-    if ( cdata ) {
-        Write( "<![CDATA[" );
-        Write( text );
-        Write( "]]>" );
-    }
-    else {
-        PrintString( text, true );
-    }
+  _textDepth = _depth-1;
+
+  SealElementIfJustOpened();
+  if ( cdata ) {
+    Write( "<![CDATA[" );
+    Write( text );
+    Write( "]]>" );
+  }
+  else {
+    PrintString( text, true );
+  }
 }
 
 
 void XMLPrinter::PushText( int64_t value )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( value, buf, BUF_SIZE );
+  PushText( buf, false );
 }
 
 
 void XMLPrinter::PushText( uint64_t value )
 {
-	char buf[BUF_SIZE];
-	XMLUtil::ToStr(value, buf, BUF_SIZE);
-	PushText(buf, false);
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr(value, buf, BUF_SIZE);
+  PushText(buf, false);
 }
 
 
 void XMLPrinter::PushText( int value )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( value, buf, BUF_SIZE );
+  PushText( buf, false );
 }
 
 
 void XMLPrinter::PushText( unsigned value )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( value, buf, BUF_SIZE );
+  PushText( buf, false );
 }
 
 
 void XMLPrinter::PushText( bool value )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( value, buf, BUF_SIZE );
+  PushText( buf, false );
 }
 
 
 void XMLPrinter::PushText( float value )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( value, buf, BUF_SIZE );
+  PushText( buf, false );
 }
 
 
 void XMLPrinter::PushText( double value )
 {
-    char buf[BUF_SIZE];
-    XMLUtil::ToStr( value, buf, BUF_SIZE );
-    PushText( buf, false );
+  char buf[BUF_SIZE];
+  XMLUtil::ToStr( value, buf, BUF_SIZE );
+  PushText( buf, false );
 }
 
 
 void XMLPrinter::PushComment( const char* comment )
 {
-    PrepareForNewNode( _compactMode );
-
-    Write( "<!--" );
-    Write( comment );
-    Write( "-->" );
+  PrepareForNewNode( _compactMode );
+
+  Write( "<!--" );
+  Write( comment );
+  Write( "-->" );
 }
 
 
 void XMLPrinter::PushDeclaration( const char* value )
 {
-    PrepareForNewNode( _compactMode );
-
-    Write( "<?" );
-    Write( value );
-    Write( "?>" );
+  PrepareForNewNode( _compactMode );
+
+  Write( "<?" );
+  Write( value );
+  Write( "?>" );
 }
 
 
 void XMLPrinter::PushUnknown( const char* value )
 {
-    PrepareForNewNode( _compactMode );
-
-    Write( "<!" );
-    Write( value );
-    Putc( '>' );
+  PrepareForNewNode( _compactMode );
+
+  Write( "<!" );
+  Write( value );
+  Putc( '>' );
 }
 
 
 bool XMLPrinter::VisitEnter( const XMLDocument& doc )
 {
-    _processEntities = doc.ProcessEntities();
-    if ( doc.HasBOM() ) {
-        PushHeader( true, false );
-    }
-    return true;
+  _processEntities = doc.ProcessEntities();
+  if ( doc.HasBOM() ) {
+    PushHeader( true, false );
+  }
+  return true;
 }
 
 
 bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )
 {
-    const XMLElement* parentElem = 0;
-    if ( element.Parent() ) {
-        parentElem = element.Parent()->ToElement();
-    }
-    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;
-    OpenElement( element.Name(), compactMode );
-    while ( attribute ) {
-        PushAttribute( attribute->Name(), attribute->Value() );
-        attribute = attribute->Next();
-    }
-    return true;
+  const XMLElement* parentElem = 0;
+  if ( element.Parent() ) {
+    parentElem = element.Parent()->ToElement();
+  }
+  const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;
+  OpenElement( element.Name(), compactMode );
+  while ( attribute ) {
+    PushAttribute( attribute->Name(), attribute->Value() );
+    attribute = attribute->Next();
+  }
+  return true;
 }
 
 
 bool XMLPrinter::VisitExit( const XMLElement& element )
 {
-    CloseElement( CompactMode(element) );
-    return true;
+  CloseElement( CompactMode(element) );
+  return true;
 }
 
 
 bool XMLPrinter::Visit( const XMLText& text )
 {
-    PushText( text.Value(), text.CData() );
-    return true;
+  PushText( text.Value(), text.CData() );
+  return true;
 }
 
 
 bool XMLPrinter::Visit( const XMLComment& comment )
 {
-    PushComment( comment.Value() );
-    return true;
+  PushComment( comment.Value() );
+  return true;
 }
 
 bool XMLPrinter::Visit( const XMLDeclaration& declaration )
 {
-    PushDeclaration( declaration.Value() );
-    return true;
+  PushDeclaration( declaration.Value() );
+  return true;
 }
 
 
 bool XMLPrinter::Visit( const XMLUnknown& unknown )
 {
-    PushUnknown( unknown.Value() );
-    return true;
+  PushUnknown( unknown.Value() );
+  return true;
 }
 
 }   // namespace tinyxml2
tests/mechanical_layer/include/InputStatic.h
====================
--- original

+++ formatted

@@ -6,22 +6,22 @@

 /// Read input files
 int readParameters(const std::string& file);
 int readMaterials(
-    const std::string& file,
-    std::map<std::string,
-    int32_t>& materialMapping);
+  const std::string& file,
+  std::map<std::string,
+           int32_t>& materialMapping);
 int readGeometry(
-    const std::string& file,
-    std::map<std::string, int32_t>& materialMapping);
+  const std::string& file,
+  std::map<std::string, int32_t>& materialMapping);
 int readAgents(
-    const std::string& file,
-    std::vector<unsigned>& nShapesPerAgent,
-    std::vector<unsigned>& shapeIDagent,
-    std::vector<int>& edges,
-    std::vector<double>& radii,
-    std::vector<double>& masses,
-    std::vector<double>& mois,
-    std::vector<double2>& delta_gtos,
-    std::map<std::string, int32_t>& materialMapping);
+  const std::string& file,
+  std::vector<unsigned>& nShapesPerAgent,
+  std::vector<unsigned>& shapeIDagent,
+  std::vector<int>& edges,
+  std::vector<double>& radii,
+  std::vector<double>& masses,
+  std::vector<double>& mois,
+  std::vector<double2>& delta_gtos,
+  std::map<std::string, int32_t>& materialMapping);
 
 /// Computes k_n and k_t for the given materials
 double computeStiffnessNormal(uint32_t i, uint32_t j);
tests/mechanical_layer/src/Crowd.cpp
====================
--- original

+++ formatted

@@ -28,183 +28,183 @@

  *         EXIT_FAILURE otherwise
  */
 int initialiseSetting(const string &dynamicsFile,
-                       vector<unsigned> &nb_shapes_allagents, vector<unsigned> &shapeIDagent, vector<int> &edges,
-                       vector<double> &radius_allshapes, vector<double> &masses, vector<double> &mois,
-                       vector<double2> &delta_gtos) {
-    /*  Allocate agents */
-    agents = new Agent*[nAgents];
-
-    /*  Create ids of shapes for agents */
-    vector<unsigned> Id_shapes(shapeIDagent.size());
-    for (size_t i = 0; i < shapeIDagent.size(); i++)
+                      vector<unsigned> &nb_shapes_allagents, vector<unsigned> &shapeIDagent, vector<int> &edges,
+                      vector<double> &radius_allshapes, vector<double> &masses, vector<double> &mois,
+                      vector<double2> &delta_gtos) {
+  /*  Allocate agents */
+  agents = new Agent*[nAgents];
+
+  /*  Create ids of shapes for agents */
+  vector<unsigned> Id_shapes(shapeIDagent.size());
+  for (size_t i = 0; i < shapeIDagent.size(); i++)
+  {
+    Id_shapes[i] = i;
+  }
+
+  /*  Create agents: read the dynamics file first  */
+  tinyxml2::XMLDocument document;
+  document.LoadFile(dynamicsFile.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << dynamicsFile << endl;
+    return EXIT_FAILURE;
+  }
+  //  Read the Agents block
+  tinyxml2::XMLElement* agentsElement         = document.FirstChildElement("Agents");
+  if (!agentsElement) {
+    cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+  const tinyxml2::XMLElement* agentElement    = agentsElement->FirstChildElement("Agent");
+  if (!agentElement) {
+    cerr << "Error: no Agent tag present in " << dynamicsFile << endl;
+    return EXIT_FAILURE;
+  }
+  uint32_t agentCounter = 0;
+  while (agentElement != nullptr) {
+    const char* agentId = nullptr;
+    uint32_t a;
+    agentElement->QueryStringAttribute("Id", &agentId);
+    if (!agentId) {
+      cerr << "Error: agent tag with no id in dynamics file" << endl;
+      return EXIT_FAILURE;
+    }
+    if (!agentMap.contains(agentId)) {
+      cerr << "Error: unknown agent " << agentId << " in dynamics file" << endl;
+      return EXIT_FAILURE;
+    }
+    else a = agentMap[agentId];
+
+    const unsigned ID_agent(a);
+    vector<double2> delta_gtos_curr(&delta_gtos[edges[a]],
+                                    &delta_gtos[edges[a + 1]]);
+    double2 shoulders_direction(delta_gtos[edges[a + 1] - 1] - delta_gtos[edges[a]]);           // from left to right
+    double2 orientation_vec({-shoulders_direction.second, shoulders_direction.first});       // normal to the shoulders direction
+    double theta_body_init(0.);
+    if (not (orientation_vec.first == 0. and orientation_vec.second == 0.))
+      theta_body_init = atan2(orientation_vec.second, orientation_vec.first);
+
+    vector<double> radius_shapes(&radius_allshapes[edges[a]], &radius_allshapes[edges[a + 1]]);
+    const vector<unsigned> Ids_shapes_agent(&Id_shapes[edges[a]], &Id_shapes[edges[a + 1]]);
+    const double mass_curr(masses[a]), moi_curr(mois[a]);
+
+    /// Kinematics and Dynamics
+    const tinyxml2::XMLElement* kinematicsElement    = agentElement->FirstChildElement("Kinematics");
+    if (!kinematicsElement) {
+      cerr << "Error: no Kinematics tag present for agent " << agentId << endl;
+      return EXIT_FAILURE;
+    }
+    const char* buffer = nullptr;
+    if (kinematicsElement->QueryStringAttribute("Position", &buffer) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: Could not parse agent position from XML file " << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    auto [rcPosition, position] = parse2DComponents(buffer);
+    if (rcPosition != EXIT_SUCCESS) {
+      cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+
+    if (kinematicsElement->QueryStringAttribute("Velocity", &buffer) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: Could not parse agent velocity from XML file " << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    auto [rcVelocity, velocity] = parse2DComponents(buffer);
+    if (rcVelocity != EXIT_SUCCESS) {
+      cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    double theta, omega;
+    if (kinematicsElement->QueryDoubleAttribute("theta", &theta) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get orientation of agent " << agentId << endl;
+    };
+    if (kinematicsElement->QueryDoubleAttribute("omega", &omega) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get angular velocity of agent " << agentId << endl;
+    };
+
+    const tinyxml2::XMLElement* dynamicsElement    = agentElement->FirstChildElement("Dynamics");
+    if (!dynamicsElement) {
+      cerr << "Error: no Dynamics tag present for agent " << agentId << endl;
+      return EXIT_FAILURE;
+    }
+    if (dynamicsElement->QueryStringAttribute("Fp", &buffer) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get driving force of agent " << agentId << endl;
+      return EXIT_FAILURE;
+    }
+    auto [rcFp, Fp] = parse2DComponents(buffer);
+    if (rcFp != EXIT_SUCCESS) {
+      cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
+      return EXIT_FAILURE;
+    }
+    double Mp;
+    if (dynamicsElement->QueryDoubleAttribute("Mp", &Mp) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get driving torque of agent " << agentId << endl;
+      return EXIT_FAILURE;
+    };
+    /// Actual creation of the Agent object
+    agents[ID_agent] = new Agent(ID_agent, Ids_shapes_agent, position.first, position.second,
+                                 velocity.first, velocity.second, omega, Fp, Mp,
+                                 nb_shapes_allagents[a], delta_gtos_curr, radius_shapes,
+                                 theta, theta_body_init, mass_curr, moi_curr);
+
+    agentElement = agentElement->NextSiblingElement("Agent");
+    agentCounter++;
+  }
+  /// Check if the number of agents in the Dynamics file is the same as in the Agents file
+  if (agentCounter != nAgents) {
+    cerr << "Not all agents are present in the dynamics file" << dynamicsFile << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Update neighbours before calling the mechanical layer   */
+  determine_agents_neighbours();
+
+  return EXIT_SUCCESS;
+}
+
+/**
+ * @brief Updates the list of neighbors for each agent in the crowd.
+ *
+ * This function creates the lists based on the proximity of each agent to other agents and to walls.
+ *
+ */
+void determine_agents_neighbours()
+{
+  /// We will consider all agents within a certain distance from one another, ie the maximum distance
+  /// that can be traveled by an agent within dt seconds at max speed vMaxAgent. We multiply it by 2 in the "extreme"
+  /// case of two pedestrians walking (running) fast towards each other. All this ensures that all agents who can
+  /// potentially collide within dt are taken into account.
+  const double criticalDistanceWall   = dt * vMaxAgent;
+  const double criticalDistance       = 2 * criticalDistanceWall;
+
+  for (uint32_t a1 = 0; a1 < nAgents; a1++)
+  {
+    Agent* agent1 = agents[a1];
+    //  First, check walls
+    for (uint32_t iobs = 0; iobs < listObstacles.size(); iobs++) {
+      for (uint32_t iwall = 0; iwall < listObstacles[iobs].size() - 1; iwall++) {
+	auto [distance, closest_point] =
+	  get_distance_to_wall_and_closest_point(
+	    listObstacles[iobs][iwall],
+	    listObstacles[iobs][iwall + 1],
+	    agent1->get_r());
+	if (distance < criticalDistanceWall) {
+	  agent1->_neighbours_walls.emplace_back(iobs, iwall);
+	}
+      }
+    }
+    //  Then, other agents
+    for (uint32_t a2 = a1 + 1; a2 < nAgents; a2++)
     {
-        Id_shapes[i] = i;
-    }
-
-    /*  Create agents: read the dynamics file first  */
-    tinyxml2::XMLDocument document;
-    document.LoadFile(dynamicsFile.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << dynamicsFile << endl;
-        return EXIT_FAILURE;
-    }
-    //  Read the Agents block
-    tinyxml2::XMLElement* agentsElement         = document.FirstChildElement("Agents");
-    if (!agentsElement) {
-        cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-    const tinyxml2::XMLElement* agentElement    = agentsElement->FirstChildElement("Agent");
-    if (!agentElement) {
-        cerr << "Error: no Agent tag present in " << dynamicsFile << endl;
-        return EXIT_FAILURE;
-    }
-    uint32_t agentCounter = 0;
-    while (agentElement != nullptr) {
-        const char* agentId = nullptr;
-        uint32_t a;
-        agentElement->QueryStringAttribute("Id", &agentId);
-        if (!agentId) {
-            cerr << "Error: agent tag with no id in dynamics file" << endl;
-            return EXIT_FAILURE;
-        }
-        if (!agentMap.contains(agentId)) {
-            cerr << "Error: unknown agent " << agentId << " in dynamics file" << endl;
-            return EXIT_FAILURE;
-        }
-        else a = agentMap[agentId];
-
-        const unsigned ID_agent(a);
-        vector<double2> delta_gtos_curr(&delta_gtos[edges[a]],
-                                        &delta_gtos[edges[a + 1]]);
-        double2 shoulders_direction(delta_gtos[edges[a + 1] - 1] - delta_gtos[edges[a]]);       // from left to right
-        double2 orientation_vec({-shoulders_direction.second, shoulders_direction.first});   // normal to the shoulders direction
-        double theta_body_init(0.);
-        if (not(orientation_vec.first == 0. and orientation_vec.second == 0.))
-            theta_body_init = atan2(orientation_vec.second, orientation_vec.first);
-
-        vector<double> radius_shapes(&radius_allshapes[edges[a]], &radius_allshapes[edges[a + 1]]);
-        const vector<unsigned> Ids_shapes_agent(&Id_shapes[edges[a]], &Id_shapes[edges[a + 1]]);
-        const double mass_curr(masses[a]), moi_curr(mois[a]);
-
-        /// Kinematics and Dynamics
-        const tinyxml2::XMLElement* kinematicsElement    = agentElement->FirstChildElement("Kinematics");
-        if (!kinematicsElement) {
-            cerr << "Error: no Kinematics tag present for agent " << agentId << endl;
-            return EXIT_FAILURE;
-        }
-        const char* buffer = nullptr;
-        if (kinematicsElement->QueryStringAttribute("Position", &buffer) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: Could not parse agent position from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        auto [rcPosition, position] = parse2DComponents(buffer);
-        if (rcPosition != EXIT_SUCCESS) {
-            cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-
-        if (kinematicsElement->QueryStringAttribute("Velocity", &buffer) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: Could not parse agent velocity from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        auto [rcVelocity, velocity] = parse2DComponents(buffer);
-        if (rcVelocity != EXIT_SUCCESS) {
-            cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        double theta, omega;
-        if (kinematicsElement->QueryDoubleAttribute("theta", &theta) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get orientation of agent " << agentId << endl;
-        };
-        if (kinematicsElement->QueryDoubleAttribute("omega", &omega) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get angular velocity of agent " << agentId << endl;
-        };
-
-        const tinyxml2::XMLElement* dynamicsElement    = agentElement->FirstChildElement("Dynamics");
-        if (!dynamicsElement) {
-            cerr << "Error: no Dynamics tag present for agent " << agentId << endl;
-            return EXIT_FAILURE;
-        }
-        if (dynamicsElement->QueryStringAttribute("Fp", &buffer) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get driving force of agent " << agentId << endl;
-            return EXIT_FAILURE;
-        }
-        auto [rcFp, Fp] = parse2DComponents(buffer);
-        if (rcFp != EXIT_SUCCESS) {
-            cerr << "Error: Could not parse corner coordinates from XML file " << dynamicsFile << endl;
-            return EXIT_FAILURE;
-        }
-        double Mp;
-        if (dynamicsElement->QueryDoubleAttribute("Mp", &Mp) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get driving torque of agent " << agentId << endl;
-            return EXIT_FAILURE;
-        };
-        /// Actual creation of the Agent object
-        agents[ID_agent] = new Agent(ID_agent, Ids_shapes_agent, position.first, position.second,
-                                    velocity.first, velocity.second, omega, Fp, Mp,
-                                    nb_shapes_allagents[a], delta_gtos_curr, radius_shapes,
-                                    theta, theta_body_init, mass_curr, moi_curr);
-
-        agentElement = agentElement->NextSiblingElement("Agent");
-        agentCounter++;
-    }
-    /// Check if the number of agents in the Dynamics file is the same as in the Agents file
-    if (agentCounter != nAgents) {
-        cerr << "Not all agents are present in the dynamics file" << dynamicsFile << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Update neighbours before calling the mechanical layer   */
-    determine_agents_neighbours();
-
-    return EXIT_SUCCESS;
-}
-
-/**
- * @brief Updates the list of neighbors for each agent in the crowd.
- *
- * This function creates the lists based on the proximity of each agent to other agents and to walls.
- *
- */
-void determine_agents_neighbours()
-{
-    /// We will consider all agents within a certain distance from one another, ie the maximum distance
-    /// that can be traveled by an agent within dt seconds at max speed vMaxAgent. We multiply it by 2 in the "extreme"
-    /// case of two pedestrians walking (running) fast towards each other. All this ensures that all agents who can
-    /// potentially collide within dt are taken into account.
-    const double criticalDistanceWall   = dt * vMaxAgent;
-    const double criticalDistance       = 2 * criticalDistanceWall;
-
-    for (uint32_t a1 = 0; a1 < nAgents; a1++)
-    {
-        Agent* agent1 = agents[a1];
-        //  First, check walls
-        for (uint32_t iobs = 0; iobs < listObstacles.size(); iobs++) {
-            for (uint32_t iwall = 0; iwall < listObstacles[iobs].size() - 1; iwall++) {
-                auto [distance, closest_point] =
-                    get_distance_to_wall_and_closest_point(
-                        listObstacles[iobs][iwall],
-                        listObstacles[iobs][iwall + 1],
-                        agent1->get_r());
-                if (distance < criticalDistanceWall) {
-                    agent1->_neighbours_walls.emplace_back(iobs, iwall);
-                }
-            }
-        }
-        //  Then, other agents
-        for (uint32_t a2 = a1 + 1; a2 < nAgents; a2++)
-        {
-            Agent* agent2 = agents[a2];
-
-            const double2 r1 = agent1->get_r();
-            const double2 r2 = agent2->get_r();
-            if (const double r = get_distance(r1, r2); r < criticalDistance) {
-                agent1->_neighbours.push_back(agent2->_id);
-                agent2->_neighbours.push_back(agent1->_id);
-            }
-        }
-    }
+      Agent* agent2 = agents[a2];
+
+      const double2 r1 = agent1->get_r();
+      const double2 r2 = agent2->get_r();
+      if (const double r = get_distance(r1, r2); r < criticalDistance) {
+	agent1->_neighbours.push_back(agent2->_id);
+	agent2->_neighbours.push_back(agent1->_id);
+      }
+    }
+  }
 }
 /**
  * @brief Executes the mechanical layer.
@@ -219,33 +219,33 @@

  */
 void handleMechanicalLayer(const string &dynamicsFile)
 {
-    /*  Handle mechanically active agents: mechanical layer */
-    if (get_future_collision())
-    {
-        const MechanicalLayer* crowdMech = new MechanicalLayer(mech_active_agents);
-        delete crowdMech;
-    }
-
-    /*  Handle non mechanically active agents: simple positional update */
-    for (uint32_t a = 0; a < nAgents; a++) {
-        Agent* agent = agents[a];
-        if (is_mechanically_active(agent))
-            continue;
-        /// The dynamics follow a simple relaxation equation, ie
-        /// dv/dt = (v_des - v) / tau_mech  ==> v(t)= v_des (1 - e^-t/tau_mech) + v(t=0) e^-t/tau_mech
-        const double inverseTauMechTranslation   = agentProperties[agent->_id].first;
-        const double inverseTauMechRotation      = agentProperties[agent->_id].second;
-        agent->_vx = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vx_des
-                    + exp(-dt * inverseTauMechTranslation) * agent->_vx;
-        agent->_vy = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vy_des
-                    + exp(-dt * inverseTauMechTranslation) * agent->_vy;
-        agent->_w  = (1.0 - exp(-dt * inverseTauMechRotation)) * agent->_w_des
-                    + exp(-dt * inverseTauMechRotation) * agent->_w;
-        agent->move();
-    }
-
-    /*  Save output of mechanical layer to file */
-    generateDynamicsOutputFile(dynamicsFile);
+  /*  Handle mechanically active agents: mechanical layer */
+  if (get_future_collision())
+  {
+    const MechanicalLayer* crowdMech = new MechanicalLayer(mech_active_agents);
+    delete crowdMech;
+  }
+
+  /*  Handle non mechanically active agents: simple positional update */
+  for (uint32_t a = 0; a < nAgents; a++) {
+    Agent* agent = agents[a];
+    if (is_mechanically_active(agent))
+      continue;
+    /// The dynamics follow a simple relaxation equation, ie
+    /// dv/dt = (v_des - v) / tau_mech  ==> v(t)= v_des (1 - e^-t/tau_mech) + v(t=0) e^-t/tau_mech
+    const double inverseTauMechTranslation   = agentProperties[agent->_id].first;
+    const double inverseTauMechRotation      = agentProperties[agent->_id].second;
+    agent->_vx = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vx_des
+                 + exp(-dt * inverseTauMechTranslation) * agent->_vx;
+    agent->_vy = (1.0 - exp(-dt * inverseTauMechTranslation)) * agent->_vy_des
+                 + exp(-dt * inverseTauMechTranslation) * agent->_vy;
+    agent->_w  = (1.0 - exp(-dt * inverseTauMechRotation)) * agent->_w_des
+                 + exp(-dt * inverseTauMechRotation) * agent->_w;
+    agent->move();
+  }
+
+  /*  Save output of mechanical layer to file */
+  generateDynamicsOutputFile(dynamicsFile);
 }
 
 /**
@@ -257,7 +257,7 @@

  */
 bool is_mechanically_active(const Agent* agent)
 {
-    return (ranges::find(mech_active_agents, agent) != mech_active_agents.end());
+  return (ranges::find(mech_active_agents, agent) != mech_active_agents.end());
 }
 
 /**
@@ -267,75 +267,75 @@

  */
 bool get_future_collision()
 {
-    /* Test new positions   */
-    for (uint32_t a = 0; a < nAgents; a++)
+  /* Test new positions   */
+  for (uint32_t a = 0; a < nAgents; a++)
+  {
+    Agent* agent = agents[a];
+
+    agent->_x += agent->_vx_des * dt;
+    agent->_y += agent->_vy_des * dt;
+    agent->_theta += agent->_w_des * dt;
+  }
+
+  /// Check if overlaps
+  mech_active_agents.clear();
+  for (uint32_t a = 0; a < nAgents; a++)
+  {
+    Agent* agent1 = agents[a];
+    /// Loop over current agent's wall neighbours
+    for (const auto& [iobs, iwall] : agent1->_neighbours_walls) {
+      double2 middlePointWall = 0.5 * (listObstacles[iobs][iwall] + listObstacles[iobs][iwall + 1]);
+      if ((!(agent1->get_r() - middlePointWall)) < agent1->_radius + 1e-1) {
+	if (not is_mechanically_active(agent1))
+	  mech_active_agents.push_back(agent1);
+      }
+    }
+    /// Loop over current agent's neighbours
+    for (const unsigned agent2_id : agent1->_neighbours)
     {
-        Agent* agent = agents[a];
-
-        agent->_x += agent->_vx_des * dt;
-        agent->_y += agent->_vy_des * dt;
-        agent->_theta += agent->_w_des * dt;
-    }
-
-    /// Check if overlaps
-    mech_active_agents.clear();
-    for (uint32_t a = 0; a < nAgents; a++)
+      if (Agent* agent2 = agents[agent2_id];
+          (!(agent1->get_r() - agent2->get_r())) < fabs(agent1->_radius + agent2->_radius) + 1e-1)
+      {
+	if (not is_mechanically_active(agent1))
+	  mech_active_agents.push_back(agent1);
+	if (not is_mechanically_active(agent2))
+	  mech_active_agents.push_back(agent2);
+      }
+    }
+  }
+
+  /// Revert to former positions
+  for (uint32_t a = 0; a < nAgents; a++)
+  {
+    Agent* agent = agents[a];
+
+    agent->_x -= agent->_vx_des * dt;
+    agent->_y -= agent->_vy_des * dt;
+    agent->_theta -= agent->_w_des * dt;
+  }
+
+  /// Add agents with significant velocity changes
+  for (uint32_t a = 0; a < nAgents; a++)
+  {
+    if (Agent* agent = agents[a];
+        pow(agent->_vx - agent->_vx_des, 2)
+        + pow(agent->_vy - agent->_vy_des, 2)
+        + pow(agent->_w - agent->_w_des, 2) > 1e-4
+        and not is_mechanically_active(agent)
+        )
+      mech_active_agents.push_back(agent);
+  }
+
+  /// Add neighbours of active agents
+  for (const Agent* agent : mech_active_agents)
+  {
+    for (const unsigned neighbour : agent->_neighbours)
     {
-        Agent* agent1 = agents[a];
-        /// Loop over current agent's wall neighbours
-        for (const auto& [iobs, iwall] : agent1->_neighbours_walls) {
-            double2 middlePointWall = 0.5 * (listObstacles[iobs][iwall] + listObstacles[iobs][iwall + 1]);
-            if ((!(agent1->get_r() - middlePointWall)) < agent1->_radius + 1e-1) {
-                if (not is_mechanically_active(agent1))
-                    mech_active_agents.push_back(agent1);
-            }
-        }
-        /// Loop over current agent's neighbours
-        for (const unsigned agent2_id : agent1->_neighbours)
-        {
-            if (Agent* agent2 = agents[agent2_id];
-                    (!(agent1->get_r() - agent2->get_r())) < fabs(agent1->_radius + agent2->_radius) + 1e-1)
-            {
-                if (not is_mechanically_active(agent1))
-                    mech_active_agents.push_back(agent1);
-                if (not is_mechanically_active(agent2))
-                    mech_active_agents.push_back(agent2);
-            }
-        }
-    }
-
-    /// Revert to former positions
-    for (uint32_t a = 0; a < nAgents; a++)
-    {
-        Agent* agent = agents[a];
-
-        agent->_x -= agent->_vx_des * dt;
-        agent->_y -= agent->_vy_des * dt;
-        agent->_theta -= agent->_w_des * dt;
-    }
-
-    /// Add agents with significant velocity changes
-    for (uint32_t a = 0; a < nAgents; a++)
-    {
-        if (Agent* agent = agents[a];
-                pow(agent->_vx - agent->_vx_des, 2)
-                + pow(agent->_vy - agent->_vy_des, 2)
-                + pow(agent->_w - agent->_w_des, 2) > 1e-4
-                and not is_mechanically_active(agent)
-            )
-            mech_active_agents.push_back(agent);
-    }
-
-    /// Add neighbours of active agents
-    for (const Agent* agent : mech_active_agents)
-    {
-        for (const unsigned neighbour : agent->_neighbours)
-        {
-            if (not is_mechanically_active(agents[neighbour]))
-                mech_active_agents.push_back(agents[neighbour]);
-        }
-    }
-    return (!mech_active_agents.empty());
+      if (not is_mechanically_active(agents[neighbour]))
+	mech_active_agents.push_back(agents[neighbour]);
+    }
+  }
+  return (!mech_active_agents.empty());
 }
 
 /**
@@ -345,34 +345,34 @@

  */
 void generateDynamicsOutputFile(const std::string &dynamicsFile)
 {
-    //  We'll  build the output from the input (the structure and fields are exactly the same)
-    tinyxml2::XMLDocument inputDoc;
-    inputDoc.LoadFile((dynamicsFile).data());
-    ofstream outputDoc;
-    outputDoc.open(dynamicsFile);
-
-    outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
-    //  Read the Agents block
-    tinyxml2::XMLElement* InAgentsElement   = inputDoc.FirstChildElement("Agents");
-    outputDoc << "<Agents>" << endl;
-
-    const tinyxml2::XMLElement* InAgentElement    = InAgentsElement->FirstChildElement("Agent");
-    while (InAgentElement != nullptr) {
-        //  First, get our internal id
-        const char* agentId = nullptr;
-        InAgentElement->QueryStringAttribute("Id", &agentId);
-        const uint32_t a = agentMap[agentId];
-        struct Agent* agent = agents[a];
-        outputDoc << "    <Agent Id=\"" << agentId << "\">" << endl;
-        //  Kinematics
-        outputDoc << "        <Kinematics Position=\"" << agent->_x << "," << agent->_y << "\" ";
-        outputDoc << "Velocity=\"" << agent->_vx << "," << agent->_vy << "\" ";
-        outputDoc << "theta=\"" << agent->_theta << "\" omega=\"" << agent->_w << "\"/>" << endl;
-
-        InAgentElement = InAgentElement->NextSiblingElement("Agent");
-        outputDoc << "    </Agent>" << endl;
-    }
-    outputDoc << "</Agents>";
-
-    outputDoc.close();
-}
+  //  We'll  build the output from the input (the structure and fields are exactly the same)
+  tinyxml2::XMLDocument inputDoc;
+  inputDoc.LoadFile((dynamicsFile).data());
+  ofstream outputDoc;
+  outputDoc.open(dynamicsFile);
+
+  outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
+  //  Read the Agents block
+  tinyxml2::XMLElement* InAgentsElement   = inputDoc.FirstChildElement("Agents");
+  outputDoc << "<Agents>" << endl;
+
+  const tinyxml2::XMLElement* InAgentElement    = InAgentsElement->FirstChildElement("Agent");
+  while (InAgentElement != nullptr) {
+    //  First, get our internal id
+    const char* agentId = nullptr;
+    InAgentElement->QueryStringAttribute("Id", &agentId);
+    const uint32_t a = agentMap[agentId];
+    struct Agent* agent = agents[a];
+    outputDoc << "    <Agent Id=\"" << agentId << "\">" << endl;
+    //  Kinematics
+    outputDoc << "        <Kinematics Position=\"" << agent->_x << "," << agent->_y << "\" ";
+    outputDoc << "Velocity=\"" << agent->_vx << "," << agent->_vy << "\" ";
+    outputDoc << "theta=\"" << agent->_theta << "\" omega=\"" << agent->_w << "\"/>" << endl;
+
+    InAgentElement = InAgentElement->NextSiblingElement("Agent");
+    outputDoc << "    </Agent>" << endl;
+  }
+  outputDoc << "</Agents>";
+
+  outputDoc.close();
+}
tests/mechanical_layer/build/CMakeFiles/4.0.1/CompilerIdC/CMakeCCompilerId.c
====================
--- original

+++ formatted

@@ -29,8 +29,8 @@

 # if defined(__GNUC__)
 #  define SIMULATE_ID "GNU"
 # endif
-  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
-     except that a few beta releases use the old format with V=2021.  */
+/* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
+   except that a few beta releases use the old format with V=2021.  */
 # if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
 #  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
 #  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
@@ -42,16 +42,16 @@

 # else
 #  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
 #  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
-   /* The third version component from --version is an update index,
-      but no macro is provided for it.  */
+/* The third version component from --version is an update index,
+   but no macro is provided for it.  */
 #  define COMPILER_VERSION_PATCH DEC(0)
 # endif
 # if defined(__INTEL_COMPILER_BUILD_DATE)
-   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
+/* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
 #  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
 # endif
 # if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 # endif
@@ -89,7 +89,7 @@

 # define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
 #endif
 #if defined(_MSC_VER)
-  /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 #endif
@@ -121,13 +121,13 @@

 
 #elif defined(__BORLANDC__)
 # define COMPILER_ID "Borland"
-  /* __BORLANDC__ = 0xVRR */
+/* __BORLANDC__ = 0xVRR */
 # define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
 # define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
 
 #elif defined(__WATCOMC__) && __WATCOMC__ < 1200
 # define COMPILER_ID "Watcom"
-   /* __WATCOMC__ = VVRR */
+/* __WATCOMC__ = VVRR */
 # define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
 # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
 # if (__WATCOMC__ % 10) > 0
@@ -136,7 +136,7 @@

 
 #elif defined(__WATCOMC__)
 # define COMPILER_ID "OpenWatcom"
-   /* __WATCOMC__ = VVRP + 1100 */
+/* __WATCOMC__ = VVRP + 1100 */
 # define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
 # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
 # if (__WATCOMC__ % 10) > 0
@@ -146,12 +146,12 @@

 #elif defined(__SUNPRO_C)
 # define COMPILER_ID "SunPro"
 # if __SUNPRO_C >= 0x5100
-   /* __SUNPRO_C = 0xVRRP */
+/* __SUNPRO_C = 0xVRRP */
 #  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)
 #  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)
 #  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
 # else
-   /* __SUNPRO_CC = 0xVRP */
+/* __SUNPRO_CC = 0xVRP */
 #  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)
 #  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)
 #  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
@@ -159,21 +159,21 @@

 
 #elif defined(__HP_cc)
 # define COMPILER_ID "HP"
-  /* __HP_cc = VVRRPP */
+/* __HP_cc = VVRRPP */
 # define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)
 # define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)
 # define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)
 
 #elif defined(__DECC)
 # define COMPILER_ID "Compaq"
-  /* __DECC_VER = VVRRTPPPP */
+/* __DECC_VER = VVRRTPPPP */
 # define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)
 # define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)
 # define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)
 
 #elif defined(__IBMC__) && defined(__COMPILER_VER__)
 # define COMPILER_ID "zOS"
-  /* __IBMC__ = VRP */
+/* __IBMC__ = VRP */
 # define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
 # define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
 # define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)
@@ -197,14 +197,14 @@

 
 #elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800
 # define COMPILER_ID "XL"
-  /* __IBMC__ = VRP */
+/* __IBMC__ = VRP */
 # define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
 # define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
 # define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)
 
 #elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800
 # define COMPILER_ID "VisualAge"
-  /* __IBMC__ = VRP */
+/* __IBMC__ = VRP */
 # define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
 # define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
 # define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)
@@ -240,7 +240,7 @@

 
 #elif defined(__TI_COMPILER_VERSION__)
 # define COMPILER_ID "TI"
-  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
+/* __TI_COMPILER_VERSION__ = VVVRRRPPP */
 # define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
 # define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
 # define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)
@@ -302,12 +302,12 @@

 #elif defined(__ARMCC_VERSION) && !defined(__clang__)
 # define COMPILER_ID "ARMCC"
 #if __ARMCC_VERSION >= 1000000
-  /* __ARMCC_VERSION = VRRPPPP */
+/* __ARMCC_VERSION = VRRPPPP */
   # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
   # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
   # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
 #else
-  /* __ARMCC_VERSION = VRPPPP */
+/* __ARMCC_VERSION = VRPPPP */
   # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
   # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
   # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
@@ -323,7 +323,7 @@

 # define COMPILER_VERSION_MINOR DEC(__clang_minor__)
 # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
 # if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 # endif
@@ -352,7 +352,7 @@

 # define COMPILER_VERSION_MINOR DEC(__clang_minor__)
 # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
 # if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 # endif
@@ -385,15 +385,15 @@

 
 #elif defined(_MSC_VER)
 # define COMPILER_ID "MSVC"
-  /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 # define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
 # define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
 # if defined(_MSC_FULL_VER)
 #  if _MSC_VER >= 1400
-    /* _MSC_FULL_VER = VVRRPPPPP */
+/* _MSC_FULL_VER = VVRRPPPPP */
 #   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
 #  else
-    /* _MSC_FULL_VER = VVRRPPPP */
+/* _MSC_FULL_VER = VVRRPPPP */
 #   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
 #  endif
 # endif
@@ -404,7 +404,7 @@

 #elif defined(_ADI_COMPILER)
 # define COMPILER_ID "ADSP"
 #if defined(__VERSIONNUM__)
-  /* __VERSIONNUM__ = 0xVVRRPPTT */
+/* __VERSIONNUM__ = 0xVVRRPPTT */
 #  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
 #  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
 #  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
@@ -420,7 +420,7 @@

 #  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
 # elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
 #  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
-#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
+#  define COMPILER_VERSION_MINOR DEC((__VER__) -(((__VER__) / 100)*100))
 #  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
 #  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
 # endif
@@ -432,7 +432,7 @@

 #  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)
 #  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)
 # else
-  /* SDCC = VRP */
+/* SDCC = VRP */
 #  define COMPILER_VERSION_MAJOR DEC(SDCC/100)
 #  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)
 #  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)
@@ -440,8 +440,8 @@

 
 
 /* These compilers are either not known or too old to define an
-  identification macro.  Try to identify the platform and guess that
-  it is the native compiler.  */
+   identification macro.  Try to identify the platform and guess that
+   it is the native compiler.  */
 #elif defined(__hpux) || defined(__hpua)
 # define COMPILER_ID "HP"
 
@@ -585,7 +585,7 @@

    the architecture of the compiler being used.  This is because
    the compilers do not have flags that can change the architecture,
    but rather depend on which compiler is being used
-*/
+ */
 #if defined(_WIN32) && defined(_MSC_VER)
 # if defined(_M_IA64)
 #  define ARCHITECTURE_ID "IA64"
@@ -748,25 +748,25 @@

 
 /* Convert integer to decimal digit literals.  */
 #define DEC(n)                   \
-  ('0' + (((n) / 10000000)%10)), \
-  ('0' + (((n) / 1000000)%10)),  \
-  ('0' + (((n) / 100000)%10)),   \
-  ('0' + (((n) / 10000)%10)),    \
-  ('0' + (((n) / 1000)%10)),     \
-  ('0' + (((n) / 100)%10)),      \
-  ('0' + (((n) / 10)%10)),       \
-  ('0' +  ((n) % 10))
+	('0' + (((n) / 10000000)%10)), \
+	('0' + (((n) / 1000000)%10)),  \
+	('0' + (((n) / 100000)%10)),   \
+	('0' + (((n) / 10000)%10)),    \
+	('0' + (((n) / 1000)%10)),     \
+	('0' + (((n) / 100)%10)),      \
+	('0' + (((n) / 10)%10)),       \
+	('0' +  ((n) % 10))
 
 /* Convert integer to hex digit literals.  */
 #define HEX(n)             \
-  ('0' + ((n)>>28 & 0xF)), \
-  ('0' + ((n)>>24 & 0xF)), \
-  ('0' + ((n)>>20 & 0xF)), \
-  ('0' + ((n)>>16 & 0xF)), \
-  ('0' + ((n)>>12 & 0xF)), \
-  ('0' + ((n)>>8  & 0xF)), \
-  ('0' + ((n)>>4  & 0xF)), \
-  ('0' + ((n)     & 0xF))
+	('0' + ((n)>>28 & 0xF)), \
+	('0' + ((n)>>24 & 0xF)), \
+	('0' + ((n)>>20 & 0xF)), \
+	('0' + ((n)>>16 & 0xF)), \
+	('0' + ((n)>>12 & 0xF)), \
+	('0' + ((n)>>8  & 0xF)), \
+	('0' + ((n)>>4  & 0xF)), \
+	('0' + ((n)     & 0xF))
 
 /* Construct a string literal encoding the version number. */
 #ifdef COMPILER_VERSION
@@ -781,13 +781,14 @@

 # ifdef COMPILER_VERSION_MINOR
   '.', COMPILER_VERSION_MINOR,
 #  ifdef COMPILER_VERSION_PATCH
-   '.', COMPILER_VERSION_PATCH,
+  '.', COMPILER_VERSION_PATCH,
 #   ifdef COMPILER_VERSION_TWEAK
-    '.', COMPILER_VERSION_TWEAK,
+  '.', COMPILER_VERSION_TWEAK,
 #   endif
 #  endif
 # endif
-  ']','\0'};
+  ']','\0'
+};
 #endif
 
 /* Construct a string literal encoding the internal version number. */
@@ -796,7 +797,8 @@

   'I', 'N', 'F', 'O', ':',
   'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
   'i','n','t','e','r','n','a','l','[',
-  COMPILER_VERSION_INTERNAL,']','\0'};
+  COMPILER_VERSION_INTERNAL,']','\0'
+};
 #elif defined(COMPILER_VERSION_INTERNAL_STR)
 char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
 #endif
@@ -810,13 +812,14 @@

 # ifdef SIMULATE_VERSION_MINOR
   '.', SIMULATE_VERSION_MINOR,
 #  ifdef SIMULATE_VERSION_PATCH
-   '.', SIMULATE_VERSION_PATCH,
+  '.', SIMULATE_VERSION_PATCH,
 #   ifdef SIMULATE_VERSION_TWEAK
-    '.', SIMULATE_VERSION_TWEAK,
+  '.', SIMULATE_VERSION_TWEAK,
 #   endif
 #  endif
 # endif
-  ']','\0'};
+  ']','\0'
+};
 #endif
 
 /* Construct the string literal in pieces to prevent the source from
@@ -859,18 +862,19 @@

 
 const char* info_language_extensions_default = "INFO" ":" "extensions_default["
 #if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
-     defined(__TI_COMPILER_VERSION__)) &&                                     \
-  !defined(__STRICT_ANSI__)
-  "ON"
+					       defined(__TI_COMPILER_VERSION__)) &&                                     \
+					       !defined(__STRICT_ANSI__)
+                                               "ON"
 #else
-  "OFF"
-#endif
-"]";
+                                               "OFF"
+#endif
+                                               "]";
 
 /*--------------------------------------------------------------------------*/
 
 #ifdef ID_VOID_MAIN
-void main() {}
+void main() {
+}
 #else
 # if defined(__CLASSIC_C__)
 int main(argc, argv) int argc; char *argv[];
tests/mechanical_layer/src/InputStatic.cpp
====================
--- original

+++ formatted

@@ -10,52 +10,52 @@

  */
 int readParameters(const string& file)
 {
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse Parameters file " << file << endl;
-        return EXIT_FAILURE;
-    }
-    /*  Read the Parameters block */
-    tinyxml2::XMLElement* parametersElement = document.FirstChildElement("Parameters");
-    if (!parametersElement) {
-        cerr << "Error: Parameters must be embedded in \"Parameters\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-    /*  Read times */
-    const tinyxml2::XMLElement* timesElement = parametersElement->FirstChildElement("Times");
-    if (!timesElement) {
-        cerr << "Error: no Times present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    if (timesElement->QueryDoubleAttribute("TimeStep", &dt) != tinyxml2::XML_SUCCESS) {
-        cerr << R"(Error: Could not read "TimeStep" attribute in )" << file << endl;
-        return EXIT_FAILURE;
-    }
-    if (timesElement->QueryDoubleAttribute("TimeStepMechanical", &dt_mech) != tinyxml2::XML_SUCCESS) {
-        cerr << R"(Error: Could not read "TimeStepMechanical" attribute in )" << file << endl;
-        return EXIT_FAILURE;
-    }
-    /// Process Id: UNUSED
-    const tinyxml2::XMLElement* processElement = parametersElement->FirstChildElement("Process");
-    if (!processElement) {
-        cerr << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))" << endl;
-        return EXIT_FAILURE;
-    }
-    if (processElement->QueryStringAttribute("Id", &processId) != tinyxml2::XML_SUCCESS) {
-        cerr << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))" << endl;
-        return EXIT_FAILURE;
-    }
-    /*  Input and Output directories: if not present, we leave the default as is    */
-    const char* staticDirectory, *dynamicDirectory;
-    if (const tinyxml2::XMLElement* directoriesElement = parametersElement->FirstChildElement("Directories")) {
-        if (directoriesElement->QueryStringAttribute("Static", &staticDirectory) == tinyxml2::XML_SUCCESS)
-            pathStatic = staticDirectory;
-        if (directoriesElement->QueryStringAttribute("Dynamic", &dynamicDirectory) == tinyxml2::XML_SUCCESS)
-            pathDynamic = dynamicDirectory;
-    }
-
-    return EXIT_SUCCESS;
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse Parameters file " << file << endl;
+    return EXIT_FAILURE;
+  }
+  /*  Read the Parameters block */
+  tinyxml2::XMLElement* parametersElement = document.FirstChildElement("Parameters");
+  if (!parametersElement) {
+    cerr << "Error: Parameters must be embedded in \"Parameters\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+  /*  Read times */
+  const tinyxml2::XMLElement* timesElement = parametersElement->FirstChildElement("Times");
+  if (!timesElement) {
+    cerr << "Error: no Times present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  if (timesElement->QueryDoubleAttribute("TimeStep", &dt) != tinyxml2::XML_SUCCESS) {
+    cerr << R"(Error: Could not read "TimeStep" attribute in )" << file << endl;
+    return EXIT_FAILURE;
+  }
+  if (timesElement->QueryDoubleAttribute("TimeStepMechanical", &dt_mech) != tinyxml2::XML_SUCCESS) {
+    cerr << R"(Error: Could not read "TimeStepMechanical" attribute in )" << file << endl;
+    return EXIT_FAILURE;
+  }
+  /// Process Id: UNUSED
+  const tinyxml2::XMLElement* processElement = parametersElement->FirstChildElement("Process");
+  if (!processElement) {
+    cerr << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))" << endl;
+    return EXIT_FAILURE;
+  }
+  if (processElement->QueryStringAttribute("Id", &processId) != tinyxml2::XML_SUCCESS) {
+    cerr << R"(Error: you must specify an identifier for the run ("id" in "Process" tag))" << endl;
+    return EXIT_FAILURE;
+  }
+  /*  Input and Output directories: if not present, we leave the default as is    */
+  const char* staticDirectory, *dynamicDirectory;
+  if (const tinyxml2::XMLElement* directoriesElement = parametersElement->FirstChildElement("Directories")) {
+    if (directoriesElement->QueryStringAttribute("Static", &staticDirectory) == tinyxml2::XML_SUCCESS)
+      pathStatic = staticDirectory;
+    if (directoriesElement->QueryStringAttribute("Dynamic", &dynamicDirectory) == tinyxml2::XML_SUCCESS)
+      pathDynamic = dynamicDirectory;
+  }
+
+  return EXIT_SUCCESS;
 }
 /**
  * @brief Reads the Materials XML file.
@@ -66,159 +66,159 @@

  */
 int readMaterials(const string& file, map<string, int32_t>& materialMapping)
 {
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << file << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Read the Materials block */
-    tinyxml2::XMLElement* materialsElement = document.FirstChildElement("Materials");
-    if (!materialsElement) {
-        cerr << "Error: Information about materials must be embedded in \"Materials\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Read intrinsic properties */
-    const tinyxml2::XMLElement* intrinsicElement = materialsElement->FirstChildElement("Intrinsic");
-    if (!intrinsicElement) {
-        cerr << "Error: no Intrinsic tag present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    /// Materials
-    vector<double2> elasticProperties;
-    const tinyxml2::XMLElement* materialElement  = intrinsicElement->FirstChildElement("Material");
-    if (!materialElement) {
-        cerr << "Error: no materials in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    nMaterials = 0;
-    while (materialElement) {
-        const char* id = nullptr;
-        if (materialElement->QueryStringAttribute("Id", &id) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: found material with no id in " << file << endl;
-        };
-        materialMapping[id] = static_cast<int32_t>(nDefaultMaterials + nMaterials);
-        double E, G;
-        if (materialElement->QueryDoubleAttribute("YoungModulus", &E) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material id " << id << ": Young's modulus (E) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        if (materialElement->QueryDoubleAttribute("ShearModulus", &G) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material id " << id << ": Shear modulus (G) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        elasticProperties.emplace_back(E, G);
-
-        materialElement = materialElement->NextSiblingElement("Material");
-        nMaterials++;
-    }
-    /*  Allocate global variables, now that we know the materials   */
-    intrinsicProperties = new double*[nIntrinsicProperties];
-    for (uint32_t i = 0; i < nIntrinsicProperties; i++) {
-        intrinsicProperties[i] = new double[nDefaultMaterials + nMaterials];
-    }
-    //  Populate intrinsic parameters
-    for (uint32_t i = 0; i < nMaterials; i++) {
-        intrinsicProperties[YOUNG_MODULUS][nDefaultMaterials + i]   = elasticProperties[i].first;
-        intrinsicProperties[SHEAR_MODULUS][nDefaultMaterials + i]   = elasticProperties[i].second;
-    }
-    //  Default materials
-    intrinsicProperties[YOUNG_MODULUS][PEDESTRIAN]   = E_pedestrian;
-    intrinsicProperties[SHEAR_MODULUS][PEDESTRIAN]   = G_pedestrian;
-    intrinsicProperties[YOUNG_MODULUS][WALL]   = E_wall;
-    intrinsicProperties[SHEAR_MODULUS][WALL]   = G_wall;
-
-
-    binaryProperties = new double**[nBinaryProperties];
-    for (uint32_t i = 0; i < nBinaryProperties; i++) {
-        binaryProperties[i] = new double*[nDefaultMaterials + nMaterials];
-        for (uint32_t j = 0; j <  nDefaultMaterials + nMaterials; j++) {
-            binaryProperties[i][j] = new double[nDefaultMaterials + nMaterials];
-        }
-    }
-    /// Find stiffness combinations from intrinsic properties
-    for (uint32_t i = 0; i < nDefaultMaterials + nMaterials; i++) {
-        for (uint32_t j = 0; j < nDefaultMaterials + nMaterials; j++) {
-            double stiffnessNormal      = computeStiffnessNormal(i, j);
-            binaryProperties[STIFFNESS_NORMAL][j][i]     = stiffnessNormal;
-            binaryProperties[STIFFNESS_NORMAL][i][j]     = stiffnessNormal;
-            double stiffnessTangential  = computeStiffnessTangential(i, j);
-            binaryProperties[STIFFNESS_TANGENTIAL][j][i] = stiffnessTangential;
-            binaryProperties[STIFFNESS_TANGENTIAL][i][j] = stiffnessTangential;
-        }
-    }
-
-    /// Populate binaryProperties for default materials
-    binaryProperties[DAMPING_NORMAL][PEDESTRIAN][PEDESTRIAN]        = gamma_n;
-    binaryProperties[DAMPING_NORMAL][PEDESTRIAN][WALL]              = gamma_n_wall;
-    binaryProperties[DAMPING_NORMAL][WALL][PEDESTRIAN]              = gamma_n_wall;
-    binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][PEDESTRIAN]    = gamma_t;
-    binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][WALL]          = gamma_t_wall;
-    binaryProperties[DAMPING_TANGENTIAL][WALL][PEDESTRIAN]          = gamma_t_wall;
-    binaryProperties[FRICTION_SLIDING][PEDESTRIAN][PEDESTRIAN]      = mu_dyn;
-    binaryProperties[FRICTION_SLIDING][PEDESTRIAN][WALL]            = mu_dyn_wall;
-    binaryProperties[FRICTION_SLIDING][WALL][PEDESTRIAN]            = mu_dyn_wall;
-    for (uint32_t i = nDefaultMaterials; i < nDefaultMaterials + nMaterials; i++) {
-        binaryProperties[DAMPING_NORMAL][PEDESTRIAN][i] = gamma_n;
-        binaryProperties[DAMPING_NORMAL][i][PEDESTRIAN] = gamma_n;
-        binaryProperties[DAMPING_NORMAL][WALL][i] = gamma_n_wall;
-        binaryProperties[DAMPING_NORMAL][i][WALL] = gamma_n_wall;
-        binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][i] = gamma_t;
-        binaryProperties[DAMPING_TANGENTIAL][i][PEDESTRIAN] = gamma_t;
-        binaryProperties[DAMPING_TANGENTIAL][WALL][i] = gamma_t_wall;
-        binaryProperties[DAMPING_TANGENTIAL][i][WALL] = gamma_t_wall;
-        binaryProperties[FRICTION_SLIDING][PEDESTRIAN][i] = mu_dyn;
-        binaryProperties[FRICTION_SLIDING][i][PEDESTRIAN] = mu_dyn;
-        binaryProperties[FRICTION_SLIDING][WALL][i] = mu_dyn_wall;
-        binaryProperties[FRICTION_SLIDING][i][WALL] = mu_dyn_wall;
-    }
-
-    /*  Read relationships for the rest of the binary properties    */
-    const tinyxml2::XMLElement* relationshipsElement = materialsElement->FirstChildElement("Binary");
-    if (!relationshipsElement) {
-        cerr << "Error: no Binary tag present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    const tinyxml2::XMLElement* relationshipElement = relationshipsElement->FirstChildElement("Contact");
-    if (!relationshipElement) {
-        cerr << "Error: no relationships in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    while (relationshipElement) {
-        const char* id1 = nullptr;
-        const char* id2 = nullptr;
-        relationshipElement->QueryStringAttribute("Id1", &id1);
-        relationshipElement->QueryStringAttribute("Id2", &id2);
-        if (!materialMapping.contains(id1) or !materialMapping.contains(id2)) {
-            cerr << "Error: relationships include unknown material ids " << id1 << "or " << id2 << "." << endl;
-            return EXIT_FAILURE;
-        }
-        double gamma_n, gamma_t, mu_d;
-        if (relationshipElement->QueryDoubleAttribute("GammaNormal", &gamma_n) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material ids " << id1 << "-" << id2 << ": normal damping (GammaNormal) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        if (relationshipElement->QueryDoubleAttribute("GammaTangential", &gamma_t) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material ids " << id1 << "-" << id2 << ": tangential damping (GammaTangential) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        if (relationshipElement->QueryDoubleAttribute("KineticFriction", &mu_d) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error for material ids " << id1 << "-" << id2 << ": kinetic friction (KineticFriction) not provided!" << endl;
-            return EXIT_FAILURE;
-        };
-        //  Fill the remaining slots in the symmetric binaryProperties matrix
-        binaryProperties[DAMPING_NORMAL][materialMapping[id1]][materialMapping[id2]] = gamma_n;
-        binaryProperties[DAMPING_NORMAL][materialMapping[id2]][materialMapping[id1]] = gamma_n;
-        binaryProperties[DAMPING_TANGENTIAL][materialMapping[id1]][materialMapping[id2]] = gamma_t;
-        binaryProperties[DAMPING_TANGENTIAL][materialMapping[id2]][materialMapping[id1]] = gamma_t;
-        binaryProperties[FRICTION_SLIDING][materialMapping[id1]][materialMapping[id2]] = mu_d;
-        binaryProperties[FRICTION_SLIDING][materialMapping[id2]][materialMapping[id1]] = mu_d;
-        relationshipElement = relationshipElement->NextSiblingElement("Contact");
-    }
-
-    return EXIT_SUCCESS;
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << file << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read the Materials block */
+  tinyxml2::XMLElement* materialsElement = document.FirstChildElement("Materials");
+  if (!materialsElement) {
+    cerr << "Error: Information about materials must be embedded in \"Materials\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read intrinsic properties */
+  const tinyxml2::XMLElement* intrinsicElement = materialsElement->FirstChildElement("Intrinsic");
+  if (!intrinsicElement) {
+    cerr << "Error: no Intrinsic tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  /// Materials
+  vector<double2> elasticProperties;
+  const tinyxml2::XMLElement* materialElement  = intrinsicElement->FirstChildElement("Material");
+  if (!materialElement) {
+    cerr << "Error: no materials in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  nMaterials = 0;
+  while (materialElement) {
+    const char* id = nullptr;
+    if (materialElement->QueryStringAttribute("Id", &id) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: found material with no id in " << file << endl;
+    };
+    materialMapping[id] = static_cast<int32_t>(nDefaultMaterials + nMaterials);
+    double E, G;
+    if (materialElement->QueryDoubleAttribute("YoungModulus", &E) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material id " << id << ": Young's modulus (E) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    if (materialElement->QueryDoubleAttribute("ShearModulus", &G) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material id " << id << ": Shear modulus (G) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    elasticProperties.emplace_back(E, G);
+
+    materialElement = materialElement->NextSiblingElement("Material");
+    nMaterials++;
+  }
+  /*  Allocate global variables, now that we know the materials   */
+  intrinsicProperties = new double*[nIntrinsicProperties];
+  for (uint32_t i = 0; i < nIntrinsicProperties; i++) {
+    intrinsicProperties[i] = new double[nDefaultMaterials + nMaterials];
+  }
+  //  Populate intrinsic parameters
+  for (uint32_t i = 0; i < nMaterials; i++) {
+    intrinsicProperties[YOUNG_MODULUS][nDefaultMaterials + i]   = elasticProperties[i].first;
+    intrinsicProperties[SHEAR_MODULUS][nDefaultMaterials + i]   = elasticProperties[i].second;
+  }
+  //  Default materials
+  intrinsicProperties[YOUNG_MODULUS][PEDESTRIAN]   = E_pedestrian;
+  intrinsicProperties[SHEAR_MODULUS][PEDESTRIAN]   = G_pedestrian;
+  intrinsicProperties[YOUNG_MODULUS][WALL]   = E_wall;
+  intrinsicProperties[SHEAR_MODULUS][WALL]   = G_wall;
+
+
+  binaryProperties = new double**[nBinaryProperties];
+  for (uint32_t i = 0; i < nBinaryProperties; i++) {
+    binaryProperties[i] = new double*[nDefaultMaterials + nMaterials];
+    for (uint32_t j = 0; j <  nDefaultMaterials + nMaterials; j++) {
+      binaryProperties[i][j] = new double[nDefaultMaterials + nMaterials];
+    }
+  }
+  /// Find stiffness combinations from intrinsic properties
+  for (uint32_t i = 0; i < nDefaultMaterials + nMaterials; i++) {
+    for (uint32_t j = 0; j < nDefaultMaterials + nMaterials; j++) {
+      double stiffnessNormal      = computeStiffnessNormal(i, j);
+      binaryProperties[STIFFNESS_NORMAL][j][i]     = stiffnessNormal;
+      binaryProperties[STIFFNESS_NORMAL][i][j]     = stiffnessNormal;
+      double stiffnessTangential  = computeStiffnessTangential(i, j);
+      binaryProperties[STIFFNESS_TANGENTIAL][j][i] = stiffnessTangential;
+      binaryProperties[STIFFNESS_TANGENTIAL][i][j] = stiffnessTangential;
+    }
+  }
+
+  /// Populate binaryProperties for default materials
+  binaryProperties[DAMPING_NORMAL][PEDESTRIAN][PEDESTRIAN]        = gamma_n;
+  binaryProperties[DAMPING_NORMAL][PEDESTRIAN][WALL]              = gamma_n_wall;
+  binaryProperties[DAMPING_NORMAL][WALL][PEDESTRIAN]              = gamma_n_wall;
+  binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][PEDESTRIAN]    = gamma_t;
+  binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][WALL]          = gamma_t_wall;
+  binaryProperties[DAMPING_TANGENTIAL][WALL][PEDESTRIAN]          = gamma_t_wall;
+  binaryProperties[FRICTION_SLIDING][PEDESTRIAN][PEDESTRIAN]      = mu_dyn;
+  binaryProperties[FRICTION_SLIDING][PEDESTRIAN][WALL]            = mu_dyn_wall;
+  binaryProperties[FRICTION_SLIDING][WALL][PEDESTRIAN]            = mu_dyn_wall;
+  for (uint32_t i = nDefaultMaterials; i < nDefaultMaterials + nMaterials; i++) {
+    binaryProperties[DAMPING_NORMAL][PEDESTRIAN][i] = gamma_n;
+    binaryProperties[DAMPING_NORMAL][i][PEDESTRIAN] = gamma_n;
+    binaryProperties[DAMPING_NORMAL][WALL][i] = gamma_n_wall;
+    binaryProperties[DAMPING_NORMAL][i][WALL] = gamma_n_wall;
+    binaryProperties[DAMPING_TANGENTIAL][PEDESTRIAN][i] = gamma_t;
+    binaryProperties[DAMPING_TANGENTIAL][i][PEDESTRIAN] = gamma_t;
+    binaryProperties[DAMPING_TANGENTIAL][WALL][i] = gamma_t_wall;
+    binaryProperties[DAMPING_TANGENTIAL][i][WALL] = gamma_t_wall;
+    binaryProperties[FRICTION_SLIDING][PEDESTRIAN][i] = mu_dyn;
+    binaryProperties[FRICTION_SLIDING][i][PEDESTRIAN] = mu_dyn;
+    binaryProperties[FRICTION_SLIDING][WALL][i] = mu_dyn_wall;
+    binaryProperties[FRICTION_SLIDING][i][WALL] = mu_dyn_wall;
+  }
+
+  /*  Read relationships for the rest of the binary properties    */
+  const tinyxml2::XMLElement* relationshipsElement = materialsElement->FirstChildElement("Binary");
+  if (!relationshipsElement) {
+    cerr << "Error: no Binary tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  const tinyxml2::XMLElement* relationshipElement = relationshipsElement->FirstChildElement("Contact");
+  if (!relationshipElement) {
+    cerr << "Error: no relationships in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  while (relationshipElement) {
+    const char* id1 = nullptr;
+    const char* id2 = nullptr;
+    relationshipElement->QueryStringAttribute("Id1", &id1);
+    relationshipElement->QueryStringAttribute("Id2", &id2);
+    if (!materialMapping.contains(id1) or !materialMapping.contains(id2)) {
+      cerr << "Error: relationships include unknown material ids " << id1 << "or " << id2 << "." << endl;
+      return EXIT_FAILURE;
+    }
+    double gamma_n, gamma_t, mu_d;
+    if (relationshipElement->QueryDoubleAttribute("GammaNormal", &gamma_n) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material ids " << id1 << "-" << id2 << ": normal damping (GammaNormal) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    if (relationshipElement->QueryDoubleAttribute("GammaTangential", &gamma_t) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material ids " << id1 << "-" << id2 << ": tangential damping (GammaTangential) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    if (relationshipElement->QueryDoubleAttribute("KineticFriction", &mu_d) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error for material ids " << id1 << "-" << id2 << ": kinetic friction (KineticFriction) not provided!" << endl;
+      return EXIT_FAILURE;
+    };
+    //  Fill the remaining slots in the symmetric binaryProperties matrix
+    binaryProperties[DAMPING_NORMAL][materialMapping[id1]][materialMapping[id2]] = gamma_n;
+    binaryProperties[DAMPING_NORMAL][materialMapping[id2]][materialMapping[id1]] = gamma_n;
+    binaryProperties[DAMPING_TANGENTIAL][materialMapping[id1]][materialMapping[id2]] = gamma_t;
+    binaryProperties[DAMPING_TANGENTIAL][materialMapping[id2]][materialMapping[id1]] = gamma_t;
+    binaryProperties[FRICTION_SLIDING][materialMapping[id1]][materialMapping[id2]] = mu_d;
+    binaryProperties[FRICTION_SLIDING][materialMapping[id2]][materialMapping[id1]] = mu_d;
+    relationshipElement = relationshipElement->NextSiblingElement("Contact");
+  }
+
+  return EXIT_SUCCESS;
 }
 /**
  * @brief Reads the Geometry XML file.
@@ -229,78 +229,78 @@

  */
 int readGeometry(const string& file, map<string, int32_t>& materialMapping)
 {
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << file << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Read the Geometry block */
-    tinyxml2::XMLElement* geometryElement = document.FirstChildElement("Geometry");
-    if (!geometryElement) {
-        cerr << "Error: Information about geometry must be embedded in \"Geometry\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Read dimensions */
-    const tinyxml2::XMLElement* dimensionsElement = geometryElement->FirstChildElement("Dimensions");
-    if (!dimensionsElement) {
-        cerr << "Error: no Dimensions tag present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    if (dimensionsElement->QueryDoubleAttribute("Lx", &Lx) != tinyxml2::XML_SUCCESS) {
-        cerr << "Error: Could not parse domain dimensions from XML file " << file << endl;
-        return EXIT_FAILURE;
-    };
-    if (dimensionsElement->QueryDoubleAttribute("Ly", &Ly) != tinyxml2::XML_SUCCESS) {
-        cerr << "Error: Could not parse domain dimensions from XML file " << file << endl;
-        return EXIT_FAILURE;
-    };
-
-    /*  Read Walls  */
-    const tinyxml2::XMLElement* wallElement = geometryElement->FirstChildElement("Wall");
-    if (!wallElement) {
-        cerr << "Error: no wall present on geometry file " << file << endl;
-        return EXIT_FAILURE;
-    }
-    while (wallElement != nullptr) {
-        /// Fetch material
-        const char * materialId = nullptr;
-        wallElement->QueryStringAttribute("MaterialId", &materialId);
-        if (!materialId or !materialMapping.contains(materialId)) {
-            // cout << "Warning: unknown or absent material id " << materialId << "given for one of the walls.";
-            // cout << "The default material will be used." << endl;
-            obstaclesMaterial.push_back(WALL);  //  If unknown id, give the default WALL material
-        }
-        else obstaclesMaterial.push_back(materialMapping[materialId]);
-
-        vector<double2> wall;
-        const tinyxml2::XMLElement* cornerElement   = wallElement->FirstChildElement("Corner");
-        if (!cornerElement) {
-            cerr << "Error: no corners in wall!" << endl;
-            return EXIT_FAILURE;
-        }
-        while (cornerElement != nullptr) {
-            const char* buffer = nullptr;
-            if (cornerElement->QueryStringAttribute("Coordinates", &buffer) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: Could not parse corner coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            auto [rc, coordinates] = parse2DComponents(buffer);
-            if (rc != EXIT_SUCCESS) {
-                cerr << "Error: Could not parse corner coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            wall.emplace_back(coordinates);
-            cornerElement = cornerElement->NextSiblingElement("Corner");
-        }
-        listObstacles.push_back(wall);
-
-        wallElement = wallElement->NextSiblingElement("Wall");
-    }
-
-     return EXIT_SUCCESS;
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << file << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read the Geometry block */
+  tinyxml2::XMLElement* geometryElement = document.FirstChildElement("Geometry");
+  if (!geometryElement) {
+    cerr << "Error: Information about geometry must be embedded in \"Geometry\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read dimensions */
+  const tinyxml2::XMLElement* dimensionsElement = geometryElement->FirstChildElement("Dimensions");
+  if (!dimensionsElement) {
+    cerr << "Error: no Dimensions tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  if (dimensionsElement->QueryDoubleAttribute("Lx", &Lx) != tinyxml2::XML_SUCCESS) {
+    cerr << "Error: Could not parse domain dimensions from XML file " << file << endl;
+    return EXIT_FAILURE;
+  };
+  if (dimensionsElement->QueryDoubleAttribute("Ly", &Ly) != tinyxml2::XML_SUCCESS) {
+    cerr << "Error: Could not parse domain dimensions from XML file " << file << endl;
+    return EXIT_FAILURE;
+  };
+
+  /*  Read Walls  */
+  const tinyxml2::XMLElement* wallElement = geometryElement->FirstChildElement("Wall");
+  if (!wallElement) {
+    cerr << "Error: no wall present on geometry file " << file << endl;
+    return EXIT_FAILURE;
+  }
+  while (wallElement != nullptr) {
+    /// Fetch material
+    const char * materialId = nullptr;
+    wallElement->QueryStringAttribute("MaterialId", &materialId);
+    if (!materialId or !materialMapping.contains(materialId)) {
+      // cout << "Warning: unknown or absent material id " << materialId << "given for one of the walls.";
+      // cout << "The default material will be used." << endl;
+      obstaclesMaterial.push_back(WALL);        //  If unknown id, give the default WALL material
+    }
+    else obstaclesMaterial.push_back(materialMapping[materialId]);
+
+    vector<double2> wall;
+    const tinyxml2::XMLElement* cornerElement   = wallElement->FirstChildElement("Corner");
+    if (!cornerElement) {
+      cerr << "Error: no corners in wall!" << endl;
+      return EXIT_FAILURE;
+    }
+    while (cornerElement != nullptr) {
+      const char* buffer = nullptr;
+      if (cornerElement->QueryStringAttribute("Coordinates", &buffer) != tinyxml2::XML_SUCCESS) {
+	cerr << "Error: Could not parse corner coordinates from XML file " << file << endl;
+	return EXIT_FAILURE;
+      }
+      auto [rc, coordinates] = parse2DComponents(buffer);
+      if (rc != EXIT_SUCCESS) {
+	cerr << "Error: Could not parse corner coordinates from XML file " << file << endl;
+	return EXIT_FAILURE;
+      }
+      wall.emplace_back(coordinates);
+      cornerElement = cornerElement->NextSiblingElement("Corner");
+    }
+    listObstacles.push_back(wall);
+
+    wallElement = wallElement->NextSiblingElement("Wall");
+  }
+
+  return EXIT_SUCCESS;
 }
 /**
  * @brief Reads the Agents XML file.
@@ -317,128 +317,128 @@

  *         EXIT_SUCCESS otherwise
  */
 int readAgents(
-    const string& file, vector<unsigned>& nShapesPerAgent,
-    vector<unsigned>& shapeIDagent, vector<int>& edges, vector<double>& radii, vector<double>& masses,
-    vector<double>& mois, vector<double2>& delta_gtos, map<string, int32_t>& materialMapping)
-{
-    tinyxml2::XMLDocument document;
-    document.LoadFile(file.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file" << file << endl;
-        return EXIT_FAILURE;
-    }
-
-    /*  Read the Agents block   */
-    tinyxml2::XMLElement* agentsElement         = document.FirstChildElement("Agents");
-    if (!agentsElement) {
-        cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-    const tinyxml2::XMLElement* agentElement    = agentsElement->FirstChildElement("Agent");
-    if (!agentElement) {
-        cerr << "Error: no Agent tag present in " << file << endl;
-        return EXIT_FAILURE;
-    }
-    size_t sGlobal = 0;
-    uint32_t agentId = 0;
-    while (agentElement != nullptr) {
-        //  Id (ignored)
-        const char* externId;
-        if (agentElement->QueryStringAttribute("Id", &externId) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: please provide identifiers for your agents " << endl;
-            return EXIT_FAILURE;
-        };
-        agentMap[externId] = agentId;
-        agentMapInverse.emplace_back(externId);
-        //  Mass and Moment of Inertia
-        double mass, moi;
-        if (agentElement->QueryDoubleAttribute("Mass", &mass) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get mass from agent " << externId << endl;
-        }
-        if (agentElement->QueryDoubleAttribute("MomentOfInertia" , &moi) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: could not get moment of inertia from agent " << externId << endl;
-        }
-        masses.push_back(mass);
-        mois.push_back(moi);
-        double dampingTranslational, dampingRotational;
-        if (agentElement->QueryDoubleAttribute("FloorDamping", &dampingTranslational) != tinyxml2::XML_SUCCESS) {
-            // cout << "Warning: for agent " << externId << ": translational damping (FloorDamping) not provided! ";
-            // cout << "Default value will be used." << endl;
-            dampingTranslational = 1 / tau_mech_translational;
-        };
-        if (agentElement->QueryDoubleAttribute("AngularDamping", &dampingRotational) != tinyxml2::XML_SUCCESS) {
-            // cout << "Warning: for agent " << externId << ": rotational damping (AngularDamping) not provided! ";
-            // cout << "Default value will be used." << endl;
-            dampingRotational = 1 / tau_mech_rotational;
-        };
-        agentProperties.emplace_back(dampingTranslational, dampingRotational);
-
-        /// Shapes
-        const tinyxml2::XMLElement* shapesElement   = agentElement->FirstChildElement("Shapes");
-        if (!shapesElement) {
-            cerr << "Error: shapes must be embedded in \"Shapes\" tag!" << endl;
-            return EXIT_FAILURE;
-        }
-        const tinyxml2::XMLElement* shapeElement    = shapesElement->FirstChildElement("Shape");
-        if (!shapeElement) {
-            cerr << "Error: an agent has no shapes in " << file << endl;
-            return EXIT_FAILURE;
-        }
-        size_t s = 0;
-        while (shapeElement != nullptr) {
-            /// Fill shapeIDagent - as many agentIds as there are shapes for it
-            shapeIDagent.push_back(agentId);
-            /// Fetch id
-            const char* shapeExternId = nullptr;
-            if (shapeElement->QueryStringAttribute("Id", &shapeExternId) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: please provide identifier for your shapes" << endl;
-                return EXIT_FAILURE;
-            }
-            shapeMap[{externId, shapeExternId}] = sGlobal;
-            shapeMapInverse.emplace_back(shapeExternId);
-            /// Fetch material
-            const char * materialId = nullptr;
-            shapeElement->QueryStringAttribute("MaterialId", &materialId);
-            if (!materialId or !materialMapping.contains(materialId)) {
-                // cout << "Warning: unknown or absent material id " << materialId << "given for one of the shapes.";
-                // cout << "The default material will be used." << endl;
-                shapesMaterial[sGlobal] = PEDESTRIAN;    //  if unknown material, give the default
-            }
-            else shapesMaterial[sGlobal] = materialMapping[materialId];
-
-            double radius;
-            if (shapeElement->QueryDoubleAttribute("Radius", &radius) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: could not get radius from shape " << s+1 << " in agent " << agentId << endl;
-                return EXIT_FAILURE;
-            };
-            radii.push_back(radius);
-            const char* buffer = nullptr;
-            if (shapeElement->QueryStringAttribute("Position", &buffer) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: Could not parse shape coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            auto [rc, coordinates] = parse2DComponents(buffer);
-            if (rc != EXIT_SUCCESS) {
-                cerr << "Error: Could not parse shape coordinates from XML file " << file << endl;
-                return EXIT_FAILURE;
-            }
-            delta_gtos.emplace_back(coordinates);
-
-            shapeElement = shapeElement->NextSiblingElement("Shape");
-            s++;
-            sGlobal++;
-        }
-        nShapesPerAgent.push_back(s);
-        edges.push_back(static_cast<int>(sGlobal));
-
-        agentElement = agentElement->NextSiblingElement("Agent");
-        agentId++;
-    }
-
-    nAgents = masses.size();
-    edges.insert(edges.begin(), 0);
-
-    return EXIT_SUCCESS;
+  const string& file, vector<unsigned>& nShapesPerAgent,
+  vector<unsigned>& shapeIDagent, vector<int>& edges, vector<double>& radii, vector<double>& masses,
+  vector<double>& mois, vector<double2>& delta_gtos, map<string, int32_t>& materialMapping)
+{
+  tinyxml2::XMLDocument document;
+  document.LoadFile(file.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file" << file << endl;
+    return EXIT_FAILURE;
+  }
+
+  /*  Read the Agents block   */
+  tinyxml2::XMLElement* agentsElement         = document.FirstChildElement("Agents");
+  if (!agentsElement) {
+    cerr << "Error: agents must be embedded in \"Agents\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+  const tinyxml2::XMLElement* agentElement    = agentsElement->FirstChildElement("Agent");
+  if (!agentElement) {
+    cerr << "Error: no Agent tag present in " << file << endl;
+    return EXIT_FAILURE;
+  }
+  size_t sGlobal = 0;
+  uint32_t agentId = 0;
+  while (agentElement != nullptr) {
+    //  Id (ignored)
+    const char* externId;
+    if (agentElement->QueryStringAttribute("Id", &externId) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: please provide identifiers for your agents " << endl;
+      return EXIT_FAILURE;
+    };
+    agentMap[externId] = agentId;
+    agentMapInverse.emplace_back(externId);
+    //  Mass and Moment of Inertia
+    double mass, moi;
+    if (agentElement->QueryDoubleAttribute("Mass", &mass) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get mass from agent " << externId << endl;
+    }
+    if (agentElement->QueryDoubleAttribute("MomentOfInertia", &moi) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: could not get moment of inertia from agent " << externId << endl;
+    }
+    masses.push_back(mass);
+    mois.push_back(moi);
+    double dampingTranslational, dampingRotational;
+    if (agentElement->QueryDoubleAttribute("FloorDamping", &dampingTranslational) != tinyxml2::XML_SUCCESS) {
+      // cout << "Warning: for agent " << externId << ": translational damping (FloorDamping) not provided! ";
+      // cout << "Default value will be used." << endl;
+      dampingTranslational = 1 / tau_mech_translational;
+    };
+    if (agentElement->QueryDoubleAttribute("AngularDamping", &dampingRotational) != tinyxml2::XML_SUCCESS) {
+      // cout << "Warning: for agent " << externId << ": rotational damping (AngularDamping) not provided! ";
+      // cout << "Default value will be used." << endl;
+      dampingRotational = 1 / tau_mech_rotational;
+    };
+    agentProperties.emplace_back(dampingTranslational, dampingRotational);
+
+    /// Shapes
+    const tinyxml2::XMLElement* shapesElement   = agentElement->FirstChildElement("Shapes");
+    if (!shapesElement) {
+      cerr << "Error: shapes must be embedded in \"Shapes\" tag!" << endl;
+      return EXIT_FAILURE;
+    }
+    const tinyxml2::XMLElement* shapeElement    = shapesElement->FirstChildElement("Shape");
+    if (!shapeElement) {
+      cerr << "Error: an agent has no shapes in " << file << endl;
+      return EXIT_FAILURE;
+    }
+    size_t s = 0;
+    while (shapeElement != nullptr) {
+      /// Fill shapeIDagent - as many agentIds as there are shapes for it
+      shapeIDagent.push_back(agentId);
+      /// Fetch id
+      const char* shapeExternId = nullptr;
+      if (shapeElement->QueryStringAttribute("Id", &shapeExternId) != tinyxml2::XML_SUCCESS) {
+	cerr << "Error: please provide identifier for your shapes" << endl;
+	return EXIT_FAILURE;
+      }
+      shapeMap[{externId, shapeExternId}] = sGlobal;
+      shapeMapInverse.emplace_back(shapeExternId);
+      /// Fetch material
+      const char * materialId = nullptr;
+      shapeElement->QueryStringAttribute("MaterialId", &materialId);
+      if (!materialId or !materialMapping.contains(materialId)) {
+	// cout << "Warning: unknown or absent material id " << materialId << "given for one of the shapes.";
+	// cout << "The default material will be used." << endl;
+	shapesMaterial[sGlobal] = PEDESTRIAN;            //  if unknown material, give the default
+      }
+      else shapesMaterial[sGlobal] = materialMapping[materialId];
+
+      double radius;
+      if (shapeElement->QueryDoubleAttribute("Radius", &radius) != tinyxml2::XML_SUCCESS) {
+	cerr << "Error: could not get radius from shape " << s+1 << " in agent " << agentId << endl;
+	return EXIT_FAILURE;
+      };
+      radii.push_back(radius);
+      const char* buffer = nullptr;
+      if (shapeElement->QueryStringAttribute("Position", &buffer) != tinyxml2::XML_SUCCESS) {
+	cerr << "Error: Could not parse shape coordinates from XML file " << file << endl;
+	return EXIT_FAILURE;
+      }
+      auto [rc, coordinates] = parse2DComponents(buffer);
+      if (rc != EXIT_SUCCESS) {
+	cerr << "Error: Could not parse shape coordinates from XML file " << file << endl;
+	return EXIT_FAILURE;
+      }
+      delta_gtos.emplace_back(coordinates);
+
+      shapeElement = shapeElement->NextSiblingElement("Shape");
+      s++;
+      sGlobal++;
+    }
+    nShapesPerAgent.push_back(s);
+    edges.push_back(static_cast<int>(sGlobal));
+
+    agentElement = agentElement->NextSiblingElement("Agent");
+    agentId++;
+  }
+
+  nAgents = masses.size();
+  edges.insert(edges.begin(), 0);
+
+  return EXIT_SUCCESS;
 }
 
 /**
@@ -449,12 +449,12 @@

  */
 double computeStiffnessNormal(const uint32_t i, const uint32_t j)
 {
-    const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
-    const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
-    const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
-    const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
-
-    return 1 / ((4 * Gi - Ei) / (4 * pow(Gi, 2)) + (4 * Gj - Ej) / (4 * pow(Gj, 2)));
+  const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
+  const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
+  const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
+  const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
+
+  return 1 / ((4 * Gi - Ei) / (4 * pow(Gi, 2)) + (4 * Gj - Ej) / (4 * pow(Gj, 2)));
 }
 /**
  * @brief Computes the tangential stiffness (k_t)
@@ -464,10 +464,10 @@

  */
 double computeStiffnessTangential(const uint32_t i, const uint32_t j)
 {
-    const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
-    const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
-    const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
-    const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
-
-    return 1 / ((6 * Gi - Ei) / (8 * pow(Gi, 2)) + (6 * Gj - Ej) / (8 * pow(Gj, 2)));
-}
+  const double Ei = intrinsicProperties[YOUNG_MODULUS][i];
+  const double Ej = intrinsicProperties[YOUNG_MODULUS][j];
+  const double Gi = intrinsicProperties[SHEAR_MODULUS][i];
+  const double Gj = intrinsicProperties[SHEAR_MODULUS][j];
+
+  return 1 / ((6 * Gi - Ei) / (8 * pow(Gi, 2)) + (6 * Gj - Ej) / (8 * pow(Gj, 2)));
+}
tests/mechanical_layer/include/Globals.h
====================
--- original

+++ formatted

@@ -18,7 +18,7 @@

 
 /*
     New types
-                */
+ */
 typedef std::pair<int, int> int2;
 typedef std::pair<double, double> double2;
 /// Define operations on type double2
@@ -36,9 +36,9 @@

 
 /*
     Global variables
-                        */
+ */
 //  Geometry
-extern std::vector<std::vector<double2>> listObstacles;
+extern std::vector<std::vector<double2> > listObstacles;
 extern double Lx;
 extern double Ly;
 
@@ -63,25 +63,25 @@

 extern uint32_t nMaterials;
 enum __attribute__((__packed__))
 { //  For the two default values
-    PEDESTRIAN = 0,
-    WALL = 1,
+  PEDESTRIAN = 0,
+  WALL = 1,
 };
 extern double **intrinsicProperties;
 constexpr int nIntrinsicProperties = 2;
 enum __attribute__((__packed__))
 {
-    YOUNG_MODULUS = 0,
-    SHEAR_MODULUS = 1,
+  YOUNG_MODULUS = 0,
+  SHEAR_MODULUS = 1,
 };
 extern double ***binaryProperties;
 constexpr int nBinaryProperties = 5;
 enum __attribute__((__packed__))
 {
-    DAMPING_NORMAL = 0,
-    DAMPING_TANGENTIAL = 1,
-    STIFFNESS_NORMAL = 2,
-    STIFFNESS_TANGENTIAL = 3, //  = static friction
-    FRICTION_SLIDING = 4,     //  = kinetic friction
+  DAMPING_NORMAL = 0,
+  DAMPING_TANGENTIAL = 1,
+  STIFFNESS_NORMAL = 2,
+  STIFFNESS_TANGENTIAL = 3,   //  = static friction
+  FRICTION_SLIDING = 4,       //  = kinetic friction
 };
 extern std::vector<int32_t> obstaclesMaterial;
 extern std::map<uint32_t, int32_t> shapesMaterial;
@@ -92,7 +92,7 @@

 
 /*
     Model parameters and user-defined constants
-                                                */
+ */
 /// Materials: default values
 constexpr double E_pedestrian = .24e+6;
 constexpr double G_pedestrian = .1e+6;
@@ -113,7 +113,7 @@

 
 /*
     Function declarations
-                            */
+ */
 /// Utilities
 std::pair<int, double2> parse2DComponents(const char *line);
 //  Physics
tests/mechanical_layer/src/Agent.cpp
====================
--- original

+++ formatted

@@ -19,22 +19,22 @@

  */
 static double size_body(const vector<double2>& delta_gtos, const vector<double>& radius_shapes)
 {
-    double max_delta_gtos = 0.0;
-    size_t cpt_max = 0;
-    for (size_t i = 0; i < delta_gtos.size(); ++i)
+  double max_delta_gtos = 0.0;
+  size_t cpt_max = 0;
+  for (size_t i = 0; i < delta_gtos.size(); ++i)
+  {
+    if (const double magnitude = !delta_gtos[i]; magnitude > max_delta_gtos)
     {
-        if (const double magnitude = !delta_gtos[i]; magnitude > max_delta_gtos)
-        {
-            max_delta_gtos = magnitude;
-            cpt_max = i;
-        }
+      max_delta_gtos = magnitude;
+      cpt_max = i;
     }
-    double radius(radius_shapes[cpt_max]);
-    if (radius_shapes[cpt_max] < 0.0)
-    {
-        radius = -radius_shapes[cpt_max];
-    }
-    return radius + max_delta_gtos;
+  }
+  double radius(radius_shapes[cpt_max]);
+  if (radius_shapes[cpt_max] < 0.0)
+  {
+    radius = -radius_shapes[cpt_max];
+  }
+  return radius + max_delta_gtos;
 }
 
 /**
@@ -60,20 +60,20 @@

 Agent::Agent(unsigned ID, vector<unsigned> Ids_shapes, double x, double y, double vx, double vy, double omega, double2 Fp, double Mp,
              unsigned nb_shapes, const vector<double2>& delta_gtos, const vector<double>& radius_shapes, double theta_body, double theta_body_init,
              double mass, double moi)
-    : _id(ID), _mass(mass), _moi(moi), _ids_shapes(std::move(Ids_shapes)), _radius(size_body(delta_gtos, radius_shapes)),
-      _nb_shapes(nb_shapes), _delta_gtos(delta_gtos), _radius_shapes(radius_shapes), _theta_init(theta_body_init),
-      _x(x), _y(y), _theta(theta_body), _vx(vx), _vy(vy), _w(omega)
+  : _id(ID), _mass(mass), _moi(moi), _ids_shapes(std::move(Ids_shapes)), _radius(size_body(delta_gtos, radius_shapes)),
+  _nb_shapes(nb_shapes), _delta_gtos(delta_gtos), _radius_shapes(radius_shapes), _theta_init(theta_body_init),
+  _x(x), _y(y), _theta(theta_body), _vx(vx), _vy(vy), _w(omega)
 {
-    const double inverseTauMechTranslation   = agentProperties[_id].first;
-    const double inverseTauMechRotation      = agentProperties[_id].second;
-    _vx_des = Fp.first  / inverseTauMechTranslation / _mass;    //  vx_des := Fpx/m * tau_mech
-    _vy_des = Fp.second / inverseTauMechTranslation / _mass;    //  vy_des := Fpy/m * tau_mech
-    _w_des  = Mp / inverseTauMechRotation / _moi;               //  w_des  := Mp/I  * tau_mech
+  const double inverseTauMechTranslation   = agentProperties[_id].first;
+  const double inverseTauMechRotation      = agentProperties[_id].second;
+  _vx_des = Fp.first  / inverseTauMechTranslation / _mass;      //  vx_des := Fpx/m * tau_mech
+  _vy_des = Fp.second / inverseTauMechTranslation / _mass;      //  vy_des := Fpy/m * tau_mech
+  _w_des  = Mp / inverseTauMechRotation / _moi;                 //  w_des  := Mp/I  * tau_mech
 
-    if (not(_vx_des == 0. and _vy_des == 0.))
-        _theta_des = atan2(_vy_des, _vx_des);
-    else _theta_des = 0.;
-    _v_des = double2(_vx_des, _vy_des);
+  if (not (_vx_des == 0. and _vy_des == 0.))
+    _theta_des = atan2(_vy_des, _vx_des);
+  else _theta_des = 0.;
+  _v_des = double2(_vx_des, _vy_des);
 }
 
 /**
@@ -93,19 +93,19 @@

  */
 void Agent::move()
 {
-    _x      += _vx * dt;
-    _y      += _vy * dt;
-    _theta  += _w  * dt;
+  _x      += _vx * dt;
+  _y      += _vy * dt;
+  _theta  += _w  * dt;
 }
 
 vector<double2> Agent::get_delta_gtos()
 {
-    vector<double2> delta_gtos_abs;
-    for (auto [x, y] : _delta_gtos)
-    {
-        const double rotation_angle = _theta - _theta_init;
-        delta_gtos_abs.emplace_back(x * cos(rotation_angle) - y * sin(rotation_angle),
-                                         x * sin(rotation_angle) + y * cos(rotation_angle));
-    }
-    return delta_gtos_abs;
+  vector<double2> delta_gtos_abs;
+  for (auto [x, y] : _delta_gtos)
+  {
+    const double rotation_angle = _theta - _theta_init;
+    delta_gtos_abs.emplace_back(x * cos(rotation_angle) - y * sin(rotation_angle),
+                                x * sin(rotation_angle) + y * cos(rotation_angle));
+  }
+  return delta_gtos_abs;
 }
tests/mechanical_layer/src/Globals.cpp
====================
--- original

+++ formatted

@@ -4,32 +4,52 @@

 
 /*
     Operations on new types: definitions
-                                            */
+ */
 /// Define operations on type double2
 //  Addition of two double2 vectors
-double2 operator+(double2 const &a, double2 const &b) { return {a.first + b.first, a.second + b.second}; }
-double2 operator-(double2 const &a, double2 const &b) { return {a.first - b.first, a.second - b.second}; }
+double2 operator+(double2 const &a, double2 const &b) {
+  return {a.first + b.first, a.second + b.second};
+}
+double2 operator-(double2 const &a, double2 const &b) {
+  return {a.first - b.first, a.second - b.second};
+}
 //  Element-wise multiplication
-double2 operator*(double2 const &a, double2 const &b) { return {a.first * b.first, a.second * b.second}; }
+double2 operator*(double2 const &a, double2 const &b) {
+  return {a.first * b.first, a.second * b.second};
+}
 //  Scalar multiplication with a double2 vector
-double2 operator*(double const coef, double2 const &R) { return {coef * R.first, coef * R.second}; }
+double2 operator*(double const coef, double2 const &R) {
+  return {coef * R.first, coef * R.second};
+}
 //  Dot product
-double operator%(double2 const &a, double2 const &b) { return a.first * b.first + a.second * b.second; }
+double operator%(double2 const &a, double2 const &b) {
+  return a.first * b.first + a.second * b.second;
+}
 // Norm (magnitude) of a double2 vector
-double operator!(double2 const &a) { return sqrt(a % a); }
+double operator!(double2 const &a) {
+  return sqrt(a % a);
+}
 // Cross product-like operation for 2D vectors (returns perpendicular vector scaled by scalar)
-double2 operator^(double const a, double2 const &b) { return {-a * b.second, a * b.first}; }
+double2 operator^(double const a, double2 const &b) {
+  return {-a * b.second, a * b.first};
+}
 
 /// Define operations on type int2
 //  Addition of two int2 vectors
-int2 operator+(int2 const &a, int2 const &b) { return {a.first + b.first, a.second + b.second}; }
-int2 operator-(int2 const &a, int2 const &b) { return {a.first - b.first, a.second - b.second}; }
+int2 operator+(int2 const &a, int2 const &b) {
+  return {a.first + b.first, a.second + b.second};
+}
+int2 operator-(int2 const &a, int2 const &b) {
+  return {a.first - b.first, a.second - b.second};
+}
 //  Element-wise multiplication
-int2 operator*(int2 const &a, int2 const &b) { return {a.first * b.first, a.second * b.second}; }
+int2 operator*(int2 const &a, int2 const &b) {
+  return {a.first * b.first, a.second * b.second};
+}
 
 /*
     Global variables
-                        */
+ */
 uint32_t nAgents;
 map<string, uint32_t> agentMap;                 /// Correspondence between user-given ids and internal ids
 vector<string> agentMapInverse;                 /// Inverse version for output
@@ -44,7 +64,7 @@

 /// Geometry
 double Lx;
 double Ly;
-vector<vector<double2>> listObstacles;
+vector<vector<double2> > listObstacles;
 
 
 /// Basic parameters
@@ -66,7 +86,7 @@

 
 /*
     Utilities functions
-                        */
+ */
 /**
  * @brief Parses a string into a vector of doubles.
  *
@@ -76,25 +96,25 @@

  */
 pair<int, double2> parse2DComponents(const char* line)
 {
-    vector<double> result;
-    stringstream ss(line);
-    string token;
-    uint8_t counter = 0;
-    while (getline(ss, token, ','))
-    {
-        double value;
-        try {
-            value = stod(token);
-        }
-        catch (...) {
-            return {EXIT_FAILURE, {0., 0.}};
-        }
-        result.push_back(value);
-        counter++;
-        if (counter > 2)
-            return {EXIT_FAILURE, {0., 0.}};
+  vector<double> result;
+  stringstream ss(line);
+  string token;
+  uint8_t counter = 0;
+  while (getline(ss, token, ','))
+  {
+    double value;
+    try {
+      value = stod(token);
     }
-    return {EXIT_SUCCESS, {result[0], result[1]}};
+    catch (...) {
+      return {EXIT_FAILURE, {0., 0.}};
+    }
+    result.push_back(value);
+    counter++;
+    if (counter > 2)
+      return {EXIT_FAILURE, {0., 0.}};
+  }
+  return {EXIT_SUCCESS, {result[0], result[1]}};
 }
 
 
@@ -108,17 +128,17 @@

  */
 pair<double, double2> get_distance_to_wall_and_closest_point(double2 vertexA, double2 vertexB, const double2 &C)
 {
-    const double2 AB = vertexB - vertexA;
-    const double2 AC = C - vertexA;
-    const double gamma = AB % AC / (AB % AB);   // coefficient such that the closest point P on (AB) satisfies AP= gamma AB
+  const double2 AB = vertexB - vertexA;
+  const double2 AC = C - vertexA;
+  const double gamma = AB % AC / (AB % AB);     // coefficient such that the closest point P on (AB) satisfies AP= gamma AB
 
-    if (gamma <= 0.0)
-        return make_pair<double, double2>(!AC, double2(vertexA));   // closest point is vertexA
-    if (gamma >= 1.0)
-        return make_pair<double, double2>(!(C - vertexB), double2(vertexB));   // closest point is vertexB
+  if (gamma <= 0.0)
+    return make_pair<double, double2>(!AC, double2(vertexA));       // closest point is vertexA
+  if (gamma >= 1.0)
+    return make_pair<double, double2>(!(C - vertexB), double2(vertexB));       // closest point is vertexB
 
-    double2 P = vertexA + gamma * AB;   // closest point P on (AB) to C
-    return make_pair<double, double2>(!(C - P), double2(P));
+  double2 P = vertexA + gamma * AB;     // closest point P on (AB) to C
+  return make_pair<double, double2>(!(C - P), double2(P));
 }
 
 /**
@@ -130,7 +150,9 @@

  * @param length The length of the interval.
  * @return The interval of the value within the specified length.
  */
-inline double get_interval(const double x, const double length) { return fmod(x + 0.5 * length, length) - 0.5 * length; }
+inline double get_interval(const double x, const double length) {
+  return fmod(x + 0.5 * length, length) - 0.5 * length;
+}
 
 /**
  * Calculates the Euclidean distance between two points in a 2D space lattice.
@@ -141,8 +163,8 @@

  */
 double get_distance(const double2 &A, const double2 &B)
 {
-    const double x_mod = get_interval(A.first - B.first, Lx);
-    const double y_mod = get_interval(A.second - B.second, Ly);
-    return sqrt(pow(x_mod, 2) + pow(y_mod, 2));
+  const double x_mod = get_interval(A.first - B.first, Lx);
+  const double y_mod = get_interval(A.second - B.second, Ly);
+  return sqrt(pow(x_mod, 2) + pow(y_mod, 2));
 }
 
tests/mechanical_layer/include/Crowd.h
====================
--- original

+++ formatted

@@ -10,10 +10,10 @@

 /// Functions
 ///     Initialise scene
 int initialiseSetting(const std::string &dynamicsFile,
-                       std::vector<unsigned> &nb_shapes_allagents, std::vector<unsigned> &shapeIDagent,
-                       std::vector<int> &edges,
-                       std::vector<double> &radius_allshapes, std::vector<double> &masses, std::vector<double> &mois,
-                       std::vector<double2> &delta_gtos);
+                      std::vector<unsigned> &nb_shapes_allagents, std::vector<unsigned> &shapeIDagent,
+                      std::vector<int> &edges,
+                      std::vector<double> &radius_allshapes, std::vector<double> &masses, std::vector<double> &mois,
+                      std::vector<double2> &delta_gtos);
 ///     Prepare mechanical layer
 bool is_mechanically_active(const Agent* agent);
 void determine_agents_neighbours();
tests/mechanical_layer/build/CMakeFiles/4.0.1/CompilerIdCXX/CMakeCXXCompilerId.cpp
====================
--- original

+++ formatted

@@ -23,8 +23,8 @@

 # if defined(__GNUC__)
 #  define SIMULATE_ID "GNU"
 # endif
-  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
-     except that a few beta releases use the old format with V=2021.  */
+/* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
+   except that a few beta releases use the old format with V=2021.  */
 # if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
 #  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
 #  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
@@ -36,16 +36,16 @@

 # else
 #  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
 #  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
-   /* The third version component from --version is an update index,
-      but no macro is provided for it.  */
+/* The third version component from --version is an update index,
+   but no macro is provided for it.  */
 #  define COMPILER_VERSION_PATCH DEC(0)
 # endif
 # if defined(__INTEL_COMPILER_BUILD_DATE)
-   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
+/* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
 #  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
 # endif
 # if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 # endif
@@ -83,7 +83,7 @@

 # define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
 #endif
 #if defined(_MSC_VER)
-  /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 # define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 # define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 #endif
@@ -115,13 +115,13 @@

 
 #elif defined(__BORLANDC__)
 # define COMPILER_ID "Borland"
-  /* __BORLANDC__ = 0xVRR */
+/* __BORLANDC__ = 0xVRR */
 # define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
 # define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)
 
 #elif defined(__WATCOMC__) && __WATCOMC__ < 1200
 # define COMPILER_ID "Watcom"
-   /* __WATCOMC__ = VVRR */
+/* __WATCOMC__ = VVRR */
 # define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
 # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
 # if (__WATCOMC__ % 10) > 0
@@ -130,7 +130,7 @@

 
 #elif defined(__WATCOMC__)
 # define COMPILER_ID "OpenWatcom"
-   /* __WATCOMC__ = VVRP + 1100 */
+/* __WATCOMC__ = VVRP + 1100 */
 # define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
 # define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
 # if (__WATCOMC__ % 10) > 0
@@ -140,12 +140,12 @@

 #elif defined(__SUNPRO_CC)
 # define COMPILER_ID "SunPro"
 # if __SUNPRO_CC >= 0x5100
-   /* __SUNPRO_CC = 0xVRRP */
+/* __SUNPRO_CC = 0xVRRP */
 #  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
 #  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
 #  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
 # else
-   /* __SUNPRO_CC = 0xVRP */
+/* __SUNPRO_CC = 0xVRP */
 #  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
 #  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
 #  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
@@ -153,21 +153,21 @@

 
 #elif defined(__HP_aCC)
 # define COMPILER_ID "HP"
-  /* __HP_aCC = VVRRPP */
+/* __HP_aCC = VVRRPP */
 # define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
 # define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
 # define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)
 
 #elif defined(__DECCXX)
 # define COMPILER_ID "Compaq"
-  /* __DECCXX_VER = VVRRTPPPP */
+/* __DECCXX_VER = VVRRTPPPP */
 # define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
 # define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
 # define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)
 
 #elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
 # define COMPILER_ID "zOS"
-  /* __IBMCPP__ = VRP */
+/* __IBMCPP__ = VRP */
 # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
 # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
 # define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
@@ -191,14 +191,14 @@

 
 #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
 # define COMPILER_ID "XL"
-  /* __IBMCPP__ = VRP */
+/* __IBMCPP__ = VRP */
 # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
 # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
 # define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
 
 #elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
 # define COMPILER_ID "VisualAge"
-  /* __IBMCPP__ = VRP */
+/* __IBMCPP__ = VRP */
 # define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
 # define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
 # define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)
@@ -234,7 +234,7 @@

 
 #elif defined(__TI_COMPILER_VERSION__)
 # define COMPILER_ID "TI"
-  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
+/* __TI_COMPILER_VERSION__ = VVVRRRPPP */
 # define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
 # define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
 # define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)
@@ -290,12 +290,12 @@

 #elif defined(__ARMCC_VERSION) && !defined(__clang__)
 # define COMPILER_ID "ARMCC"
 #if __ARMCC_VERSION >= 1000000
-  /* __ARMCC_VERSION = VRRPPPP */
+/* __ARMCC_VERSION = VRRPPPP */
   # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
   # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
   # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
 #else
-  /* __ARMCC_VERSION = VRPPPP */
+/* __ARMCC_VERSION = VRPPPP */
   # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
   # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
   # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
@@ -311,7 +311,7 @@

 # define COMPILER_VERSION_MINOR DEC(__clang_minor__)
 # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
 # if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 # endif
@@ -340,7 +340,7 @@

 # define COMPILER_VERSION_MINOR DEC(__clang_minor__)
 # define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
 # if defined(_MSC_VER)
-   /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 #  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
 #  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
 # endif
@@ -377,15 +377,15 @@

 
 #elif defined(_MSC_VER)
 # define COMPILER_ID "MSVC"
-  /* _MSC_VER = VVRR */
+/* _MSC_VER = VVRR */
 # define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
 # define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
 # if defined(_MSC_FULL_VER)
 #  if _MSC_VER >= 1400
-    /* _MSC_FULL_VER = VVRRPPPPP */
+/* _MSC_FULL_VER = VVRRPPPPP */
 #   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
 #  else
-    /* _MSC_FULL_VER = VVRRPPPP */
+/* _MSC_FULL_VER = VVRRPPPP */
 #   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
 #  endif
 # endif
@@ -396,7 +396,7 @@

 #elif defined(_ADI_COMPILER)
 # define COMPILER_ID "ADSP"
 #if defined(__VERSIONNUM__)
-  /* __VERSIONNUM__ = 0xVVRRPPTT */
+/* __VERSIONNUM__ = 0xVVRRPPTT */
 #  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
 #  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
 #  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
@@ -412,15 +412,15 @@

 #  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
 # elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
 #  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
-#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
+#  define COMPILER_VERSION_MINOR DEC((__VER__) -(((__VER__) / 100)*100))
 #  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
 #  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
 # endif
 
 
 /* These compilers are either not known or too old to define an
-  identification macro.  Try to identify the platform and guess that
-  it is the native compiler.  */
+   identification macro.  Try to identify the platform and guess that
+   it is the native compiler.  */
 #elif defined(__hpux) || defined(__hpua)
 # define COMPILER_ID "HP"
 
@@ -564,7 +564,7 @@

    the architecture of the compiler being used.  This is because
    the compilers do not have flags that can change the architecture,
    but rather depend on which compiler is being used
-*/
+ */
 #if defined(_WIN32) && defined(_MSC_VER)
 # if defined(_M_IA64)
 #  define ARCHITECTURE_ID "IA64"
@@ -727,25 +727,25 @@

 
 /* Convert integer to decimal digit literals.  */
 #define DEC(n)                   \
-  ('0' + (((n) / 10000000)%10)), \
-  ('0' + (((n) / 1000000)%10)),  \
-  ('0' + (((n) / 100000)%10)),   \
-  ('0' + (((n) / 10000)%10)),    \
-  ('0' + (((n) / 1000)%10)),     \
-  ('0' + (((n) / 100)%10)),      \
-  ('0' + (((n) / 10)%10)),       \
-  ('0' +  ((n) % 10))
+	('0' + (((n) / 10000000)%10)), \
+	('0' + (((n) / 1000000)%10)),  \
+	('0' + (((n) / 100000)%10)),   \
+	('0' + (((n) / 10000)%10)),    \
+	('0' + (((n) / 1000)%10)),     \
+	('0' + (((n) / 100)%10)),      \
+	('0' + (((n) / 10)%10)),       \
+	('0' +  ((n) % 10))
 
 /* Convert integer to hex digit literals.  */
 #define HEX(n)             \
-  ('0' + ((n)>>28 & 0xF)), \
-  ('0' + ((n)>>24 & 0xF)), \
-  ('0' + ((n)>>20 & 0xF)), \
-  ('0' + ((n)>>16 & 0xF)), \
-  ('0' + ((n)>>12 & 0xF)), \
-  ('0' + ((n)>>8  & 0xF)), \
-  ('0' + ((n)>>4  & 0xF)), \
-  ('0' + ((n)     & 0xF))
+	('0' + ((n)>>28 & 0xF)), \
+	('0' + ((n)>>24 & 0xF)), \
+	('0' + ((n)>>20 & 0xF)), \
+	('0' + ((n)>>16 & 0xF)), \
+	('0' + ((n)>>12 & 0xF)), \
+	('0' + ((n)>>8  & 0xF)), \
+	('0' + ((n)>>4  & 0xF)), \
+	('0' + ((n)     & 0xF))
 
 /* Construct a string literal encoding the version number. */
 #ifdef COMPILER_VERSION
@@ -760,9 +760,9 @@

 # ifdef COMPILER_VERSION_MINOR
   '.', COMPILER_VERSION_MINOR,
 #  ifdef COMPILER_VERSION_PATCH
-   '.', COMPILER_VERSION_PATCH,
+  '.', COMPILER_VERSION_PATCH,
 #   ifdef COMPILER_VERSION_TWEAK
-    '.', COMPILER_VERSION_TWEAK,
+  '.', COMPILER_VERSION_TWEAK,
 #   endif
 #  endif
 # endif
@@ -789,9 +789,9 @@

 # ifdef SIMULATE_VERSION_MINOR
   '.', SIMULATE_VERSION_MINOR,
 #  ifdef SIMULATE_VERSION_PATCH
-   '.', SIMULATE_VERSION_PATCH,
+  '.', SIMULATE_VERSION_PATCH,
 #   ifdef SIMULATE_VERSION_TWEAK
-    '.', SIMULATE_VERSION_TWEAK,
+  '.', SIMULATE_VERSION_TWEAK,
 #   endif
 #  endif
 # endif
@@ -864,31 +864,31 @@

 
 const char* info_language_standard_default = "INFO" ":" "standard_default["
 #if CXX_STD > CXX_STD_23
-  "26"
+                                             "26"
 #elif CXX_STD > CXX_STD_20
-  "23"
+                                             "23"
 #elif CXX_STD > CXX_STD_17
-  "20"
+                                             "20"
 #elif CXX_STD > CXX_STD_14
-  "17"
+                                             "17"
 #elif CXX_STD > CXX_STD_11
-  "14"
+                                             "14"
 #elif CXX_STD >= CXX_STD_11
-  "11"
+                                             "11"
 #else
-  "98"
-#endif
-"]";
+                                             "98"
+#endif
+                                             "]";
 
 const char* info_language_extensions_default = "INFO" ":" "extensions_default["
 #if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
-     defined(__TI_COMPILER_VERSION__)) &&                                     \
-  !defined(__STRICT_ANSI__)
-  "ON"
+					       defined(__TI_COMPILER_VERSION__)) &&                                     \
+					       !defined(__STRICT_ANSI__)
+                                               "ON"
 #else
-  "OFF"
-#endif
-"]";
+                                               "OFF"
+#endif
+                                               "]";
 
 /*--------------------------------------------------------------------------*/
 
tests/mechanical_layer/include/MechanicalLayer.h
====================
--- original

+++ formatted

@@ -24,65 +24,65 @@

  * and saving the configuration to a file.
  */
 {
-  private:
-    unsigned nb_active_agents;        // number of mechanically active agens
-    unsigned nb_active_shapes;        // number of pedestrians (each pedestrian is a collection of active agents)
-    std::vector<double2> vgn;         // velocity of the center of mass (CM) of each pedestrian at t
-    std::vector<double2> vgnp1;       // velocity of the CM of each pedestrian at t+dt
-    std::vector<double2> rgcomp;      // initial positions of all the components of the pedestrians
-    std::vector<double2> rgn;         // positions of the CM of each pedestrian at t
-    std::vector<double2> rgnp1;       // positions of the CM of each pedestrian at t+dt
-    std::vector<double2> delta;       // difference between position of the CM of each component and the CM of their associated pedestrian
-    std::vector<double> thetn;        // orientation wrt x-axis at t
-    std::vector<double> thetnp1;      // orientation wrt x-axis at t+dt
-    std::vector<double> wn;           // angular velocity at t
-    std::vector<double> wnp1;         // angular velocity at t+dt
-    std::vector<double> wdesired;     // desired orientation wrt x-axis (constant during the execution of the crowd_mech file)
-    std::vector<double2> Fp;          // propelling forces v_des/tau_mech
-    std::vector<double2> Forthon;     // orthogonal force (hertz) wrt contact surface at time t
-    std::vector<double2> Ftn;         // tangential force wrt contact surface at time t
-    std::vector<double> taun;         // torque at time t (moment projected on z-axis) expressed at the CM
-    std::vector<std::list<int>> neighbours;
-    std::vector<unsigned> active_shapeIDagent;        // pedestrian id of each shape (goes from 0 to nb_active_shapes - 1)
-    std::vector<unsigned> active_shapeIDshape_crowd;  // shape id of each pedestrian
-    std::vector<double> radius;                       // radius off all shapes of actives agents
-    std::vector<unsigned> size_agents;
-    std::map<unsigned, unsigned> agentIds;
-    std::vector<unsigned> agentActiveIds;
-    std::vector<std::vector<unsigned>> neighbours_shape;
-    std::vector<unsigned> agentIDshape;
-    std::vector<double> masses;
-    std::vector<double> mois;
-    std::vector<double2> damping;
+private:
+  unsigned nb_active_agents;          // number of mechanically active agens
+  unsigned nb_active_shapes;          // number of pedestrians (each pedestrian is a collection of active agents)
+  std::vector<double2> vgn;           // velocity of the center of mass (CM) of each pedestrian at t
+  std::vector<double2> vgnp1;         // velocity of the CM of each pedestrian at t+dt
+  std::vector<double2> rgcomp;        // initial positions of all the components of the pedestrians
+  std::vector<double2> rgn;           // positions of the CM of each pedestrian at t
+  std::vector<double2> rgnp1;         // positions of the CM of each pedestrian at t+dt
+  std::vector<double2> delta;         // difference between position of the CM of each component and the CM of their associated pedestrian
+  std::vector<double> thetn;          // orientation wrt x-axis at t
+  std::vector<double> thetnp1;        // orientation wrt x-axis at t+dt
+  std::vector<double> wn;             // angular velocity at t
+  std::vector<double> wnp1;           // angular velocity at t+dt
+  std::vector<double> wdesired;       // desired orientation wrt x-axis (constant during the execution of the crowd_mech file)
+  std::vector<double2> Fp;            // propelling forces v_des/tau_mech
+  std::vector<double2> Forthon;       // orthogonal force (hertz) wrt contact surface at time t
+  std::vector<double2> Ftn;           // tangential force wrt contact surface at time t
+  std::vector<double> taun;           // torque at time t (moment projected on z-axis) expressed at the CM
+  std::vector<std::list<int> > neighbours;
+  std::vector<unsigned> active_shapeIDagent;          // pedestrian id of each shape (goes from 0 to nb_active_shapes - 1)
+  std::vector<unsigned> active_shapeIDshape_crowd;    // shape id of each pedestrian
+  std::vector<double> radius;                         // radius off all shapes of actives agents
+  std::vector<unsigned> size_agents;
+  std::map<unsigned, unsigned> agentIds;
+  std::vector<unsigned> agentActiveIds;
+  std::vector<std::vector<unsigned> > neighbours_shape;
+  std::vector<unsigned> agentIDshape;
+  std::vector<double> masses;
+  std::vector<double> mois;
+  std::vector<double2> damping;
 
-    /// Tangential relative displacement when in contact
-    std::map<std::pair<unsigned, unsigned>, double2> slip;
-    std::map<std::tuple<unsigned, int, int>, double2> slip_wall;
+  /// Tangential relative displacement when in contact
+  std::map<std::pair<unsigned, unsigned>, double2> slip;
+  std::map<std::tuple<unsigned, int, int>, double2> slip_wall;
 
-    //  For output purposes: the following variables will contain:
-    //    - a copy of slip
-    //    - fortho from shape to shape
-    //    - ft from shape to shape
-    std::map<std::pair<unsigned, unsigned>, std::array<double2,3>> interactionsOutput;
-    std::map<std::tuple<unsigned, int, int>, std::array<double2,3>> interactionsOutputWall;
+  //  For output purposes: the following variables will contain:
+  //    - a copy of slip
+  //    - fortho from shape to shape
+  //    - ft from shape to shape
+  std::map<std::pair<unsigned, unsigned>, std::array<double2,3> > interactionsOutput;
+  std::map<std::tuple<unsigned, int, int>, std::array<double2,3> > interactionsOutputWall;
 
-    std::tuple<double2, double2, double> get_interactions(unsigned cpt_shape, bool AtTimen);
-    void loop();
-    /// AgentInteractions is an input and output file (ie "dynamic") of this process
-    int readInteractionsInputFile(const std::string& interactionsFile);
-    std::pair<bool, bool> existsContacts();   /// Do contacts exist?
-    void generateInteractionsOutputFile(const std::string&, const std::pair<bool, bool> &);
+  std::tuple<double2, double2, double> get_interactions(unsigned cpt_shape, bool AtTimen);
+  void loop();
+  /// AgentInteractions is an input and output file (ie "dynamic") of this process
+  int readInteractionsInputFile(const std::string& interactionsFile);
+  std::pair<bool, bool> existsContacts();     /// Do contacts exist?
+  void generateInteractionsOutputFile(const std::string&, const std::pair<bool, bool> &);
 
-  public:
-    /**
-     * @brief Initializes a CrowdMech object.
-     *
-     * This constructor initializes a CrowdMech object with the given parameters.
-     *
-     * @param agents A std::list of Agent pointers representing the crowd agents.
-     */
-    explicit MechanicalLayer(std::list<Agent*>& agents);
-    ~MechanicalLayer();
+public:
+  /**
+   * @brief Initializes a CrowdMech object.
+   *
+   * This constructor initializes a CrowdMech object with the given parameters.
+   *
+   * @param agents A std::list of Agent pointers representing the crowd agents.
+   */
+  explicit MechanicalLayer(std::list<Agent*>& agents);
+  ~MechanicalLayer();
 };
 
 
tests/mechanical_layer/src/MechanicalLayer.cpp
====================
--- original

+++ formatted

@@ -8,116 +8,118 @@

  * @param mech_active_agents A list of active agents.
  */
 MechanicalLayer::MechanicalLayer(list<Agent*>& mech_active_agents)
-    : nb_active_agents(mech_active_agents.size()), nb_active_shapes(0), vgn(nb_active_agents), vgnp1(nb_active_agents), rgn(nb_active_agents),
-      rgnp1(nb_active_agents), delta(0), thetn(nb_active_agents), thetnp1(nb_active_agents), wn(nb_active_agents), wnp1(nb_active_agents),
-      wdesired(nb_active_agents), Fp(nb_active_agents), Forthon(nb_active_agents), Ftn(nb_active_agents), taun(nb_active_agents),
-      neighbours(nb_active_agents), active_shapeIDagent(0), active_shapeIDshape_crowd(0), radius(0), size_agents(nb_active_agents),
-      neighbours_shape(nb_active_agents), agentIDshape(nb_active_agents + 1, 0), masses(nb_active_agents),
-      mois(nb_active_agents), damping(nb_active_agents)
+  : nb_active_agents(mech_active_agents.size()), nb_active_shapes(0), vgn(nb_active_agents), vgnp1(nb_active_agents), rgn(nb_active_agents),
+  rgnp1(nb_active_agents), delta(0), thetn(nb_active_agents), thetnp1(nb_active_agents), wn(nb_active_agents), wnp1(nb_active_agents),
+  wdesired(nb_active_agents), Fp(nb_active_agents), Forthon(nb_active_agents), Ftn(nb_active_agents), taun(nb_active_agents),
+  neighbours(nb_active_agents), active_shapeIDagent(0), active_shapeIDshape_crowd(0), radius(0), size_agents(nb_active_agents),
+  neighbours_shape(nb_active_agents), agentIDshape(nb_active_agents + 1, 0), masses(nb_active_agents),
+  mois(nb_active_agents), damping(nb_active_agents)
 
 {
-    /*  Preliminary definitions and initialisation  */
-    //  Sort mechanically active agents
-    mech_active_agents.sort([](auto const& a, auto const& b) {return (a->_id) < (b->_id); });
-    unsigned cpt_agent = 0;
-    for (Agent* agent : mech_active_agents)
+  /*  Preliminary definitions and initialisation  */
+  //  Sort mechanically active agents
+  mech_active_agents.sort([](auto const& a, auto const& b) {
+    return (a->_id) < (b->_id);
+  });
+  unsigned cpt_agent = 0;
+  for (Agent* agent : mech_active_agents)
+  {
+    for (unsigned cpt_shape(0); cpt_shape < agent->_nb_shapes; cpt_shape++)
     {
-        for (unsigned cpt_shape(0); cpt_shape < agent->_nb_shapes; cpt_shape++)
-        {
-            active_shapeIDagent.push_back(cpt_agent);
-            active_shapeIDshape_crowd.push_back(agent->_ids_shapes[cpt_shape]);
-        }
-        agentIds[agent->_id] = cpt_agent;
-        agentActiveIds.push_back(agent->_id);
-        vector<double2> delta_gtos_agent = agent->get_delta_gtos();
-        delta.insert(delta.end(), (delta_gtos_agent).begin(), (delta_gtos_agent).end());
-        radius.insert(radius.end(), (agent->_radius_shapes).begin(), (agent->_radius_shapes).end());
-        size_agents[cpt_agent] = agent->_nb_shapes;
-        nb_active_shapes += agent->_nb_shapes;
-        rgn[cpt_agent] = double2(agent->_x, agent->_y);
-        thetn[cpt_agent] = agent->_theta;
-        vgn[cpt_agent] = double2(agent->_vx, agent->_vy);
-        wn[cpt_agent] = agent->_w;
-        masses[cpt_agent] = agent->_mass;
-        mois[cpt_agent] = agent->_moi;
-        damping[cpt_agent] = agentProperties[agent->_id];
-
-        rgnp1[cpt_agent] = double2(agent->_x, agent->_y);
-        thetnp1[cpt_agent] = agent->_theta;
-        vgnp1[cpt_agent] = double2(agent->_vx, agent->_vy);
-        wnp1[cpt_agent] = agent->_w;
-        const double inverseTauMechTranslation   = agentProperties[agent->_id].first;
-        //  The "F" here have the dimension of an acceleration
-        Fp[cpt_agent] = inverseTauMechTranslation * agent->_v_des;  //  We recompute Fp from v_des...
-        Forthon[cpt_agent] = double2(0., 0.);
-        Ftn[cpt_agent] = double2(0., 0.);
-        taun[cpt_agent] = 0.;
-        wdesired[cpt_agent] = agent->_w_des;
-
-        cpt_agent++;
-    }
-
-    // Get the correspondence between agent and shapes  (ie the edges)
-    unsigned length(0);
-    for (size_t a = 0; a < nb_active_agents; ++a)
+      active_shapeIDagent.push_back(cpt_agent);
+      active_shapeIDshape_crowd.push_back(agent->_ids_shapes[cpt_shape]);
+    }
+    agentIds[agent->_id] = cpt_agent;
+    agentActiveIds.push_back(agent->_id);
+    vector<double2> delta_gtos_agent = agent->get_delta_gtos();
+    delta.insert(delta.end(), (delta_gtos_agent).begin(), (delta_gtos_agent).end());
+    radius.insert(radius.end(), (agent->_radius_shapes).begin(), (agent->_radius_shapes).end());
+    size_agents[cpt_agent] = agent->_nb_shapes;
+    nb_active_shapes += agent->_nb_shapes;
+    rgn[cpt_agent] = double2(agent->_x, agent->_y);
+    thetn[cpt_agent] = agent->_theta;
+    vgn[cpt_agent] = double2(agent->_vx, agent->_vy);
+    wn[cpt_agent] = agent->_w;
+    masses[cpt_agent] = agent->_mass;
+    mois[cpt_agent] = agent->_moi;
+    damping[cpt_agent] = agentProperties[agent->_id];
+
+    rgnp1[cpt_agent] = double2(agent->_x, agent->_y);
+    thetnp1[cpt_agent] = agent->_theta;
+    vgnp1[cpt_agent] = double2(agent->_vx, agent->_vy);
+    wnp1[cpt_agent] = agent->_w;
+    const double inverseTauMechTranslation   = agentProperties[agent->_id].first;
+    //  The "F" here have the dimension of an acceleration
+    Fp[cpt_agent] = inverseTauMechTranslation * agent->_v_des;      //  We recompute Fp from v_des...
+    Forthon[cpt_agent] = double2(0., 0.);
+    Ftn[cpt_agent] = double2(0., 0.);
+    taun[cpt_agent] = 0.;
+    wdesired[cpt_agent] = agent->_w_des;
+
+    cpt_agent++;
+  }
+
+  // Get the correspondence between agent and shapes  (ie the edges)
+  unsigned length(0);
+  for (size_t a = 0; a < nb_active_agents; ++a)
+  {
+    length += size_agents[a];
+    agentIDshape[a + 1] = length;
+  }
+
+  // Get neighbouring shapes id of each agent
+  cpt_agent = 0;
+  for (const Agent* agent : mech_active_agents)
+  {
+    unsigned cpt_agent2 = 0;
+    for (const Agent* agent2 : mech_active_agents)
     {
-        length += size_agents[a];
-        agentIDshape[a + 1] = length;
-    }
-
-    // Get neighbouring shapes id of each agent
-    cpt_agent = 0;
-    for (const Agent* agent : mech_active_agents)
-    {
-        unsigned cpt_agent2 = 0;
-        for (const Agent* agent2 : mech_active_agents)
-        {
-            if (cpt_agent2 > cpt_agent)
-            {
-                //	include as neighbour if within 5*(r1+r2) where r1 and r2 are the size of
-                //	the body (the radius of the smallest circle containing all the shapes)
-                if (const double distance = !(rgn[cpt_agent] - rgn[cpt_agent2]);
-                    distance < 5.0 * (agent->_radius + agent2->_radius))
-                {
-                    for (unsigned cpt_shape(agentIDshape[cpt_agent2]); cpt_shape < agentIDshape[cpt_agent2] + size_agents[cpt_agent2]; ++cpt_shape)
-                        neighbours_shape[cpt_agent].push_back(cpt_shape);
-                    for (unsigned cpt_shape(agentIDshape[cpt_agent]); cpt_shape < agentIDshape[cpt_agent] + size_agents[cpt_agent]; ++cpt_shape)
-                        neighbours_shape[cpt_agent2].push_back(cpt_shape);
-                }
-            }
-            cpt_agent2++;
-        }
-        cpt_agent++;
-    }
-
-    /*  Check if an Interactions File already exists    */
-    const string interactionsFile = pathDynamic + "AgentInteractions.xml";
-    struct stat buffer{};
-    if (stat(interactionsFile.c_str(), &buffer) != -1)
-        readInteractionsInputFile(interactionsFile);
-
-
-    /*  MECHANICAL Loop */
-    for (unsigned t = 0; t < static_cast<unsigned>(dt / dt_mech); t++)
-    {
-        loop();
-    }
-
-    // Update the positions and velocities of mechanically active agents
-    cpt_agent = 0;
-    for (Agent* agent : mech_active_agents)
-    {
-        agent->_x = rgn[cpt_agent].first;
-        agent->_y = rgn[cpt_agent].second;
-        agent->_vx = vgn[cpt_agent].first;
-        agent->_vy = vgn[cpt_agent].second;
-        agent->_theta = thetn[cpt_agent];
-        agent->_w = wn[cpt_agent];
-        cpt_agent++;
-    }
-
-    //  Output the interactions file
-    generateInteractionsOutputFile(interactionsFile, existsContacts());
+      if (cpt_agent2 > cpt_agent)
+      {
+	//	include as neighbour if within 5*(r1+r2) where r1 and r2 are the size of
+	//	the body (the radius of the smallest circle containing all the shapes)
+	if (const double distance = !(rgn[cpt_agent] - rgn[cpt_agent2]);
+	    distance < 5.0 * (agent->_radius + agent2->_radius))
+	{
+	  for (unsigned cpt_shape(agentIDshape[cpt_agent2]); cpt_shape < agentIDshape[cpt_agent2] + size_agents[cpt_agent2]; ++cpt_shape)
+	    neighbours_shape[cpt_agent].push_back(cpt_shape);
+	  for (unsigned cpt_shape(agentIDshape[cpt_agent]); cpt_shape < agentIDshape[cpt_agent] + size_agents[cpt_agent]; ++cpt_shape)
+	    neighbours_shape[cpt_agent2].push_back(cpt_shape);
+	}
+      }
+      cpt_agent2++;
+    }
+    cpt_agent++;
+  }
+
+  /*  Check if an Interactions File already exists    */
+  const string interactionsFile = pathDynamic + "AgentInteractions.xml";
+  struct stat buffer {};
+  if (stat(interactionsFile.c_str(), &buffer) != -1)
+    readInteractionsInputFile(interactionsFile);
+
+
+  /*  MECHANICAL Loop */
+  for (unsigned t = 0; t < static_cast<unsigned>(dt / dt_mech); t++)
+  {
+    loop();
+  }
+
+  // Update the positions and velocities of mechanically active agents
+  cpt_agent = 0;
+  for (Agent* agent : mech_active_agents)
+  {
+    agent->_x = rgn[cpt_agent].first;
+    agent->_y = rgn[cpt_agent].second;
+    agent->_vx = vgn[cpt_agent].first;
+    agent->_vy = vgn[cpt_agent].second;
+    agent->_theta = thetn[cpt_agent];
+    agent->_w = wn[cpt_agent];
+    cpt_agent++;
+  }
+
+  //  Output the interactions file
+  generateInteractionsOutputFile(interactionsFile, existsContacts());
 }
 
 /**
@@ -137,87 +139,87 @@

  */
 int MechanicalLayer::readInteractionsInputFile(const std::string& interactionsFile)
 {
-    tinyxml2::XMLDocument document;
-    document.LoadFile(interactionsFile.data());
-    if (document.ErrorID() != 0) {
-        cerr << "Error: Could not load or parse XML file " << interactionsFile << endl;
-        return EXIT_FAILURE;
-    }
-
-    //  Read the Interactions block
-    const tinyxml2::XMLElement* interactionsElement = document.FirstChildElement("Interactions");
-    if (!interactionsElement) {
-        cerr << "Error: interactions must be embedded in \"Interactions\" tag!" << endl;
-        return EXIT_FAILURE;
-    }
-
-    const tinyxml2::XMLElement* agent1Element = interactionsElement->FirstChildElement("Agent");
-    if (!agent1Element) {
-        cerr << "Error: no Agent tag present in " << interactionsFile << endl;
-        return EXIT_FAILURE;
-    }
-    while (agent1Element) {
-        const char* agent1ExternId = nullptr;
-        if (agent1Element->QueryStringAttribute("Id", &agent1ExternId) != tinyxml2::XML_SUCCESS) {
-            cerr << "Error: Agents must have an Id in file " << interactionsFile << endl;
-            return EXIT_FAILURE;
-        }
-        //  Interactions with other agents
-        const tinyxml2::XMLElement* agent2Element = interactionsElement->FirstChildElement("Agent");
-        if (!agent2Element) {
-            cerr << "Error: no Agent neighbour present in " << interactionsFile << endl;
-            return EXIT_FAILURE;
-        }
-        while (agent2Element) {
-            const char* agent2ExternId = nullptr;
-            if (agent2Element->QueryStringAttribute("Id", &agent2ExternId) != tinyxml2::XML_SUCCESS) {
-                cerr << "Error: Agents must have an Id in file " << interactionsFile << endl;
-                return EXIT_FAILURE;
-            }
-            //  Read interactions
-            const tinyxml2::XMLElement* interactionElement = agent2Element->FirstChildElement("Interaction");
-            while (interactionElement) {
-                const char* shape1ExternId = nullptr;
-                const char* shape2ExternId = nullptr;
-                if (interactionElement->QueryStringAttribute("ParentShape", &shape1ExternId) != tinyxml2::XML_SUCCESS) {
-                    cerr << "Error: no shape identifier in interaction between agents in " << interactionsFile << endl;
-                    return EXIT_FAILURE;
-                }
-                if (interactionElement->QueryStringAttribute("ChildShape", &shape2ExternId) != tinyxml2::XML_SUCCESS) {
-                    cerr << "Error: no shape identifier in interaction between agents in " << interactionsFile << endl;
-                    return EXIT_FAILURE;
-                }
-                const char* buffer = nullptr;
-                interactionElement->QueryStringAttribute("TangentialRelativeDisplacement", &buffer);
-                auto [rcSlip, inputSlip] = parse2DComponents(buffer);
-                uint32_t cpt_shape          = shapeMap[{agent1ExternId, shape1ExternId}];
-                uint32_t cpt_shape_neigh    = shapeMap[{agent2ExternId, shape2ExternId}];
-                slip[{cpt_shape, cpt_shape_neigh}] = inputSlip;
-                slip[{cpt_shape_neigh, cpt_shape}] = -1 * inputSlip;
-            }
-
-            agent2Element = agent2Element->NextSiblingElement("Agent");
-        }
-        //  Interactions with walls
-        const tinyxml2::XMLElement* wallElement = agent1Element->FirstChildElement("Wall");
-        while (wallElement) {
-          	const char* shapeExternId = nullptr;
-            wallElement->QueryStringAttribute("ShapeId", &shapeExternId);
-            int obstacleId, wallId;
-            wallElement->QueryIntAttribute("ObstacleId", &obstacleId);
-            wallElement->QueryIntAttribute("WallId", &wallId);
-            const char* buffer = nullptr;
-            wallElement->QueryStringAttribute("TangentialRelativeDisplacement", &buffer);
-            auto [rcSlipWall, inputSlipWall] = parse2DComponents(buffer);
-            uint32_t cpt_shape = shapeMap[{agent1ExternId, shapeExternId}];
-            slip_wall[{cpt_shape, obstacleId, wallId}] = inputSlipWall;
-
-            wallElement = wallElement->NextSiblingElement("Wall");
-        }
-        agent1Element = agent1Element->NextSiblingElement("Agent");
-    }
-
-    return EXIT_SUCCESS;
+  tinyxml2::XMLDocument document;
+  document.LoadFile(interactionsFile.data());
+  if (document.ErrorID() != 0) {
+    cerr << "Error: Could not load or parse XML file " << interactionsFile << endl;
+    return EXIT_FAILURE;
+  }
+
+  //  Read the Interactions block
+  const tinyxml2::XMLElement* interactionsElement = document.FirstChildElement("Interactions");
+  if (!interactionsElement) {
+    cerr << "Error: interactions must be embedded in \"Interactions\" tag!" << endl;
+    return EXIT_FAILURE;
+  }
+
+  const tinyxml2::XMLElement* agent1Element = interactionsElement->FirstChildElement("Agent");
+  if (!agent1Element) {
+    cerr << "Error: no Agent tag present in " << interactionsFile << endl;
+    return EXIT_FAILURE;
+  }
+  while (agent1Element) {
+    const char* agent1ExternId = nullptr;
+    if (agent1Element->QueryStringAttribute("Id", &agent1ExternId) != tinyxml2::XML_SUCCESS) {
+      cerr << "Error: Agents must have an Id in file " << interactionsFile << endl;
+      return EXIT_FAILURE;
+    }
+    //  Interactions with other agents
+    const tinyxml2::XMLElement* agent2Element = interactionsElement->FirstChildElement("Agent");
+    if (!agent2Element) {
+      cerr << "Error: no Agent neighbour present in " << interactionsFile << endl;
+      return EXIT_FAILURE;
+    }
+    while (agent2Element) {
+      const char* agent2ExternId = nullptr;
+      if (agent2Element->QueryStringAttribute("Id", &agent2ExternId) != tinyxml2::XML_SUCCESS) {
+	cerr << "Error: Agents must have an Id in file " << interactionsFile << endl;
+	return EXIT_FAILURE;
+      }
+      //  Read interactions
+      const tinyxml2::XMLElement* interactionElement = agent2Element->FirstChildElement("Interaction");
+      while (interactionElement) {
+	const char* shape1ExternId = nullptr;
+	const char* shape2ExternId = nullptr;
+	if (interactionElement->QueryStringAttribute("ParentShape", &shape1ExternId) != tinyxml2::XML_SUCCESS) {
+	  cerr << "Error: no shape identifier in interaction between agents in " << interactionsFile << endl;
+	  return EXIT_FAILURE;
+	}
+	if (interactionElement->QueryStringAttribute("ChildShape", &shape2ExternId) != tinyxml2::XML_SUCCESS) {
+	  cerr << "Error: no shape identifier in interaction between agents in " << interactionsFile << endl;
+	  return EXIT_FAILURE;
+	}
+	const char* buffer = nullptr;
+	interactionElement->QueryStringAttribute("TangentialRelativeDisplacement", &buffer);
+	auto [rcSlip, inputSlip] = parse2DComponents(buffer);
+	uint32_t cpt_shape          = shapeMap[{agent1ExternId, shape1ExternId}];
+	uint32_t cpt_shape_neigh    = shapeMap[{agent2ExternId, shape2ExternId}];
+	slip[{cpt_shape, cpt_shape_neigh}] = inputSlip;
+	slip[{cpt_shape_neigh, cpt_shape}] = -1 * inputSlip;
+      }
+
+      agent2Element = agent2Element->NextSiblingElement("Agent");
+    }
+    //  Interactions with walls
+    const tinyxml2::XMLElement* wallElement = agent1Element->FirstChildElement("Wall");
+    while (wallElement) {
+      const char* shapeExternId = nullptr;
+      wallElement->QueryStringAttribute("ShapeId", &shapeExternId);
+      int obstacleId, wallId;
+      wallElement->QueryIntAttribute("ObstacleId", &obstacleId);
+      wallElement->QueryIntAttribute("WallId", &wallId);
+      const char* buffer = nullptr;
+      wallElement->QueryStringAttribute("TangentialRelativeDisplacement", &buffer);
+      auto [rcSlipWall, inputSlipWall] = parse2DComponents(buffer);
+      uint32_t cpt_shape = shapeMap[{agent1ExternId, shapeExternId}];
+      slip_wall[{cpt_shape, obstacleId, wallId}] = inputSlipWall;
+
+      wallElement = wallElement->NextSiblingElement("Wall");
+    }
+    agent1Element = agent1Element->NextSiblingElement("Agent");
+  }
+
+  return EXIT_SUCCESS;
 }
 
 
@@ -231,201 +233,201 @@

 tuple<double2, double2, double> MechanicalLayer::get_interactions(unsigned cpt_shape, bool AtTimen)
 {   // return    tangential force     + normal / m     , moment / I    if AtTimen=true
     // otherwise force tangentielle_np1 + normale_np1 / m
-    unsigned cpt_agent = active_shapeIDagent[cpt_shape];
-    double UnmZetadt    = 1.0 - dt_mech * damping[cpt_agent].first;
-    double2 delta_GtoS = AtTimen ? delta[cpt_shape] : delta[cpt_shape] + ((thetnp1[cpt_agent] - thetn[cpt_agent]) ^ delta[cpt_shape]);
-    double2 posagent = AtTimen ? rgn[cpt_agent] : rgnp1[cpt_agent];   // center of mass of the agent
-    double2 posshape = posagent + delta_GtoS;                         // center of mass of the shape
-    double angvel =
-        AtTimen ? wn[cpt_agent]
+  unsigned cpt_agent = active_shapeIDagent[cpt_shape];
+  double UnmZetadt    = 1.0 - dt_mech * damping[cpt_agent].first;
+  double2 delta_GtoS = AtTimen ? delta[cpt_shape] : delta[cpt_shape] + ((thetnp1[cpt_agent] - thetn[cpt_agent]) ^ delta[cpt_shape]);
+  double2 posagent = AtTimen ? rgn[cpt_agent] : rgnp1[cpt_agent];     // center of mass of the agent
+  double2 posshape = posagent + delta_GtoS;                           // center of mass of the shape
+  double angvel =
+    AtTimen ? wn[cpt_agent]
                 : wn[cpt_agent] + dt_mech * taun[cpt_agent];   // angular velocity of the shape at time n and trial angular velocity for the time n+1
-    double2 velagent =
-        AtTimen ? vgn[cpt_agent]
+  double2 velagent =
+    AtTimen ? vgn[cpt_agent]
                 : UnmZetadt * vgn[cpt_agent] + dt_mech * (Fp[cpt_agent] + Forthon[cpt_agent] +
                                                           Ftn[cpt_agent]);   // velocity of the shape   // v_shape(t+dt) = v_CM(t+dt) transport
-    double2 velshape = velagent + (angvel ^ delta_GtoS);
-
-    double torq = 0.;
-    double2 fortho(0., 0.);
-    double2 ft(0., 0.);
-
-    // Hertzian interactions between agents
-    for (unsigned cpt_shape_neigh : neighbours_shape[cpt_agent])
-    {
-        unsigned cpt_neigh = active_shapeIDagent[cpt_shape_neigh];
-        double2 delta_GtoS_neigh =
-            AtTimen ? delta[cpt_shape_neigh] : delta[cpt_shape_neigh] + ((thetnp1[cpt_neigh] - thetn[cpt_neigh]) ^ delta[cpt_shape_neigh]);
-        double2 posagent_neigh = AtTimen ? rgn[cpt_neigh] : rgnp1[cpt_neigh];
-        double2 posshape_neigh = posagent_neigh + delta_GtoS_neigh;
-        double angvel_neigh = AtTimen ? wn[cpt_neigh] : wn[cpt_neigh] + dt_mech * taun[cpt_neigh];
-        double2 velagent_neigh =
-            AtTimen ? vgn[cpt_neigh]
+  double2 velshape = velagent + (angvel ^ delta_GtoS);
+
+  double torq = 0.;
+  double2 fortho(0., 0.);
+  double2 ft(0., 0.);
+
+  // Hertzian interactions between agents
+  for (unsigned cpt_shape_neigh : neighbours_shape[cpt_agent])
+  {
+    unsigned cpt_neigh = active_shapeIDagent[cpt_shape_neigh];
+    double2 delta_GtoS_neigh =
+      AtTimen ? delta[cpt_shape_neigh] : delta[cpt_shape_neigh] + ((thetnp1[cpt_neigh] - thetn[cpt_neigh]) ^ delta[cpt_shape_neigh]);
+    double2 posagent_neigh = AtTimen ? rgn[cpt_neigh] : rgnp1[cpt_neigh];
+    double2 posshape_neigh = posagent_neigh + delta_GtoS_neigh;
+    double angvel_neigh = AtTimen ? wn[cpt_neigh] : wn[cpt_neigh] + dt_mech * taun[cpt_neigh];
+    double2 velagent_neigh =
+      AtTimen ? vgn[cpt_neigh]
                     : UnmZetadt * vgn[cpt_neigh] + dt_mech * (Fp[cpt_neigh] + Forthon[cpt_neigh] +
                                                               Ftn[cpt_neigh]);   // velocity of the CM of the neighbouring pedestrian neigh
-        double2 velshape_neigh = velagent_neigh + (angvel_neigh ^ delta_GtoS_neigh);
-
-        double2 r_ij = posshape - posshape_neigh;   // points towards i // i : current_shape // j : neigh_shape
-        double distance(!r_ij);
-        double2 n_ij;
-        if (distance == 0.)
-            n_ij = double2(0., 0.);
-        else
-            n_ij = (1. / distance) * r_ij;
-        double h(radius[cpt_shape] + radius[cpt_shape_neigh] - distance);   // indentation
-        double2 dcGshape = -(radius[cpt_shape] - h / 2.) * n_ij;            // from the center of mass G of shape towards c (the contact point)
-        double2 dcGshapeneigh = +(radius[cpt_shape_neigh] - h / 2.) * n_ij;
-        double2 dcG = delta[cpt_shape] + dcGshape;   // vector distance from CM of the agent to c = vector distance from CM agent
+    double2 velshape_neigh = velagent_neigh + (angvel_neigh ^ delta_GtoS_neigh);
+
+    double2 r_ij = posshape - posshape_neigh;       // points towards i // i : current_shape // j : neigh_shape
+    double distance(!r_ij);
+    double2 n_ij;
+    if (distance == 0.)
+      n_ij = double2(0., 0.);
+    else
+      n_ij = (1. / distance) * r_ij;
+    double h(radius[cpt_shape] + radius[cpt_shape_neigh] - distance);       // indentation
+    double2 dcGshape = -(radius[cpt_shape] - h / 2.) * n_ij;                // from the center of mass G of shape towards c (the contact point)
+    double2 dcGshapeneigh = +(radius[cpt_shape_neigh] - h / 2.) * n_ij;
+    double2 dcG = delta[cpt_shape] + dcGshape;       // vector distance from CM of the agent to c = vector distance from CM agent
                                                      // to CM shape + distance from CM shape to c
 
-        if (h > 0.)   // if the two shapes are in contact
-        {
-            double2 v_ci = velshape + (angvel ^ dcGshape);                    // velocity of i at the contact point
-            double2 v_cj = velshape_neigh + (angvel_neigh ^ dcGshapeneigh);   // velocity of j at the contact point
-            double2 vij = v_ci - v_cj;
-            double2 vortho_ij = (vij % n_ij) * n_ij;
-            double2 vt_ij = vij - vortho_ij;
-            double norm_vt_ij = !vt_ij;
-
-            // if the map does not contain this pair ie the slip is not initialized then we initialize it otherwise we increment it
-            if (!slip.contains({cpt_shape, cpt_shape_neigh}))
-                slip[{cpt_shape, cpt_shape_neigh}] = double2(0., 0.);
-            else
-                slip[{cpt_shape, cpt_shape_neigh}] = slip[{cpt_shape, cpt_shape_neigh}] + dt_mech * vt_ij;
-            //  We will only put the N(N-1)/2 pairs, ie cpt_shape_neigh>cpt_shape in interactionsOutput
-            if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
-                interactionsOutput[{cpt_shape, cpt_shape_neigh}][SLIP]
-                    = slip[{cpt_shape, cpt_shape_neigh}];
-
-            double2 delta_tij = slip[{cpt_shape, cpt_shape_neigh}];   // vector of tangential displacement
-            double norm_delta_tij = !delta_tij;
-
-            double2 t_vij;
-            if (norm_vt_ij > 0)
-                t_vij = (1. / norm_vt_ij) * vt_ij;
-            else if (norm_delta_tij > 0)
-                t_vij = (1. / norm_delta_tij) * delta_tij;
-            else
-                t_vij = double2(0., 0.);
-
-            uint32_t shapeMaterialId 			= shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
-            uint32_t shapeNeighbourMaterialId 	= shapesMaterial[active_shapeIDshape_crowd[cpt_shape_neigh]];
-            /*  Normal interactions */
-            double k_n 		= binaryProperties[STIFFNESS_NORMAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double Gamma_n 	= binaryProperties[DAMPING_NORMAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double2 fnij_elastic = k_n * h * n_ij;
-            double2 fnij_viscous = -Gamma_n * vortho_ij;
-            double2 fnij = fnij_elastic + fnij_viscous;
-            fortho = fortho + fnij;
-            if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
-                interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_ORTHO] = fnij;
-
-            /*  Tangential interactions */
-            double k_t 		= binaryProperties[STIFFNESS_TANGENTIAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double Gamma_t 	= binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId][shapeNeighbourMaterialId];
-            double2 ftij_spring  = -k_t * norm_delta_tij * t_vij;
-            double2 ftij_viscous = -Gamma_t * vt_ij;
-            double2 ftij_static  = ftij_spring + ftij_viscous;
-            double mu_dyn = binaryProperties[FRICTION_SLIDING][shapeMaterialId][shapeNeighbourMaterialId];
-            double2 ftij_dynamic = -mu_dyn * !fnij * t_vij;
-            double2 ftij = -1. * min(!ftij_static, !ftij_dynamic) * t_vij;
-            ft = ft + ftij;
-            if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
-                interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_TAN] = ftij;
-
-            /*	Torque	*/
-            double torqnij = (1. ^ dcG) % fnij;
-            double torqtij = (1. ^ dcG) % ftij;
-            double torqij = torqnij + torqtij;
-            torq = torq + torqij;   // cf circular permutation of the cross product // two forces induce rotation the orthogonal
+    if (h > 0.)       // if the two shapes are in contact
+    {
+      double2 v_ci = velshape + (angvel ^ dcGshape);                          // velocity of i at the contact point
+      double2 v_cj = velshape_neigh + (angvel_neigh ^ dcGshapeneigh);         // velocity of j at the contact point
+      double2 vij = v_ci - v_cj;
+      double2 vortho_ij = (vij % n_ij) * n_ij;
+      double2 vt_ij = vij - vortho_ij;
+      double norm_vt_ij = !vt_ij;
+
+      // if the map does not contain this pair ie the slip is not initialized then we initialize it otherwise we increment it
+      if (!slip.contains({cpt_shape, cpt_shape_neigh}))
+	slip[{cpt_shape, cpt_shape_neigh}] = double2(0., 0.);
+      else
+	slip[{cpt_shape, cpt_shape_neigh}] = slip[{cpt_shape, cpt_shape_neigh}] + dt_mech * vt_ij;
+      //  We will only put the N(N-1)/2 pairs, ie cpt_shape_neigh>cpt_shape in interactionsOutput
+      if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
+	interactionsOutput[{cpt_shape, cpt_shape_neigh}][SLIP]
+	  = slip[{cpt_shape, cpt_shape_neigh}];
+
+      double2 delta_tij = slip[{cpt_shape, cpt_shape_neigh}];         // vector of tangential displacement
+      double norm_delta_tij = !delta_tij;
+
+      double2 t_vij;
+      if (norm_vt_ij > 0)
+	t_vij = (1. / norm_vt_ij) * vt_ij;
+      else if (norm_delta_tij > 0)
+	t_vij = (1. / norm_delta_tij) * delta_tij;
+      else
+	t_vij = double2(0., 0.);
+
+      uint32_t shapeMaterialId                    = shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
+      uint32_t shapeNeighbourMaterialId   = shapesMaterial[active_shapeIDshape_crowd[cpt_shape_neigh]];
+      /*  Normal interactions */
+      double k_n          = binaryProperties[STIFFNESS_NORMAL][shapeMaterialId][shapeNeighbourMaterialId];
+      double Gamma_n      = binaryProperties[DAMPING_NORMAL][shapeMaterialId][shapeNeighbourMaterialId];
+      double2 fnij_elastic = k_n * h * n_ij;
+      double2 fnij_viscous = -Gamma_n * vortho_ij;
+      double2 fnij = fnij_elastic + fnij_viscous;
+      fortho = fortho + fnij;
+      if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
+	interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_ORTHO] = fnij;
+
+      /*  Tangential interactions */
+      double k_t          = binaryProperties[STIFFNESS_TANGENTIAL][shapeMaterialId][shapeNeighbourMaterialId];
+      double Gamma_t      = binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId][shapeNeighbourMaterialId];
+      double2 ftij_spring  = -k_t * norm_delta_tij * t_vij;
+      double2 ftij_viscous = -Gamma_t * vt_ij;
+      double2 ftij_static  = ftij_spring + ftij_viscous;
+      double mu_dyn = binaryProperties[FRICTION_SLIDING][shapeMaterialId][shapeNeighbourMaterialId];
+      double2 ftij_dynamic = -mu_dyn * !fnij * t_vij;
+      double2 ftij = -1. * min(!ftij_static, !ftij_dynamic) * t_vij;
+      ft = ft + ftij;
+      if (!interactionsOutput.contains({cpt_shape_neigh, cpt_shape}))
+	interactionsOutput[{cpt_shape, cpt_shape_neigh}][FORCE_TAN] = ftij;
+
+      /*	Torque	*/
+      double torqnij = (1. ^ dcG) % fnij;
+      double torqtij = (1. ^ dcG) % ftij;
+      double torqij = torqnij + torqtij;
+      torq = torq + torqij;         // cf circular permutation of the cross product // two forces induce rotation the orthogonal
                                     // force and the tangential force (to the contact surface)
 
-        }
-    }
-
-    // Interactions with walls
-    int iobs = 0;
-    for (vector<double2> const& wall_it : listObstacles)   // iterates over obstacles
+    }
+  }
+
+  // Interactions with walls
+  int iobs = 0;
+  for (vector<double2> const& wall_it : listObstacles)     // iterates over obstacles
+  {
+    int iwall = 0;
+    for (auto it = wall_it.begin(); next(it) != wall_it.end(); ++it)
     {
-        int iwall = 0;
-        for (auto it = wall_it.begin(); next(it) != wall_it.end(); ++it)
-        {
-            auto [dist, closestPoint] = get_distance_to_wall_and_closest_point(*it, *(next(it)), posshape);
-            // first => distance between the CM of the shape and the closest point on the wall , second => closest point on the
-            // wall
-
-            double2 r_iw = posshape - closestPoint;   // vector starting on the wall and going towards the shape
-            double distance = dist;
-            double2 n_iw;
-            if (distance == 0.)
-                n_iw = double2(0., 0.);
-            else
-                n_iw = (1. / distance) * r_iw;
-            double h = radius[cpt_shape] - distance;
-            double2 dcGshape = -(radius[cpt_shape] - h / 2.) * n_iw;
-            double2 dcG = delta[cpt_shape] + dcGshape;   // distance from the CM G to the contact point c
-            if (h > 0.)
-            {
-                double2 v_ci = velshape + (angvel ^ dcGshape);
-                double2 viw = v_ci - double2(0., 0.);   // because v_cw = double2(0.,0.)
-                double2 vortho_iw = (viw % n_iw) * n_iw;
-                double2 vt_iw = viw - vortho_iw;
-                double norm_vt_iw = !vt_iw;
-
-                // if the map does not contain this pair ie the slip is not initialized then we initialize it otherwise we
-                // increment it
-                if (!slip_wall.contains({cpt_shape, iobs, iwall}))
-                    slip_wall[{cpt_shape, iobs, iwall}] = double2(0., 0.);
-                else
-                    slip_wall[{cpt_shape, iobs, iwall}] = slip_wall[{cpt_shape, iobs, iwall}] + dt_mech * vt_iw;
-                interactionsOutputWall[{cpt_shape, iobs, iwall}][SLIP]
-                    = slip_wall[{cpt_shape, iobs, iwall}];
-
-                double2 delta_tiw = slip_wall[{cpt_shape, iobs, iwall}];
-                double norm_delta_tiw = !delta_tiw;
-
-                double2 t_viw;
-                if (norm_vt_iw > 0)
-                    t_viw = (1. / norm_vt_iw) * vt_iw;
-                else if (norm_delta_tiw > 0)
-                    t_viw = (1. / norm_delta_tiw) * delta_tiw;
-                else
-                    t_viw = double2(0., 0.);
-
-                uint32_t shapeMaterialId    = shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
-                uint32_t obstacleMaterialId = obstaclesMaterial[iobs];
-                /*  Normal interactions */
-                double k_n_wall 	= binaryProperties[STIFFNESS_NORMAL][shapeMaterialId][obstacleMaterialId];
-                double Gamma_n_wall = binaryProperties[DAMPING_NORMAL][shapeMaterialId][obstacleMaterialId];
-                double2 fniw_elastic = k_n_wall * h * n_iw;
-                double2 fniw_viscous = -Gamma_n_wall * vortho_iw;
-                double2 fniw = fniw_elastic + fniw_viscous;
-                fortho = fortho + fniw;
-                interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_ORTHO] = fniw;
-
-                /*  Tangential interactions */
-                double k_t_wall 	= binaryProperties[STIFFNESS_TANGENTIAL][shapeMaterialId][obstacleMaterialId];
-                double Gamma_t_wall = binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId][obstacleMaterialId];
-                double2 ftiw_spring = -k_t_wall * norm_delta_tiw * t_viw;
-                double2 ftiw_viscous = -Gamma_t_wall * vt_iw;
-                double2 ftiw_static = ftiw_spring + ftiw_viscous;
-                double mu_dyn_wall = binaryProperties[FRICTION_SLIDING][shapeMaterialId][obstacleMaterialId];
-                double2 ftiw_dynamic = -mu_dyn_wall * !fniw * t_viw;
-                double2 ftiw = -1. * min(!ftiw_static, !ftiw_dynamic) * t_viw;
-                ft = ft + ftiw;
-                interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_TAN] = ftiw;
-
-                /*	Torque	*/
-                double torqniw = (1. ^ dcG) % fniw;
-                double torqtiw = (1. ^ dcG) % ftiw;
-                double torqiw = torqniw + torqtiw;
-                torq = torq + torqiw;
-
-            }
-            iwall++;
-        }
-        iobs++;
-    }
-    return {fortho, ft, torq};
+      auto [dist, closestPoint] = get_distance_to_wall_and_closest_point(*it, *(next(it)), posshape);
+      // first => distance between the CM of the shape and the closest point on the wall , second => closest point on the
+      // wall
+
+      double2 r_iw = posshape - closestPoint;         // vector starting on the wall and going towards the shape
+      double distance = dist;
+      double2 n_iw;
+      if (distance == 0.)
+	n_iw = double2(0., 0.);
+      else
+	n_iw = (1. / distance) * r_iw;
+      double h = radius[cpt_shape] - distance;
+      double2 dcGshape = -(radius[cpt_shape] - h / 2.) * n_iw;
+      double2 dcG = delta[cpt_shape] + dcGshape;         // distance from the CM G to the contact point c
+      if (h > 0.)
+      {
+	double2 v_ci = velshape + (angvel ^ dcGshape);
+	double2 viw = v_ci - double2(0., 0.);           // because v_cw = double2(0.,0.)
+	double2 vortho_iw = (viw % n_iw) * n_iw;
+	double2 vt_iw = viw - vortho_iw;
+	double norm_vt_iw = !vt_iw;
+
+	// if the map does not contain this pair ie the slip is not initialized then we initialize it otherwise we
+	// increment it
+	if (!slip_wall.contains({cpt_shape, iobs, iwall}))
+	  slip_wall[{cpt_shape, iobs, iwall}] = double2(0., 0.);
+	else
+	  slip_wall[{cpt_shape, iobs, iwall}] = slip_wall[{cpt_shape, iobs, iwall}] + dt_mech * vt_iw;
+	interactionsOutputWall[{cpt_shape, iobs, iwall}][SLIP]
+	  = slip_wall[{cpt_shape, iobs, iwall}];
+
+	double2 delta_tiw = slip_wall[{cpt_shape, iobs, iwall}];
+	double norm_delta_tiw = !delta_tiw;
+
+	double2 t_viw;
+	if (norm_vt_iw > 0)
+	  t_viw = (1. / norm_vt_iw) * vt_iw;
+	else if (norm_delta_tiw > 0)
+	  t_viw = (1. / norm_delta_tiw) * delta_tiw;
+	else
+	  t_viw = double2(0., 0.);
+
+	uint32_t shapeMaterialId    = shapesMaterial[active_shapeIDshape_crowd[cpt_shape]];
+	uint32_t obstacleMaterialId = obstaclesMaterial[iobs];
+	/*  Normal interactions */
+	double k_n_wall         = binaryProperties[STIFFNESS_NORMAL][shapeMaterialId][obstacleMaterialId];
+	double Gamma_n_wall = binaryProperties[DAMPING_NORMAL][shapeMaterialId][obstacleMaterialId];
+	double2 fniw_elastic = k_n_wall * h * n_iw;
+	double2 fniw_viscous = -Gamma_n_wall * vortho_iw;
+	double2 fniw = fniw_elastic + fniw_viscous;
+	fortho = fortho + fniw;
+	interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_ORTHO] = fniw;
+
+	/*  Tangential interactions */
+	double k_t_wall         = binaryProperties[STIFFNESS_TANGENTIAL][shapeMaterialId][obstacleMaterialId];
+	double Gamma_t_wall = binaryProperties[DAMPING_TANGENTIAL][shapeMaterialId][obstacleMaterialId];
+	double2 ftiw_spring = -k_t_wall * norm_delta_tiw * t_viw;
+	double2 ftiw_viscous = -Gamma_t_wall * vt_iw;
+	double2 ftiw_static = ftiw_spring + ftiw_viscous;
+	double mu_dyn_wall = binaryProperties[FRICTION_SLIDING][shapeMaterialId][obstacleMaterialId];
+	double2 ftiw_dynamic = -mu_dyn_wall * !fniw * t_viw;
+	double2 ftiw = -1. * min(!ftiw_static, !ftiw_dynamic) * t_viw;
+	ft = ft + ftiw;
+	interactionsOutputWall[{cpt_shape, iobs, iwall}][FORCE_TAN] = ftiw;
+
+	/*	Torque	*/
+	double torqniw = (1. ^ dcG) % fniw;
+	double torqtiw = (1. ^ dcG) % ftiw;
+	double torqiw = torqniw + torqtiw;
+	torq = torq + torqiw;
+
+      }
+      iwall++;
+    }
+    iobs++;
+  }
+  return {fortho, ft, torq};
 }
 
 /**
@@ -440,84 +442,84 @@

  */
 void MechanicalLayer::loop()
 {
-    // Reset the forces and torques
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
+  // Reset the forces and torques
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
+  {
+    Forthon[cpt_agent] = double2(0., 0.);
+    Ftn[cpt_agent] = double2(0., 0.);
+    taun[cpt_agent] = 0.;
+  }
+
+  // Loop over shapes for forces and momentum
+  for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
+  {     // FORCE AT TIME n
+    auto Motion = get_interactions(cpt_shape, true);
+    const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
+    Forthon[cpt_agent] =
+      Forthon[cpt_agent] + (1. / masses[cpt_agent]) * get<0>(Motion);         // resultant of normal forces (applied on the contact point)
+    Ftn[cpt_agent] =
+      Ftn[cpt_agent] + (1.0 / masses[cpt_agent]) * get<1>(Motion);         // resultant of tangential forces (applied on the contact point)
+    taun[cpt_agent] = taun[cpt_agent] + (1.0 / mois[cpt_agent]) * get<2>(Motion);       // torque
+  }
+
+  // Loop over agents for positions
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
+  {
+    double UnmZetadt2   = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
+    taun[cpt_agent] = taun[cpt_agent] + (wdesired[cpt_agent] - wn[cpt_agent]) * damping[cpt_agent].second;
+    // update positions with velocity Verlet algorithm
+    rgnp1[cpt_agent] =
+      rgn[cpt_agent] + UnmZetadt2 * dt_mech * vgn[cpt_agent] + 0.5 * dt_mech * dt_mech * (Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent]);
+    thetnp1[cpt_agent] = thetn[cpt_agent] + dt_mech * wn[cpt_agent] + 0.5 * dt_mech * dt_mech * taun[cpt_agent];
+  }
+
+  // Loop over shapes for velocities
+  vector<double2> forthonp1(nb_active_agents, double2(0, 0));
+  vector<double2> ftnp1(nb_active_agents, double2(0, 0));
+  vector<double> taunp1(nb_active_agents, 0.);
+
+  for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
+  {     // FORCE AT TIME N+1
+    auto Motion = get_interactions(cpt_shape, false);
+    const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
+    forthonp1[cpt_agent] = forthonp1[cpt_agent] + get<0>(Motion);
+    ftnp1[cpt_agent] = ftnp1[cpt_agent] + get<1>(Motion);
+    taunp1[cpt_agent] = taunp1[cpt_agent] + get<2>(Motion);
+  }
+
+  // Loop over agents for velocities
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
+  {
+    double UnmZetadt2   = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
+    double UnpZetadt2   = 1.0 + 0.5 * dt_mech * damping[cpt_agent].first;
+    taunp1[cpt_agent] = taunp1[cpt_agent] + (wdesired[cpt_agent] - wnp1[cpt_agent]) * damping[cpt_agent].second;
+    // update velocities
+    vgnp1[cpt_agent] = 1.0 / UnpZetadt2 *
+                       (UnmZetadt2 * vgn[cpt_agent] +
+                        0.5 * dt_mech * (2. * Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent] + forthonp1[cpt_agent] + ftnp1[cpt_agent]));
+    wnp1[cpt_agent] = wn[cpt_agent] + 0.5 * dt_mech * (taun[cpt_agent] + taunp1[cpt_agent]);
+  }
+
+  // Update relative positions of the shapes
+  for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
+  {
+    const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
+    const double delta_theta = thetnp1[cpt_agent] - thetn[cpt_agent];
+    delta[cpt_shape].first = delta[cpt_shape].first * cos(delta_theta) - delta[cpt_shape].second * sin(delta_theta);
+    delta[cpt_shape].second = delta[cpt_shape].first * sin(delta_theta) + delta[cpt_shape].second * cos(delta_theta);
+    // rotation of the delta by an angle delta_theta (the norm is conserved)
+  }
+
+  // update position, velocity, orientation, angular velocity of each agent
+  for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
+  {
     {
-        Forthon[cpt_agent] = double2(0., 0.);
-        Ftn[cpt_agent] = double2(0., 0.);
-        taun[cpt_agent] = 0.;
-    }
-
-    // Loop over shapes for forces and momentum
-    for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
-    {   // FORCE AT TIME n
-        auto Motion = get_interactions(cpt_shape, true);
-        const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
-        Forthon[cpt_agent] =
-            Forthon[cpt_agent] + (1. / masses[cpt_agent]) * get<0>(Motion);   // resultant of normal forces (applied on the contact point)
-        Ftn[cpt_agent] =
-            Ftn[cpt_agent] + (1.0 / masses[cpt_agent]) * get<1>(Motion);   // resultant of tangential forces (applied on the contact point)
-        taun[cpt_agent] = taun[cpt_agent] + (1.0 / mois[cpt_agent]) * get<2>(Motion);   // torque
-    }
-
-    // Loop over agents for positions
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
-    {
-        double UnmZetadt2   = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
-        taun[cpt_agent] = taun[cpt_agent] + (wdesired[cpt_agent] - wn[cpt_agent]) * damping[cpt_agent].second;
-        // update positions with velocity Verlet algorithm
-        rgnp1[cpt_agent] =
-            rgn[cpt_agent] + UnmZetadt2 * dt_mech * vgn[cpt_agent] + 0.5 * dt_mech * dt_mech * (Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent]);
-        thetnp1[cpt_agent] = thetn[cpt_agent] + dt_mech * wn[cpt_agent] + 0.5 * dt_mech * dt_mech * taun[cpt_agent];
-    }
-
-    // Loop over shapes for velocities
-    vector<double2> forthonp1(nb_active_agents, double2(0, 0));
-    vector<double2> ftnp1(nb_active_agents, double2(0, 0));
-    vector<double> taunp1(nb_active_agents, 0.);
-
-    for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
-    {   // FORCE AT TIME N+1
-        auto Motion = get_interactions(cpt_shape, false);
-        const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
-        forthonp1[cpt_agent] = forthonp1[cpt_agent] + get<0>(Motion);
-        ftnp1[cpt_agent] = ftnp1[cpt_agent] + get<1>(Motion);
-        taunp1[cpt_agent] = taunp1[cpt_agent] + get<2>(Motion);
-    }
-
-    // Loop over agents for velocities
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
-    {
-        double UnmZetadt2   = 1.0 - 0.5 * dt_mech * damping[cpt_agent].first;
-        double UnpZetadt2   = 1.0 + 0.5 * dt_mech * damping[cpt_agent].first;
-        taunp1[cpt_agent] = taunp1[cpt_agent] + (wdesired[cpt_agent] - wnp1[cpt_agent]) * damping[cpt_agent].second;
-        // update velocities
-        vgnp1[cpt_agent] = 1.0 / UnpZetadt2 *
-                           (UnmZetadt2 * vgn[cpt_agent] +
-                            0.5 * dt_mech * (2. * Fp[cpt_agent] + Forthon[cpt_agent] + Ftn[cpt_agent] + forthonp1[cpt_agent] + ftnp1[cpt_agent]));
-        wnp1[cpt_agent] = wn[cpt_agent] + 0.5 * dt_mech * (taun[cpt_agent] + taunp1[cpt_agent]);
-    }
-
-    // Update relative positions of the shapes
-    for (unsigned cpt_shape = 0; cpt_shape < nb_active_shapes; cpt_shape++)
-    {
-        const unsigned cpt_agent(active_shapeIDagent[cpt_shape]);
-        const double delta_theta = thetnp1[cpt_agent] - thetn[cpt_agent];
-        delta[cpt_shape].first = delta[cpt_shape].first * cos(delta_theta) - delta[cpt_shape].second * sin(delta_theta);
-        delta[cpt_shape].second = delta[cpt_shape].first * sin(delta_theta) + delta[cpt_shape].second * cos(delta_theta);
-        // rotation of the delta by an angle delta_theta (the norm is conserved)
-    }
-
-    // update position, velocity, orientation, angular velocity of each agent
-    for (unsigned cpt_agent = 0; cpt_agent < nb_active_agents; cpt_agent++)
-    {
-        {
-            rgn[cpt_agent] = rgnp1[cpt_agent];
-            vgn[cpt_agent] = vgnp1[cpt_agent];
-            thetn[cpt_agent] = thetnp1[cpt_agent];
-            wn[cpt_agent] = wnp1[cpt_agent];
-        }
-    }
+      rgn[cpt_agent] = rgnp1[cpt_agent];
+      vgn[cpt_agent] = vgnp1[cpt_agent];
+      thetn[cpt_agent] = thetnp1[cpt_agent];
+      wn[cpt_agent] = wnp1[cpt_agent];
+    }
+  }
 }
 /**
  * @brief For output: do contacts exist?
@@ -525,24 +527,24 @@

  */
 pair<bool, bool> MechanicalLayer::existsContacts() {
 
-    bool agentContact = false;
-    bool wallContact  = false;
-
-    for (auto const& [key, value] : slip)
-    {
-        if (value != double2(0., 0.)) {
-            agentContact = true;
-            break;
-        }
-    }
-    for (auto const& [key, value] : slip_wall)
-    {
-        if (value != double2(0., 0.)) {
-            wallContact = true;
-            break;
-        }
-    }
-    return {agentContact, wallContact};
+  bool agentContact = false;
+  bool wallContact  = false;
+
+  for (auto const& [key, value] : slip)
+  {
+    if (value != double2(0., 0.)) {
+      agentContact = true;
+      break;
+    }
+  }
+  for (auto const& [key, value] : slip_wall)
+  {
+    if (value != double2(0., 0.)) {
+      wallContact = true;
+      break;
+    }
+  }
+  return {agentContact, wallContact};
 }
 
 /**
@@ -555,103 +557,103 @@

  */
 void MechanicalLayer::generateInteractionsOutputFile(const string& interactionsFile, const pair<bool, bool> &exists)
 {
-    ofstream outputDoc;
-    outputDoc.open(interactionsFile);
-
-    outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
-    outputDoc << "<Interactions>" << endl;
-    if (!exists.first && !exists.second) {
-      	outputDoc << "</Interactions>";
-        return;
-    }
-
-    /*  Loop over active agents */
-    set<unsigned> parent;                       //  Variable to remember if we have opening tags for parents
-    set<pair<unsigned, unsigned>> parentChild;  //  Variable to remember if we have an opening child tag
-    for (uint32_t a = 0; a < nb_active_agents; a++) {
-        //  First, collisions with agents
-        if (exists.first && !interactionsOutput.empty()) {
-            for (auto iterator = interactionsOutput.begin(); iterator != interactionsOutput.end(); ) {
-                auto shape = iterator->first.first;
-                const uint32_t agent = active_shapeIDagent[shape];
-                if (agent > a)
-                    break;
-                //  If we're here, agent = a
-                auto output = iterator->second;
-                if (output[SLIP]        == double2(0., 0.)
-                 && output[FORCE_ORTHO] == double2(0., 0.)
-                 && output[FORCE_TAN]   == double2(0., 0.))
-                    continue;
-                if (!parent.contains(a)) {
-                    if (!parent.empty())
-                        outputDoc << "    </Agent>" << endl;
-                    outputDoc << "    <Agent Id=\"" << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
-                    parent.insert(a);
-                }
-                auto shapeNeighbour = iterator->first.second;
-                const uint32_t neighbour = active_shapeIDagent[shapeNeighbour];
-                if (!parentChild.contains({agent, neighbour})) {
-                    if (!parentChild.empty() && parentChild.rbegin()->first == agent)
-                        //  We have switched to another child within the same agent -> insert child closing tag
-                            outputDoc << "        </Agent>" << endl;
-                    outputDoc << "        <Agent Id=\"" << agentMapInverse[agentActiveIds[neighbour]] << "\">" << endl;
-                    parentChild.insert({agent, neighbour});
-                }
-                outputDoc << "            <Interaction ParentShape=\"" << shapeMapInverse[shape] << "\" "
-                          << "ChildShape=\"" << shapeMapInverse[shapeNeighbour] << "\" ";
-                if (output[SLIP] != double2(0., 0.))
-                    outputDoc << "TangentialRelativeDisplacement=\""
-                              << output[SLIP].first << "," << output[SLIP].second << "\" ";
-                if (output[FORCE_ORTHO] != double2(0., 0.))
-                    outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << "," << output[FORCE_ORTHO].second << "\" ";
-                if (output[FORCE_TAN] != double2(0., 0.))
-                    outputDoc << "Ft=\"" << output[FORCE_TAN].first << "," << output[FORCE_TAN].second << "\" ";
-                outputDoc << "/>" << endl;
-                interactionsOutput.erase(iterator++);
-            }
-            if (!parentChild.empty() && parentChild.rbegin()->first == a)
-                //  If there were entries for the current agent, we need to close the last Agent child
-                    outputDoc << "        </Agent>" << endl;
-        }
-        //  Second, collision with walls
-        if (exists.second && !interactionsOutputWall.empty()) {
-            for (auto iterator = interactionsOutputWall.begin(); iterator != interactionsOutputWall.end(); ) {
-                auto key = iterator->first;
-                const uint32_t shape          = get<0>(key);
-                const uint32_t agent = active_shapeIDagent[shape];
-                //  If the current element of interactionsOutputWall is not the same as the last parent, end
-                if (agent > a)
-                    break;
-                auto output = iterator->second;
-                if (output[0] == double2(0., 0.) &&
-                    output[1] == double2(0., 0.) &&
-                    output[2] == double2(0., 0.))
-                    continue;
-                if (!parent.contains(a)) {
-                    if (!parent.empty())
-                        outputDoc << "    </Agent>" << endl;
-                    outputDoc << "    <Agent Id=\"" << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
-                    parent.insert(a);
-                }
-                outputDoc << "        <Wall ShapeId=\"" << shapeMapInverse[shape] << "\" "
-                    << "WallId=\"" << get<1>(key) << "\" CornerId=\"" << get<2>(key) << "\" ";
-                if (output[SLIP] != double2(0., 0.))
-                    outputDoc << "TangentialRelativeDisplacement=\"" << output[SLIP].first << ","
-                              << output[SLIP].second << "\" ";
-                if (output[FORCE_TAN] != double2(0., 0.))
-                    outputDoc << "Ft=\"" << output[FORCE_TAN].first << ","
-                              << output[FORCE_TAN].second << "\" ";
-                if (output[FORCE_ORTHO] != double2(0., 0.))
-                    outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << ","
-                              << output[FORCE_ORTHO].second << "\" ";
-                outputDoc << "/>" << endl;
-                //  Erase the entry in slip_wall to make the next sequential search "easier"
-                interactionsOutputWall.erase(iterator++);
-            }
-        }
-    }
-    outputDoc << "    </Agent>" << endl;
+  ofstream outputDoc;
+  outputDoc.open(interactionsFile);
+
+  outputDoc << R"(<?xml version="1.0" encoding="utf-8"?>)" << endl;
+  outputDoc << "<Interactions>" << endl;
+  if (!exists.first && !exists.second) {
     outputDoc << "</Interactions>";
-
-    outputDoc.close();
+    return;
+  }
+
+  /*  Loop over active agents */
+  set<unsigned> parent;                         //  Variable to remember if we have opening tags for parents
+  set<pair<unsigned, unsigned> > parentChild;   //  Variable to remember if we have an opening child tag
+  for (uint32_t a = 0; a < nb_active_agents; a++) {
+    //  First, collisions with agents
+    if (exists.first && !interactionsOutput.empty()) {
+      for (auto iterator = interactionsOutput.begin(); iterator != interactionsOutput.end(); ) {
+	auto shape = iterator->first.first;
+	const uint32_t agent = active_shapeIDagent[shape];
+	if (agent > a)
+	  break;
+	//  If we're here, agent = a
+	auto output = iterator->second;
+	if (output[SLIP]        == double2(0., 0.)
+	    && output[FORCE_ORTHO] == double2(0., 0.)
+	    && output[FORCE_TAN]   == double2(0., 0.))
+	  continue;
+	if (!parent.contains(a)) {
+	  if (!parent.empty())
+	    outputDoc << "    </Agent>" << endl;
+	  outputDoc << "    <Agent Id=\"" << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
+	  parent.insert(a);
+	}
+	auto shapeNeighbour = iterator->first.second;
+	const uint32_t neighbour = active_shapeIDagent[shapeNeighbour];
+	if (!parentChild.contains({agent, neighbour})) {
+	  if (!parentChild.empty() && parentChild.rbegin()->first == agent)
+	    //  We have switched to another child within the same agent -> insert child closing tag
+	    outputDoc << "        </Agent>" << endl;
+	  outputDoc << "        <Agent Id=\"" << agentMapInverse[agentActiveIds[neighbour]] << "\">" << endl;
+	  parentChild.insert({agent, neighbour});
+	}
+	outputDoc << "            <Interaction ParentShape=\"" << shapeMapInverse[shape] << "\" "
+	          << "ChildShape=\"" << shapeMapInverse[shapeNeighbour] << "\" ";
+	if (output[SLIP] != double2(0., 0.))
+	  outputDoc << "TangentialRelativeDisplacement=\""
+	            << output[SLIP].first << "," << output[SLIP].second << "\" ";
+	if (output[FORCE_ORTHO] != double2(0., 0.))
+	  outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << "," << output[FORCE_ORTHO].second << "\" ";
+	if (output[FORCE_TAN] != double2(0., 0.))
+	  outputDoc << "Ft=\"" << output[FORCE_TAN].first << "," << output[FORCE_TAN].second << "\" ";
+	outputDoc << "/>" << endl;
+	interactionsOutput.erase(iterator++);
+      }
+      if (!parentChild.empty() && parentChild.rbegin()->first == a)
+	//  If there were entries for the current agent, we need to close the last Agent child
+	outputDoc << "        </Agent>" << endl;
+    }
+    //  Second, collision with walls
+    if (exists.second && !interactionsOutputWall.empty()) {
+      for (auto iterator = interactionsOutputWall.begin(); iterator != interactionsOutputWall.end(); ) {
+	auto key = iterator->first;
+	const uint32_t shape          = get<0>(key);
+	const uint32_t agent = active_shapeIDagent[shape];
+	//  If the current element of interactionsOutputWall is not the same as the last parent, end
+	if (agent > a)
+	  break;
+	auto output = iterator->second;
+	if (output[0] == double2(0., 0.) &&
+	    output[1] == double2(0., 0.) &&
+	    output[2] == double2(0., 0.))
+	  continue;
+	if (!parent.contains(a)) {
+	  if (!parent.empty())
+	    outputDoc << "    </Agent>" << endl;
+	  outputDoc << "    <Agent Id=\"" << agentMapInverse[agentActiveIds[agent]] << "\">" << endl;
+	  parent.insert(a);
+	}
+	outputDoc << "        <Wall ShapeId=\"" << shapeMapInverse[shape] << "\" "
+	          << "WallId=\"" << get<1>(key) << "\" CornerId=\"" << get<2>(key) << "\" ";
+	if (output[SLIP] != double2(0., 0.))
+	  outputDoc << "TangentialRelativeDisplacement=\"" << output[SLIP].first << ","
+	            << output[SLIP].second << "\" ";
+	if (output[FORCE_TAN] != double2(0., 0.))
+	  outputDoc << "Ft=\"" << output[FORCE_TAN].first << ","
+	            << output[FORCE_TAN].second << "\" ";
+	if (output[FORCE_ORTHO] != double2(0., 0.))
+	  outputDoc << "Fn=\"" << output[FORCE_ORTHO].first << ","
+	            << output[FORCE_ORTHO].second << "\" ";
+	outputDoc << "/>" << endl;
+	//  Erase the entry in slip_wall to make the next sequential search "easier"
+	interactionsOutputWall.erase(iterator++);
+      }
+    }
+  }
+  outputDoc << "    </Agent>" << endl;
+  outputDoc << "</Interactions>";
+
+  outputDoc.close();
 }

cppcheck.................................................................Failed
- hook id: cppcheck
- exit code: 1

tests/mechanical_layer/src/Main.cpp:13:0: information: Include file: "CrowdMechanics.h" not found. [missingInclude]
#include "CrowdMechanics.h"
^
nofile:0:0: information: Active checkers: 167/856 (use --checkers-report=<filename> to see details) [checkersReport]

tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 16 configurations. Use --force to check all configurations. [toomanyconfigs]

^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:206:5: warning: Member variable 'DynArray < XMLNode * , 10 >::_pool' is not initialized in the constructor. [uninitMemberVar]
    DynArray() :
    ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:206:5: warning: Member variable 'DynArray < const char * , 10 >::_pool' is not initialized in the constructor. [uninitMemberVar]
    DynArray() :
    ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:206:5: warning: Member variable 'DynArray < char , 20 >::_pool' is not initialized in the constructor. [uninitMemberVar]
    DynArray() :
    ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1688:5: style: Class 'XMLElement' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    XMLElement( XMLDocument* doc );
    ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1731:5: style: Class 'XMLDocument' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    XMLDocument( bool processEntities = true, Whitespace whitespaceMode = PRESERVE_WHITESPACE );
    ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:2249:5: style: Class 'XMLPrinter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 );
    ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1020:14: style: The destructor '~XMLText' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~XMLText()            {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:952:14: note: Virtual destructor in base class
    virtual ~XMLNode();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1020:14: note: Destructor in derived class
    virtual ~XMLText()            {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1051:14: style: The destructor '~XMLComment' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~XMLComment();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:952:14: note: Virtual destructor in base class
    virtual ~XMLNode();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1051:14: note: Destructor in derived class
    virtual ~XMLComment();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1090:14: style: The destructor '~XMLDeclaration' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~XMLDeclaration();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:952:14: note: Virtual destructor in base class
    virtual ~XMLNode();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1090:14: note: Destructor in derived class
    virtual ~XMLDeclaration();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1125:14: style: The destructor '~XMLUnknown' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~XMLUnknown();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:952:14: note: Virtual destructor in base class
    virtual ~XMLNode();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1125:14: note: Destructor in derived class
    virtual ~XMLUnknown();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1689:14: style: The destructor '~XMLElement' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~XMLElement();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:952:14: note: Virtual destructor in base class
    virtual ~XMLNode();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1689:14: note: Destructor in derived class
    virtual ~XMLElement();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1732:6: style: The destructor '~XMLDocument' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~XMLDocument();
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:952:14: note: Virtual destructor in base class
    virtual ~XMLNode();
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:1732:6: note: Destructor in derived class
    ~XMLDocument();
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:2250:14: style: The destructor '~XMLPrinter' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~XMLPrinter() {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:480:14: note: Virtual destructor in base class
    virtual ~XMLVisitor() {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:2250:14: note: Destructor in derived class
    virtual ~XMLPrinter() {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: style: The destructor '~MemPoolT < sizeof ( XMLElement ) >' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:330:14: note: Virtual destructor in base class
    virtual ~MemPool() {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: note: Destructor in derived class
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: style: The destructor '~MemPoolT < sizeof ( XMLAttribute ) >' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:330:14: note: Virtual destructor in base class
    virtual ~MemPool() {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: note: Destructor in derived class
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: style: The destructor '~MemPoolT < sizeof ( XMLText ) >' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:330:14: note: Virtual destructor in base class
    virtual ~MemPool() {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: note: Destructor in derived class
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: style: The destructor '~MemPoolT < sizeof ( XMLComment ) >' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:330:14: note: Virtual destructor in base class
    virtual ~MemPool() {}
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:347:6: note: Destructor in derived class
    ~MemPoolT() {
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:410:9: portability: %d in format string (no. 2) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
        ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:410:9: portability: %d in format string (no. 3) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
        ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:410:9: portability: %d in format string (no. 4) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
        ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:410:9: portability: %d in format string (no. 5) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
        ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:410:9: portability: %d in format string (no. 6) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
        ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:433:10: warning: Either the condition 'length==0' is redundant or there is possible null pointer dereference: length. [nullPointerRedundantCheck]
        *length = 4;
         ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:548:14: note: Assuming that condition 'length==0' is not redundant
  if (length == 0) {
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:547:40: note: Calling function 'ConvertUTF32ToUTF8', 3rd argument 'length' value is 0
        ConvertUTF32ToUTF8(ucs, value, length);
                                       ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:433:10: note: Null pointer dereference
        *length = 4;
         ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:440:16: warning: Either the condition 'length==0' is redundant or there is possible null pointer dereference: length. [nullPointerRedundantCheck]
    output += *length;
               ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:548:14: note: Assuming that condition 'length==0' is not redundant
  if (length == 0) {
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:547:40: note: Calling function 'ConvertUTF32ToUTF8', 3rd argument 'length' value is 0
        ConvertUTF32ToUTF8(ucs, value, length);
                                       ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:440:16: note: Null pointer dereference
    output += *length;
               ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:444:14: warning: Either the condition 'length==0' is redundant or there is possible null pointer dereference: length. [nullPointerRedundantCheck]
    switch (*length) {
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:548:14: note: Assuming that condition 'length==0' is not redundant
  if (length == 0) {
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:547:40: note: Calling function 'ConvertUTF32ToUTF8', 3rd argument 'length' value is 0
        ConvertUTF32ToUTF8(ucs, value, length);
                                       ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:444:14: note: Null pointer dereference
    switch (*length) {
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:473:6: warning: Either the condition 'length==0' is redundant or there is possible null pointer dereference: length. [nullPointerRedundantCheck]
    *length = 0;
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:548:14: note: Assuming that condition 'length==0' is not redundant
  if (length == 0) {
             ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:473:6: note: Null pointer dereference
    *length = 0;
     ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1966:17: warning: Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
        if ( !(*p) ) {
                ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1980:18: note: Assuming that condition '!p' is not redundant
            if ( !p || Attribute( attrib->Name() ) ) {
                 ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1966:17: note: Null pointer dereference
        if ( !(*p) ) {
                ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1972:67: warning: Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
        if (XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
                                                                  ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1980:18: note: Assuming that condition '!p' is not redundant
            if ( !p || Attribute( attrib->Name() ) ) {
                 ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1972:67: note: Null pointer dereference
        if (XMLUtil::IsNameStartChar( static_cast<unsigned char>(*p) ) ) {
                                                                  ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:153:9: error: syntax error [syntaxError]
        TIXMLASSERT( start );
        ^
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:269:28: style: Unsigned expression '_size' can't be negative so it is unnecessary to test it. [unsignedPositive]
        TIXMLASSERT( _size >= 0 );
                           ^
nofile:0:0: information: Active checkers: There was critical errors (use --checkers-report=<filename> to see details) [checkersReport]

tests/mechanical_layer/src/InputStatic.cpp:1:0: information: Include file: "InputStatic.h" not found. [missingInclude]
#include "InputStatic.h"
^
tests/mechanical_layer/src/InputStatic.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
nofile:0:0: information: Active checkers: 167/856 (use --checkers-report=<filename> to see details) [checkersReport]

tests/mechanical_layer/include/Globals.h:17:0: information: Include file: "tinyxml2.h" not found. [missingInclude]
#include "tinyxml2.h"
^
tests/mechanical_layer/include/Globals.h:118:1: error: Code 'std::pair' is invalid C code. [syntaxError]
std::pair<int, double2> parse2DComponents(const char *line);
^
nofile:0:0: information: Active checkers: There was critical errors (use --checkers-report=<filename> to see details) [checkersReport]

cpplint..................................................................Failed
- hook id: cpplint
- exit code: 1

Done processing tests/mechanical_layer/src/Main.cpp
Total errors found: 7
tests/mechanical_layer/src/Main.cpp:0:  No copyright message found.  You should have a line: "Copyright [year] <Copyright Owner>"  [legal/copyright] [5]
tests/mechanical_layer/src/Main.cpp:15:  Do not use namespace using-directives.  Use using-declarations instead.  [build/namespaces] [5]
tests/mechanical_layer/src/Main.cpp:38:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/src/Main.cpp:70:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/Main.cpp:60:  Add #include <vector> for vector<>  [build/include_what_you_use] [4]
tests/mechanical_layer/src/Main.cpp:69:  Add #include <string> for string  [build/include_what_you_use] [4]
tests/mechanical_layer/src/Main.cpp:80:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]
Done processing tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp
Total errors found: 1673
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:0:  No copyright message found.  You should have a line: "Copyright [year] <Copyright Owner>"  [legal/copyright] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:  Include the directory when naming header files  [build/include_subdir] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:26:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:27:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:36:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:44:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:44:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:44:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:45:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:45:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:45:  Missing space before {  [whitespace/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:46:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:47:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:47:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:47:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:48:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:48:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:48:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:49:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:49:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:49:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:50:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:51:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:53:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:53:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:53:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:54:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:54:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:54:  Missing space before {  [whitespace/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:55:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:55:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:55:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:56:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:57:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:59:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:60:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:62:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:63:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:64:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:65:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:66:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:67:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:68:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:68:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:68:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:69:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:70:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:71:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:71:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:72:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:72:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:72:  Missing space before {  [whitespace/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:73:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:74:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:75:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:76:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:77:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:78:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:79:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:80:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:80:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:80:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:81:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:82:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:83:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:84:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:85:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:85:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:85:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:86:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:87:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:88:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:90:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:91:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:91:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:92:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:93:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:94:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:94:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:95:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:95:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:95:  Missing space before {  [whitespace/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:96:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:96:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:96:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:97:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:97:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:97:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:98:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:99:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:100:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:104:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:105:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:106:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:107:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:108:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:110:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:111:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:113:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:114:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:118:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:118:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:120:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:120:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:122:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:123:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:126:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:126:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:127:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:127:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:134:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:144:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:145:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:146:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:147:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:148:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:153:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:158:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:159:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:166:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:166:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:167:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:167:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:168:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:168:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:169:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:169:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:184:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:194:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:195:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:196:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:196:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:198:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:198:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:199:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:199:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:201:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:201:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:207:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:207:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:208:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:209:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:209:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:210:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:210:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:211:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:215:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:215:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:219:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:219:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:220:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:220:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:226:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:226:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:232:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:233:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:237:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:243:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:247:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:247:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:253:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:255:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:255:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:257:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:257:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:260:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:260:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:261:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:261:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:263:  Missing space before ( in while(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:264:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:264:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:265:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:265:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:267:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:282:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:283:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:283:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:284:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:284:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:290:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:290:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:291:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:291:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:293:  Missing space before ( in while(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:301:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:307:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:307:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:311:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:317:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:317:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:327:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:327:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:327:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:333:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:334:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:334:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:335:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:335:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:337:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:337:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:341:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:343:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:345:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:346:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:346:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:362:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:377:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:377:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:389:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:390:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:391:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:392:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:394:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:395:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:399:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:400:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:401:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:401:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:402:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:402:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:412:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:412:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:417:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:417:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:417:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:418:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:419:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:420:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:421:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:421:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:426:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:426:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:429:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:429:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:432:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:432:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:435:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:449:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:454:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:459:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:465:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:465:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:471:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:496:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:519:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:519:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:522:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:522:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:525:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:532:  Line ends in whitespace.  Consider deleting these extra spaces.  [whitespace/end_of_line] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:533:  Line ends in whitespace.  Consider deleting these extra spaces.  [whitespace/end_of_line] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:548:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:551:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:552:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:558:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:559:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:560:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:560:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:564:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:565:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:566:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:566:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:570:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:571:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:572:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:572:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:579:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:580:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:581:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:581:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:585:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:586:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:587:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:587:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:591:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:592:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:593:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:594:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:594:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:597:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:598:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:600:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:600:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:604:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:612:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:621:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:628:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:629:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:631:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:631:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:632:  Missing spaces around ==  [whitespace/operators] [3]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:654:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:655:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:656:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:656:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:663:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:664:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:665:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:665:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:673:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:675:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:675:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:675:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:675:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:681:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:682:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:682:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:682:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:682:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:688:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:693:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:693:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:693:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:693:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:694:  Missing space before ( in if(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:702:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:703:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:704:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:704:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:705:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:705:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:708:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:708:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:709:  Missing space before ( in if(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:711:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:711:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:716:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:717:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:718:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:719:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:720:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:720:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:720:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:722:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:723:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:724:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:725:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:726:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:728:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:728:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:729:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:729:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:729:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:731:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:732:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:732:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:736:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:736:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:736:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:737:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:737:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:741:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:741:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:741:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:742:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:742:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:746:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:746:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:748:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:748:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:748:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:749:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:749:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:753:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:753:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:753:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:754:  Redundant blank line at the start of a code block should be deleted.  [whitespace/blank_line] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:755:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:756:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:759:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:759:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:762:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:768:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:769:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:769:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:770:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:770:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:771:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:771:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:775:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:775:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:776:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:776:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:782:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:782:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:783:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:784:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:784:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:785:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:786:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:787:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:798:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:798:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:799:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:799:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:800:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:800:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:802:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:802:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:803:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:803:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:804:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:804:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:805:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:805:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:805:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:806:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:807:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:812:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:815:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:815:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:819:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:822:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:824:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:826:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:827:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:828:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:829:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:831:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:835:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:837:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:839:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:840:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:841:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:842:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:844:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:848:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:855:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:856:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:858:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:858:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:860:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:861:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:861:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:866:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:867:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:868:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:870:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:870:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:871:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:872:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:873:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:874:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:875:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:879:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:880:  Missing space before ( in while(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:881:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:881:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:882:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:882:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:888:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:889:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:890:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:890:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:891:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:891:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:892:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:892:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:906:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:907:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:908:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:912:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:913:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:914:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:914:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:915:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:915:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:916:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:916:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:917:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:917:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:918:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:919:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:920:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:921:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:921:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:925:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:926:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:927:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:927:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:929:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:929:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:932:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:932:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:935:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:935:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:936:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:936:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:943:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:944:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:944:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:955:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:956:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:957:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:957:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:959:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:959:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:962:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:962:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:965:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:965:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:966:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:966:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:974:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:975:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:975:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:986:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:987:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:988:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:988:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:990:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:990:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:994:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:994:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:997:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:997:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1012:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1012:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1024:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1024:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1025:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1026:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1027:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1027:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1036:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1036:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1037:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1038:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1039:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1039:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1048:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1048:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1049:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1050:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1051:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1051:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1060:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1060:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1061:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1062:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1063:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1063:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1072:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1073:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1076:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1076:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1077:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1080:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1080:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1081:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1081:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1082:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1084:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1088:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1089:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1091:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1092:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1093:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1095:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1096:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1099:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1099:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1100:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1100:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1109:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1109:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1111:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1111:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1113:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1123:  Line ends in whitespace.  Consider deleting these extra spaces.  [whitespace/end_of_line] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1125:  Line ends in whitespace.  Consider deleting these extra spaces.  [whitespace/end_of_line] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1126:  Line ends in whitespace.  Consider deleting these extra spaces.  [whitespace/end_of_line] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1138:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1143:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1143:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1144:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1144:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1154:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1154:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1156:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1157:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1157:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1169:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1173:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1173:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1173:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1173:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1178:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1178:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1179:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1179:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1183:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1183:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1188:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1189:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1193:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1194:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1195:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1196:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1200:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1200:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1203:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1203:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1204:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1205:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1205:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1206:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1206:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1208:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1209:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1209:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1210:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1211:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1211:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1212:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1214:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1217:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1217:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1218:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1226:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1233:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1234:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1236:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1236:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1236:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1238:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1238:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1242:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1243:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1248:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1248:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1253:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1253:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1260:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1260:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1261:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1265:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1265:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1265:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1265:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1266:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1271:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1271:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1272:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1273:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1273:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1279:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1279:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1280:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1281:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1281:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1288:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1288:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1289:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1294:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1298:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1299:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1301:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1301:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1303:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1303:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1309:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1309:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1310:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1314:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1314:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1314:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1314:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1319:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1319:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1320:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1321:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1321:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1327:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1327:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1328:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1329:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1329:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1336:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1336:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1337:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1342:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1343:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1347:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1348:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1350:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1350:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1350:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1352:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1352:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1358:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1358:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1359:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1363:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1363:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1363:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1363:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1368:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1368:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1369:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1370:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1370:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1372:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1377:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1377:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1378:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1379:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1379:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1385:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1385:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1386:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1391:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1395:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1396:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1398:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1398:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1398:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1400:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1400:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1406:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1406:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1407:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1411:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1411:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1411:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1411:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1416:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1416:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1417:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1418:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1418:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1424:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1424:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1425:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1426:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1426:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1433:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1438:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1442:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1442:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1443:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1445:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1445:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1451:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1451:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1456:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1456:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1457:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1457:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1463:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1463:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1465:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1465:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1465:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1470:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1471:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1472:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1472:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1476:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1476:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1477:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1478:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1478:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1485:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1485:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1486:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1487:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1487:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1495:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1496:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1497:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1498:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1499:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1504:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1505:  Missing space before ( in if(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1512:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1512:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1513:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1514:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1514:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1521:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1521:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1522:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1523:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1523:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1530:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1530:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1531:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1532:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1532:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1539:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1540:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1541:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1541:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1545:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1546:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1548:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1548:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1549:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1549:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1553:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1554:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1556:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1556:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1557:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1557:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1562:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1563:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1564:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1565:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1569:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1576:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1577:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1579:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1579:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1580:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1580:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1583:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1584:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1586:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1586:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1587:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1587:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1590:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1591:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1593:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1593:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1594:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1594:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1599:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1599:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1600:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1600:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1601:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1602:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1607:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1608:  Missing space before ( in while(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1610:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1610:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1616:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1616:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1617:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1618:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1619:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1627:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1627:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1628:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1629:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1629:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1633:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1633:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1640:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1641:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1642:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1643:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1646:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1647:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1648:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1649:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1650:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1654:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1655:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1656:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1657:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1660:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1661:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1662:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1663:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1664:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1668:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1669:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1670:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1671:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1675:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1676:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1677:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1678:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1682:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1683:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1684:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1685:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1689:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1707:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1707:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1708:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1709:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1710:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1710:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1710:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1711:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1711:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1712:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1712:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1712:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1713:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1713:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1713:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1714:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1718:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1719:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1721:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1721:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1722:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1722:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1726:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1727:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1729:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1729:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1730:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1730:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1735:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1736:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1737:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1738:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1748:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1749:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1751:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1751:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1752:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1752:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1756:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1757:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1759:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1759:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1760:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1760:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1764:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1765:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1767:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1767:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1768:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1768:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1772:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1772:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1773:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1776:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1785:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1785:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1786:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1789:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1799:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1800:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1801:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1802:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1803:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1804:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1805:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1806:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1807:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1812:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1813:  Missing space before ( in if(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1815:  Missing space before ( in if(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1824:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1824:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1825:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1828:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1837:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1837:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1838:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1841:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1850:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1850:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1851:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1854:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1863:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1864:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1865:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1866:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1870:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1871:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1872:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1873:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1877:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1878:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1879:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1880:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1884:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1885:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1886:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1887:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1891:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1892:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1893:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1894:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1898:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1899:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1900:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1901:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1905:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1906:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1907:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1908:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1912:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1913:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1916:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1919:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1925:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1925:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1927:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1927:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1930:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1931:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1931:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1934:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1934:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1940:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1941:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1943:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1943:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1944:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1948:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1951:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1951:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1959:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1960:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1964:  Missing space before ( in while(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1964:  Mismatching spaces inside () in while  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1965:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1965:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1967:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1967:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1972:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1972:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1974:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1974:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1979:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1979:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1979:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1980:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1981:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1981:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1982:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1982:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1987:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1991:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1991:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1994:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1995:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:1995:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2001:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2001:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2006:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2006:  If an else has a brace on one side, it should have it on both  [readability/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2008:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2008:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2010:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2011:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2011:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2018:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2019:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2025:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2025:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2029:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2030:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2031:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2032:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2032:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2040:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2046:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2052:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2058:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2064:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2072:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2072:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2073:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2073:  Should have a space between // and comment  [whitespace/comments] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2075:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2075:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2076:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2078:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2078:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2088:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2088:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2093:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2093:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2098:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2098:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2104:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2104:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2105:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2109:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2109:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2109:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2110:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2110:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2111:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2111:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2111:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2117:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2117:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2118:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2119:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2119:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2121:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2121:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2122:  Redundant blank line at the start of a code block should be deleted.  [whitespace/blank_line] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2123:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2124:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2127:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2143:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2143:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2144:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2145:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2145:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2146:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2147:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2148:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2179:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2183:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2183:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2184:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2184:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2185:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2185:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2186:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2186:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2188:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2188:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2190:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2190:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2191:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2191:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2192:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2192:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2193:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2199:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2200:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2206:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2212:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2213:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2214:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2216:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2217:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2218:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2219:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2220:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2221:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2225:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2227:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2227:  Mismatching spaces inside () in while  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2228:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2228:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2229:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2238:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2241:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2241:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2242:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2242:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2243:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2243:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2244:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2244:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2249:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2249:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2250:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2250:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2251:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2252:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2252:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2259:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2260:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2262:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2265:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2266:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2266:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2267:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2268:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2271:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2272:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2273:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2273:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2274:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2274:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2279:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2280:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2281:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2281:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2282:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2282:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2287:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2288:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2289:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2289:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2290:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2290:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2295:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2296:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2297:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2297:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2298:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2298:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2303:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2304:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2305:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2305:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2306:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2306:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2310:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2311:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2312:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2312:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2313:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2313:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2316:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2316:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2321:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2321:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2326:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2326:  Missing space before {  [whitespace/braces] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2326:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2327:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2327:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2328:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2330:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2330:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2332:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2344:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2345:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2347:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2347:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2348:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2348:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2353:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2353:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2355:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2355:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2358:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2358:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2359:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2359:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2363:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2364:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2367:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2367:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2368:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2368:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2369:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2369:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2373:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2373:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2375:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2377:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2377:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2377:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2378:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2378:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2380:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2380:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2383:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2383:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2384:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2388:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2390:  Use int16_t/int64_t/etc, rather than the C type long  [runtime/int] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2391:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2392:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2392:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2397:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2397:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2402:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2402:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2404:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2404:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2406:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2406:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2417:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2418:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2420:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2420:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2421:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2421:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2425:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2425:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2427:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2427:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2427:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2431:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2431:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2436:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2437:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2441:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2441:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2442:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2442:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2447:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2448:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2452:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2452:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2456:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2456:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2458:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2458:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2460:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2460:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2478:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2478:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2479:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2481:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2481:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2483:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2484:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2484:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2485:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2485:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2497:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2497:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2498:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2502:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2508:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2509:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2511:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2512:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2513:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2514:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2516:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2517:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2518:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2519:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2520:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2521:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2522:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2527:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2528:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2528:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2528:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2530:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2530:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2535:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2536:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2541:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2546:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2551:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2552:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2552:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2553:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2553:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2557:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2557:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2558:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2558:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2560:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2560:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2563:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2567:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2568:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2569:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2570:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2570:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2570:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2571:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2575:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2576:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2577:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2580:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2580:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2581:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2581:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2583:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2583:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2584:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2584:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2585:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2585:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2586:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2586:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2587:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2587:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2588:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2588:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2590:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2591:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2591:  Missing spaces around <  [whitespace/operators] [3]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2591:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2595:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2595:  Missing spaces around <  [whitespace/operators] [3]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2595:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2598:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2598:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2603:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2603:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2603:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2604:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2604:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2608:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2609:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2611:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2611:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2614:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2614:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2616:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2617:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2617:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2619:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2619:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2620:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2620:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2621:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2621:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2622:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2622:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2623:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2623:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2623:  At least two spaces is best between code and comments  [whitespace/comments] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2623:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2623:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2624:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2624:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2624:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2626:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2626:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2630:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2631:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2635:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2636:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2636:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2637:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2637:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2643:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2644:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2646:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2646:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2648:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2649:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2656:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2657:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2658:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2658:  Missing spaces around <  [whitespace/operators] [3]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2658:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2659:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2659:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2664:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2665:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2672:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2672:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2673:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2681:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2681:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2681:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2682:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2682:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2686:  Missing spaces around =  [whitespace/operators] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2686:  Missing spaces around <  [whitespace/operators] [3]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2686:  Missing space before ( in for(  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2688:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2688:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2689:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2689:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2690:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2690:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2696:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2697:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2697:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2703:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2703:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2709:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2709:  Extra space after (  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2709:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2710:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2710:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2713:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2714:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2714:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2719:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2720:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2722:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2723:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2723:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2726:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2726:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2730:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2731:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2739:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2740:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2741:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2741:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2742:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2742:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2748:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2749:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2750:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2750:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2751:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2751:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2753:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2753:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2753:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2754:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2754:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2754:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2761:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2762:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2763:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2763:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2764:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2764:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2764:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2765:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2765:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2766:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2766:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2767:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2767:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2768:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2768:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2768:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2772:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2773:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2775:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2775:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2776:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2776:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2780:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2781:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2783:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2783:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2784:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2784:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2789:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2790:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2791:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2792:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2797:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2798:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2799:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2800:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2804:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2805:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2807:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2807:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2808:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2808:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2812:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2813:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2815:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2815:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2816:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2816:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2820:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2821:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2826:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2826:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2828:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2829:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2830:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2830:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2831:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2831:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2833:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2833:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2833:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2834:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2834:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2834:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2835:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2835:  Extra space before ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2835:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2841:  Mismatching spaces inside () in if  [whitespace/parens] [5]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2842:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2842:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2849:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2854:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2854:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2858:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2859:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2864:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2864:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2865:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2865:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2866:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2866:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2868:  An else should appear on the same line as the preceding }  [whitespace/newline] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2869:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2869:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2874:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2875:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2877:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2877:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2878:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2878:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2882:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2883:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2884:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2885:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2886:  Tab found; better to use spaces  [whitespace/tab] [1]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2890:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2891:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2893:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2893:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2894:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2894:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2898:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2899:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2901:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2901:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2902:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2902:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2906:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2907:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2909:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2909:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2910:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2910:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2914:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2915:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2917:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2917:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2918:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2918:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2922:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2923:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2925:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2925:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2926:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2926:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2930:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2931:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2932:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2932:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2934:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2934:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2935:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2935:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2936:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2936:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2940:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2941:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2942:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2942:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2944:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2944:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2945:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2945:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2946:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2946:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2950:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2951:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2952:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2952:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2954:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2954:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2955:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2955:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2956:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2956:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2960:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2961:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2964:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2964:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2970:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2970:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2971:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2976:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2976:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2976:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2977:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2977:  Extra space before )  [whitespace/parens] [2]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2979:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2986:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2987:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2988:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2993:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2994:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2995:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3000:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3001:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3002:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3006:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3007:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3008:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3013:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3014:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:3015:  Extra space after ( in function call  [whitespace/parens] [4]
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:2614:  Add #include <cstdio> for vfprintf  [build/include_what_you_use] [4]
Done processing tests/mechanical_layer/src/InputStatic.cpp
Total errors found: 114
tests/mechanical_layer/src/InputStatic.cpp:0:  No copyright message found.  You should have a line: "Copyright [year] <Copyright Owner>"  [legal/copyright] [5]
tests/mechanical_layer/src/InputStatic.cpp:3:  Do not use namespace using-directives.  Use using-declarations instead.  [build/namespaces] [5]
tests/mechanical_layer/src/InputStatic.cpp:12:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:16:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:20:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:22:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:26:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:31:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:35:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:40:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:45:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:49:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:51:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:52:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:54:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:68:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:77:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:79:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:84:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:91:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:99:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:101:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:102:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:104:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:107:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:105:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:108:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:111:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:109:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:124:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:125:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:155:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:156:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:158:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:159:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:161:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:162:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:163:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:179:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:184:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:194:  Use operator || instead of or  [readability/alt_tokens] [2]
tests/mechanical_layer/src/InputStatic.cpp:195:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:199:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:202:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:200:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:203:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:206:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:204:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:207:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:210:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:208:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:212:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:213:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:214:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:215:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:216:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:217:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:218:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:231:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:240:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:242:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:247:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:252:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:255:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:253:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:256:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:259:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:257:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:262:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:271:  Use operator || instead of or  [readability/alt_tokens] [2]
tests/mechanical_layer/src/InputStatic.cpp:272:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:274:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:279:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:286:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:287:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:292:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:321:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:322:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:323:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:332:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:337:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:347:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:350:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:348:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:355:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:358:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:359:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:364:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:368:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:365:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:369:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:373:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:370:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:377:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:382:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:393:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:394:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:402:  Use operator || instead of or  [readability/alt_tokens] [2]
tests/mechanical_layer/src/InputStatic.cpp:403:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:405:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:410:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:413:  You don't need a ; after a }  [readability/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:411:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:416:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:417:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:422:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:451:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:457:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:466:  { should almost always be at the end of the previous line  [whitespace/braces] [4]
tests/mechanical_layer/src/InputStatic.cpp:472:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/src/InputStatic.cpp:322:  Add #include <string> for string  [build/include_what_you_use] [4]
tests/mechanical_layer/src/InputStatic.cpp:322:  Add #include <vector> for vector<>  [build/include_what_you_use] [4]
tests/mechanical_layer/src/InputStatic.cpp:422:  Add #include <iostream> for cerr  [build/include_what_you_use] [4]
tests/mechanical_layer/src/InputStatic.cpp:473:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]
Done processing tests/mechanical_layer/include/Crowd.h
Total errors found: 9
tests/mechanical_layer/include/Crowd.h:0:  No copyright message found.  You should have a line: "Copyright [year] <Copyright Owner>"  [legal/copyright] [5]
tests/mechanical_layer/include/Crowd.h:1:  #ifndef header guard has wrong style, please use: TESTS_MECHANICAL_LAYER_INCLUDE_CROWD_H_  [build/header_guard] [5]
tests/mechanical_layer/include/Crowd.h:26:  #endif line should be "#endif  // TESTS_MECHANICAL_LAYER_INCLUDE_CROWD_H_"  [build/header_guard] [5]
tests/mechanical_layer/include/Crowd.h:13:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/include/Crowd.h:15:  Lines should be <= 80 characters long  [whitespace/line_length] [2]
tests/mechanical_layer/include/Crowd.h:8:  Add #include <list> for list<>  [build/include_what_you_use] [4]
tests/mechanical_layer/include/Crowd.h:16:  Add #include <vector> for vector<>  [build/include_what_you_use] [4]
tests/mechanical_layer/include/Crowd.h:24:  Add #include <string> for string  [build/include_what_you_use] [4]
tests/mechanical_layer/include/Crowd.h:26:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]

include-what-you-use.....................................................Failed
- hook id: include-what-you-use
- exit code: 1

tests/mechanical_layer/src/Main.cpp:13:10: fatal error: 'CrowdMechanics.h' file not found
   13 | #include "CrowdMechanics.h"
      |          ^~~~~~~~~~~~~~~~~~
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:40:
In file included from /opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/cstdlib:90:
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/stdlib.h:141:30: error: unknown type name 'ldiv_t'
  141 | inline _LIBCPP_HIDE_FROM_ABI ldiv_t div(long __x, long __y) _NOEXCEPT { return ::ldiv(__x, __y); }
      |                              ^
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/stdlib.h:141:82: error: no member named 'ldiv' in the global namespace
  141 | inline _LIBCPP_HIDE_FROM_ABI ldiv_t div(long __x, long __y) _NOEXCEPT { return ::ldiv(__x, __y); }
      |                                                                                ~~^
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/stdlib.h:143:30: error: unknown type name 'lldiv_t'
  143 | inline _LIBCPP_HIDE_FROM_ABI lldiv_t div(long long __x, long long __y) _NOEXCEPT { return ::lldiv(__x, __y); }
      |                              ^
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/stdlib.h:143:93: error: no member named 'lldiv' in the global namespace
  143 | inline _LIBCPP_HIDE_FROM_ABI lldiv_t div(long long __x, long long __y) _NOEXCEPT { return ::lldiv(__x, __y); }
      |                                                                                           ~~^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:41:
In file included from /opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/cstring:66:
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/string.h:98:102: error: unknown type name 'size_t'; did you mean 'std::size_t'?
   98 | inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_PREFERRED_OVERLOAD const void* memchr(const void* __s, int __c, size_t __n) {
      |                                                                                                      ^
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:41:
In file included from /opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/cstring:66:
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/string.h:101:90: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  101 | inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_PREFERRED_OVERLOAD void* memchr(void* __s, int __c, size_t __n) {
      |                                                                                          ^
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:202:20: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  202 | template <class T, size_t INITIAL_SIZE>
      |                    ^~~~~~
      |                    std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:230:17: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  230 |     T* PushArr( size_t count ) {
      |                 ^~~~~~
      |                 std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:244:18: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  244 |     void PopArr( size_t count ) {
      |                  ^~~~~~
      |                  std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:253:19: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  253 |     T& operator[](size_t i) {
      |                   ^~~~~~
      |                   std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:258:25: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  258 |     const T& operator[](size_t i) const {
      |                         ^~~~~~
      |                         std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:268:5: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  268 |     size_t Size() const {
      |     ^~~~~~
      |     std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:273:5: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  273 |     size_t Capacity() const {
      |     ^~~~~~
      |     std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:278:18: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  278 |         void SwapRemove(size_t i) {
      |                         ^~~~~~
      |                         std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:299:26: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  299 |     void EnsureCapacity( size_t cap ) {
      |                          ^~~~~~
      |                          std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:317:5: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  317 |     size_t _allocated;          // objects allocated
      |     ^~~~~~
      |     std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:318:5: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  318 |     size_t _size;                       // number objects in use
      |     ^~~~~~
      |     std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:303:19: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  303 |             const size_t newAllocated = cap * 2;
      |                   ^~~~~~
      |                   std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
In file included from tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.cpp:24:
tests/mechanical_layer/3rdparty/tinyxml/tinyxml2.h:332:13: error: unknown type name 'size_t'; did you mean 'std::size_t'?
  332 |     virtual size_t ItemSize() const = 0;
      |             ^~~~~~
      |             std::size_t
/opt/homebrew/Cellar/include-what-you-use/0.24/libexec/bin/../include/c++/v1/__cstddef/size_t.h:20:7: note: 'std::size_t' declared here
   20 | using size_t = decltype(sizeof(int));
      |       ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
tests/mechanical_layer/src/InputStatic.cpp:1:10: fatal error: 'InputStatic.h' file not found
    1 | #include "InputStatic.h"
      |          ^~~~~~~~~~~~~~~
In file included from tests/mechanical_layer/include/Crowd.h:4:
In file included from tests/mechanical_layer/include/Agent.h:4:
tests/mechanical_layer/include/Globals.h:4:10: fatal error: 'random' file not found
    4 | #include <random>
      |          ^~~~~~~~

